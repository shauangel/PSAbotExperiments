[{"link": "https://stackoverflow.com/questions/1481488/what-is-the-del-method-and-how-do-i-call-it", "keywords": [], "tags": ["python", "oop"], "question": {"id": 1481488, "title": "What is the __del__ method and how do I call it?", "content": "I saw a class in which a __del__ method is defined. This method is used to destroy an instance of the class. However, I cannot find a place where this method is used. How is this method used? Like that: obj1.del()?. How do I call the __del__ method?", "abstract": ""}, "answers": [{"id": 1481512, "score": 240, "vote": 0, "content": "__del__ is a finalizer. It is called when an object is garbage collected which happens at some point after all references to the object have been deleted. In a simple case this could be right after you say del x or, if x is a local variable, after the function ends. In particular, unless there are circular references, CPython (the standard Python implementation) will garbage collect immediately.* However, this is an implementation detail of CPython. The only required property of Python garbage collection is that it happens after all references have been deleted, so this might not necessary happen right after and might not happen at all. Even more, variables can live for a long time for many reasons, e.g. a propagating exception or module introspection can keep variable reference count greater than 0. Also, variable can be a part of cycle of references \u2014 CPython with garbage collection turned on breaks most, but not all, such cycles, and even then only periodically. Since you have no guarantee it's executed, one should never put the code that you need to be run into __del__() \u2014 instead, this code belongs to the finally clause of a try statement or to a context manager in a with statement. However, there are valid use cases for __del__: e.g. if an object X references Y and also keeps a copy of Y reference in a global cache (cache['X -> Y'] = Y) then it would be polite for X.__del__ to also delete the cache entry. If you know that the destructor provides (in violation of the above guideline) a required cleanup, you might want to call it directly, since there is nothing special about it as a method: x.__del__(). Obviously, you should only do so if you know it can be called twice. Or, as a last resort, you can redefine this method using * Reference: CPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable [...] Other implementations act differently and CPython may change.", "abstract": ""}, {"id": 56443562, "score": 3, "vote": 0, "content": "As mentioned earlier, the __del__ functionality is somewhat unreliable. In cases where it might seem useful, consider using the __enter__ and __exit__ methods instead. This will give a behaviour similar to the with open() as f: pass syntax used for accessing files. __enter__ is automatically called when entering the scope of with, while __exit__ is automatically called when exiting it. See this question for more details.", "abstract": ""}, {"id": 2452895, "score": 118, "vote": 0, "content": "I wrote up the answer for another question, though this is a more accurate question for it.   How do constructors and destructors work? Here is a slightly opinionated answer. Don't use __del__. This is not C++ or a language built for destructors. The __del__ method really should be gone in Python 3.x, though I'm sure someone will find a use case that makes sense. If you need to use __del__, be aware of the basic limitations per http://docs.python.org/reference/datamodel.html: But, on the other hand: And my pesonal reason for not liking the __del__ function. So, find a reason not to use __del__.", "abstract": ""}, {"id": 1481527, "score": 20, "vote": 0, "content": "The __del__ method, it will be called when the object is garbage collected.  Note that it isn't necessarily guaranteed to be called though.  The following code by itself won't necessarily do it: The reason being that del just decrements the reference count by one.  If something else has a reference to the object, __del__ won't get called. There are a few caveats to using __del__ though.  Generally, they usually just aren't very useful.  It sounds to me more like you want to use a close method or maybe a with statement. See the python documentation on __del__ methods. One other thing to note:  __del__ methods can inhibit garbage collection if overused.  In particular, a circular reference that has more than one object with a __del__ method won't get garbage collected.  This is because the garbage collector doesn't know which one to call first.  See the documentation on the gc module for more info.", "abstract": ""}, {"id": 1481523, "score": 13, "vote": 0, "content": "The __del__ method (note spelling!) is called when your object is finally destroyed.  Technically speaking (in cPython) that is when there are no more references to your object, ie when it goes out of scope. If you want to delete your object and thus call the __del__ method use which will delete the object (provided there weren't any other references to it). I suggest you write a small class like this And investigate in the python interpreter, eg Note that jython and ironpython have different rules as to exactly when the object is deleted and __del__ is called.  It isn't considered good practice to use __del__ though because of this and the fact that the object and its environment may be in an unknown state when it is called.  It isn't absolutely guaranteed __del__ will be called either - the interpreter can exit in various ways without deleteting all objects.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46957542/why-isnt-the-del-method-called", "keywords": [], "tags": ["python", "python-3.x", "python-multiprocessing", "circular-reference", "finalizer"], "question": {"id": 46957542, "title": "Why isn&#39;t the __del__ method called\uff1f", "content": "In python3's multiprocess,  can't call the __del__ method.   I've read other issues about circular references,but I can't find the situation in multiprocess.   There is a circular reference in foo, __del__ will be called when  foo is called directly,but in multiprocess the __del__ will never be called. Output:\ncall foo\ncall foo\ndel why __del__ is not called in p?", "abstract": ""}, "answers": [{"id": 46966357, "score": 3, "vote": 0, "content": "Forked Process objects terminate after running their task using os._exit(), which forcibly terminates the child process without the normal cleanup Python performs on exit. Cyclic garbage isn't cleaned (because the process is terminated without giving the cyclic GC a chance to run), it's just dropped on the floor, leaving the OS to clean up. This is intentional, since exiting normally (invoking all normal cleanup procedures) would risk stuff like unflushed buffers getting flushed in both parent and child (doubling output), and other weirdness involved when a forked process inherits all the state of the parent but isn't supposed to use it except when told to do so explicitly. You could write a wrapper function that would invoke the \"real\" function, then trigger a cycle collection before returning, but it's hard to write correctly and quite brittle. An initial stab at it would be something like: You'd use it by replacing: with: I don't really recommend this solution though. Ideally, if some cleanup (not related to process memory, which the OS cleans for you anyway) must occur in the child, you'd implement the context manager protocol on the relevant type(s) (contextlib.contextmanager can be used to provide such functionality for existing types you can't modify directly) and create/control them with with statements, which would guarantee cleanup was performed deterministically, even in the presence of cyclic references, even on non-CPython interpreters (which aren't reference counted, and therefore don't perform deterministic cleanup without with statements even when there are no cyclic references). Anything less than with statements (or try/finally blocks with equivalent effect) is going to be some combination of brittle, non-portable, or non-functional. Using context management, your class and function would look like: You'll actually see multiple del outputs now in some cases, particularly when you include the optional __del__ = close line as a backup when the user fails to context manage (where close and/or __exit__ gets invoked, then __del__ gets invoked later), but there's no harm there (the contained list just gets emptied twice).", "abstract": ""}, {"id": 46966427, "score": 1, "vote": 0, "content": "The question isn't actually why it isn't called in multiprocess, but why it is called in the other example. And the answer to that is that it isn't called when you call foo. It's called at the end of the program. Since the program is finished, Python knows that anything else can be cleaned up even if it's still referenced, so it cleans up circular references. If you add a print statement at the end of the script, or call this from the REPL, you can see that __del__ still isn't called at your second foo call either, but only at the end of the script. Given that Python cleans up circular references when the script ends, ShadowRanger's answer explains why that doesn't happen when the multiprocessing function is finished.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/74721464/del-not-implicitly-called-on-object-when-its-last-reference-gets-deleted", "keywords": [], "tags": ["python", "multithreading", "del"], "question": {"id": 74721464, "title": "__del__ not implicitly called on object when its last reference gets deleted", "content": "I have a class that starts a thread in its __init__ member and I would like join that thread when the instance of that class is not needed anymore, so I implemented that clean-up code in __del__. It turns out that the __del__ member is never called when the last reference of the instance gets deleted, however if I implicitly call del, it gets called. Below is a shorter modified version of my implementation that shows the issue. The console outputs the following for this code: The execution hangs since the thread is still running. For some reason I don't understand __del__ is not called, and as a result of that the thread is not terminated. If I uncomment the last line del mgr to explicitly delete the instance, then __del__ gets called and the thread clean-up occurs. Does anyone have an explanation for this?", "abstract": ""}, "answers": [{"id": 74721768, "score": 5, "vote": 0, "content": "Silvio's answer is correct, but incomplete. In fact, it's actually guaranteed that mgr won't be deleted in this case because: This ends up with a cyclic problem: The explicit del mgr here works, assuming no other references to mgr exist (implicitly or explicitly). You could get a safer, and automatic version of this cleanup by putting the code in a function, e.g. a standard design (that actually makes things run quicker by replacing use of dict-based globals with function array-based locals) is to put the main functionality in a function, then invoke it: It's still not perfect though; an exception can end up holding the frame object after main exits leading to non-deterministic cleanup (similarly, only the CPython reference interpreter uses reference-counting as its primary GC mechanism; on other Python interpreters cleanup is not deterministic). The only way to make this completely deterministic is to make your object a context manager, and use a with statement with it, e.g.:", "abstract": ""}, {"id": 74721536, "score": 3, "vote": 0, "content": "From the official documentation on __del__ It is not guaranteed that __del__() methods are called for objects that still exist when the interpreter exits. You have a reference at module-level called mgr to your object. That reference exists when your program terminates, so __del__ may or may not be called. To elaborate on some of the comments on the question, __del__ should not be thought of as a resource deallocator. That is to say, if you're coming from C++, __del__ is not the equivalent of a destructor. __del__ may or may not run (for instance, as indicated above it will not run at program exit), and even if it does, it may run far later in the program than you anticipated, depending on how the garbage collector feels about you. If you're looking for resource allocation that gets freed when you say so, you want a context manager. I don't know your exact use case, but if you want to create a mgr object that's freed at the end of a particular block of code, you can write something like", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6104535/i-dont-understand-this-python-del-behaviour", "keywords": [], "tags": ["python", "del"], "question": {"id": 6104535, "title": "I don&#39;t understand this python __del__ behaviour", "content": "Can someone explain why the following code behaves the way it does: The output (note that the destructor for d2 is never called) is this (python 2.7) Is there a way to \"fix\" the code so the destructor is called without deleting the method added?  I mean, the best place to put the d2.func = None would be in the destructor! Thanks [edit] Based on the first few answers, I'd like to clarify that I'm not asking about the merits (or lack thereof) of using __del__.  I tried to create the shortest function that would demonstrate what I consider to be non-intuitive behavior.  I'm assuming a circular reference has been created, but I'm not sure why.  If possible, I'd like to know how to avoid the circular reference....", "abstract": ""}, "answers": [{"id": 69011988, "score": 0, "vote": 0, "content": "use eval()", "abstract": ""}, {"id": 6104605, "score": 11, "vote": 0, "content": "Instead of del, you can use the with operator. http://effbot.org/zone/python-with-statement.htm just like with filetype objects, you could something like", "abstract": ""}, {"id": 17074919, "score": 2, "vote": 0, "content": "It seems to me the real heart of the matter is here: adding the functions is dynamic (at runtime) and not known in advance I sense that what you are really after is a flexible way to bind different functionality to an object representing program state, also known as polymorphism.  Python does that quite well, not by attaching/detaching methods, but by instantiating different classes.  I suggest you look again at your class organization.  Perhaps you need to separate a core, persistent data object from transient state objects.  Use the has-a paradigm rather than is-a: each time state changes, you either wrap the core data in a state object, or you assign the new state object to an attribute of the core. If you're sure you can't use that kind of pythonic OOP, you could still work around your problem another way by defining all your functions in the class to begin with and subsequently binding them to additional instance attributes (unless you're compiling these functions on the fly from user input):", "abstract": ""}, {"id": 6165533, "score": 29, "vote": 0, "content": "I'm providing my own answer because, while I appreciate the advice to avoid __del__, my question was how to get it to work properly for the code sample provided. Short version: The following code uses weakref to avoid the circular reference.  I thought I'd tried this before posting the question, but I guess I must have done something wrong. Longer version:\nWhen I posted the question, I did search for similar questions.  I know you can use with instead, and that the prevailing sentiment is that __del__ is BAD.   Using with makes sense, but only in certain situations.  Opening a file, reading it, and closing it is a good example where with is a perfectly good solution.  You've gone a specific block of code where the object is needed, and you want to clean up the object and the end of the block. A database connection seems to be used often as an example that doesn't work well using with, since you usually need to leave the section of code that creates the connection and have the connection closed in a more event-driven (rather than sequential) timeframe.   If with is not the right solution, I see two alternatives:  While I tried to provide simplified code, my real problem is more event-driven, so with is not an appropriate solution (with is fine for the simplified code).  I also wanted to avoid atexit, as my program can be long-running, and I want to be able to perform the cleanup as soon as possible. So, in this specific case, I find it to be the best solution to use weakref and prevent circular references that would prevent __del__ from working. This may be an exception to the rule, but there are use-cases where using weakref and __del__ is the right implementation, IMHO.", "abstract": ""}, {"id": 46381340, "score": 0, "vote": 0, "content": "An alternative solution to using weakref is to dynamically bind the function to the instance only when it is called by overriding __getattr__ or __getattribute__ on the class to return func.__get__(self, type(self)) instead of just func for functions bound to the instance.  This is how functions defined on the class behave.  Unfortunately (for some use cases) python doesn't perform the same logic for functions attached to the instance itself, but you can modify it to do this.  I've had similar problems with descriptors bound to instances.  Performance here probably isn't as good as using weakref, but it is an option that will work transparently for any dynamically assigned function with the use of only python builtins. If you find yourself doing this often, you might want a custom metaclass that does dynamic binding of instance-level functions. Another alternative is to add the function directly to the class, which will then properly perform the binding when it's called. For a lot of use cases, this would have some headaches involved: namely, properly namespacing the functions so they don't collide.  The instance id could be used for this, though, since the id in cPython isn't guaranteed unique over the life of the program, you'd need to ponder this a bit to make sure it works for your use case... in particular, you probably need to make sure you delete the class function when an object goes out of scope, and thus its id/memory address is available again. __del__ is perfect for this :). Alternatively, you could clear out all methods namespaced to the instance on object creation (in __init__ or __new__).  Another alternative (rather than messing with python magic methods) is to explicitly add a method for calling your dynamically bound functions.  This has the downside that your users can't call your function using normal python syntax: Just to make this post complete, I'll show your weakref option as well:", "abstract": ""}, {"id": 6169031, "score": 1, "vote": 0, "content": "A full example of a context manager.  ", "abstract": ""}, {"id": 6104645, "score": 9, "vote": 0, "content": "del doesn't call __del__ del in the way you are using removes a local variable. __del__ is called when the object is destroyed. Python as a language makes no guarantees as to when it will destroy an object. CPython as the most common implementation of Python, uses reference counting. As a result del will often work as you expect. However it will not work in the case that you have a reference cycle.  Python doesn't detect this and so won't clean it up right away. And its not just reference cycles. If an exception is throw you probably want to still call your destructor. However, Python will typically hold onto to the local variables as part of its traceback. The solution is not to depend on the __del__ method. Rather, use a context manager.  This is guaranteed to work, and you can even check the parameters to see whether you are handling an exception and do something different in that case. ", "abstract": ""}, {"id": 6104568, "score": 46, "vote": 0, "content": "You cannot assume that __del__ will ever be called - it is not a place to hope that resources are automagically deallocated.  If you want to make sure that a (non-memory) resource is released, you should make a release() or similar method and then call that explicitly (or use it in a context manager as pointed out by Thanatos in comments below). At the very least you should read the __del__ documentation very closely, and then you should probably not try to use __del__. (Also refer to the gc.garbage documentation for other bad things about __del__)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/59508235/what-is-the-difference-between-del-and-delete", "keywords": [], "tags": ["python", "python-3.x", "destructor", "destruction"], "question": {"id": 59508235, "title": "What is the difference between `__del__` and `__delete__`?", "content": "Suppose someone didn't know what the difference was between __del__ and __delete__? Write an explanation.", "abstract": ""}, "answers": [{"id": 67250611, "score": 0, "vote": 0, "content": "Called when the instance is about to be destroyed. This is also called a finalizer or (improperly) a destructor. If a base class has a __del__() method, the derived class\u2019s __del__() method, if any, must explicitly call it to ensure proper deletion of the base class part of the instance. I think this means that my_object.__del__ will get called by CPython's garbage collector after the reference count for my_object drops to zero. Called to delete the attribute on an instance instance of the owner class. The __delete__ dunder method is related to python's notion of descriptors; a descriptor is \"any object which defines the methods __get__(), __set__(), or __delete__().\" Descriptors can be used to implement custom behavior for attribute lookup/assignment/deletion (via __get__/__set__/__delete__, respectively).", "abstract": ""}, {"id": 59508236, "score": -3, "vote": 0, "content": "__del__ is called when you delete an object and __delete__ is sometimes called when you delete an attribute of an object.            The following code shows when __del__ gets called:       If my_instance is the last label pointing to the data, then del my_instance calls MyClass.__del__(my_instance)  Technically, del my_instance only deletes the label my_instance. Imagine people at a party all wearing names tags. Sometimes a person has 6 or 7 names tags on simultaneously, and other times, they only have one. Python will kick anyone out of the party who is not wearing at least one name tag. MyClass.__del__(my_instance) gets called when the last name-tag/label is removed from a piece of data. The code above shows an example of when we make sure to close an open file. Another example might be to count of the number active instances of a given class: Unlike __del__, __delete__ has to do with descriptors.\nThe code below describes the behavior of obj.my_var or getattr(obj, \u201cmy_var\u201d) class Klaus:\n    def getattribute(self, attrname):\n        try:\n            attribute = attrname from instance Klaus\n        except AttributeError:\n            attribute = attrname from class Klaus If my_var is a descriptor, then following two lines of code equivalent:         Just as __getattribute__ checks whether the attribute has a __get__ method or not, __delattr__ will check whether the attribute has a __delete__ method or not. You can see when __delete__ gets called by viewing the following code: When dealing with descriptors, the following lines of code are all equivalent:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/36722390/python-3-super-del", "keywords": [], "tags": ["python", "python-3.x", "destructor", "super"], "question": {"id": 36722390, "title": "Python 3, super.__del__()", "content": "I have a __del__ method in a class I've defined, to delete some C++ objects created by calling C++ new in a ctypes interface. I want to delete these objects when an instance of my class is destroyed. I have a fragment of the class shown here: When an instance of my Graph class is deleted, the __del__ method is called and I see my print statement and when I set a breakpoint in the destructor method in the C++ code, as expected, it deletes the object. However, when my __del__ method calls super().__del__(), I get the error message: How do I ensure that the parent class (QtCore.QObject) is deleted if I define my own __del__ method in the child class or will the parent class be deleted automatically?", "abstract": ""}, "answers": [{"id": 36723532, "score": 4, "vote": 0, "content": "The class you're deriving from doesn't have __del__(). So trying to call it is an error. Now, if you expect your class to be used in a multiple inheritance scenario, the next class in the method resolution order (MRO) might not actually be your class's parent. And that class, whatever it is, might have a __del__() method. So, if you're concerned about that case, you could use try and swallow the AttributeError, or use hasattr(), or use getattr() with a dummy lambda as a default value. Here's an example of each:", "abstract": ""}, {"id": 59870543, "score": 0, "vote": 0, "content": "From the official documentation, Called when the instance is about to be destroyed. This is also called a finalizer or (improperly) a destructor. If a base class has a del() method, the derived class\u2019s del() method, if any, must explicitly call it to ensure proper deletion of the base class part of the instance. Correct me if I'm wrong. If the base class doesn't provide __del__, you don't have to call it. Catching AttributeError and ignoring it is a good way.", "abstract": ""}, {"id": 36729117, "score": 6, "vote": 0, "content": "The role of __del__ is not to delete the object: it is called before the object is automatically deleted. Therefore it's fine if your parent class doesn't define __del__. Feel free not to call super().__del__() if it's bugging you. For the record, the reason why objects don't have a default __del__ is that objects with __del__ were not garbage collected in case of reference cycles (until Python 3.4). For more information, read the documentation for gc.garbage in Python 3.3 and for gc.garbage in Python 3.4.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/53917228/deleting-the-del-method-from-an-existing-object-in-python", "keywords": [], "tags": ["python"], "question": {"id": 53917228, "title": "Deleting the &#39;__del__&#39; method from an existing object in Python", "content": "I have an application with a ProcessPoolExecutor, to which I deliver an object instance that has a destructor implemented using the __del__ method. The problem is, that the __del__ method deletes files from the disk, that are common to all the threads (processes). When a process in the pool finishes its job, it calls the __del__ method of the object it got and thus ruins the resources of the other threads (processes). I tried to prepare a \"safe\" object, without a destructor, which I would use when submitting jobs to the pool: But the delattr call fails with the following error: Any idea how to get rid of the __del__ method of an existing object at runtime?  UPDATE - My solution: Eventually I solved it using quite an elegant workaround: So the field orig_id is only computed for the original object, where the constructor is really executed. The other object \"clones\" are created using a deep-copy, so their orig_id value will contain the id of the original object. Thus, when the clones are destroyed and call __del__, they will compare their own id with the original object id and will return, as the IDs will not match. Thus, only the original object will pass into executing __del__.", "abstract": ""}, "answers": [{"id": 53917547, "score": 2, "vote": 0, "content": "The best thing yo do there, if you have access to the object's class code, is not to rely on __del__ at all. The fact of __del__ having a permanent side-effect could be a problem by itself, but in an environment using multiprocessing it is definitively a no-go! Here is why: first __del__ is a method that lies on the instance's class, as most \"magic\" methods (and that is why you can't delete it from an instance). Second: __del__ is called when references to an object reach zero. However, if you don't have any reference to an object on the \"master\" process, that does not mean all the child processes are over with it. This is likely the source of your problem: reference counting for objects are independent in each process. And third: you don't have that much control on when __del__ is called, even in a single process application. It is not hard to have a dangling reference to an object in a dictionary, or cache somewhere - so tying important application behavior to __del__ is normally discouraged. And all of this is only for recent Python versions (~ > 3.5), as prior to that, __del__ would be even more unreliable, and Python would not ensure it was called at all. So, as the other answers put it, you could try snooze __del__ directly on the class, but that would have to be done on the object's class in all the sub-processes as well.   Therefore the way I recommend you to do this is to have a method to be explicitly  called that will perform the file-erasing and other side-effects when disposing of an object. You simply rename your __del__ method and call it just on the main process. If you want to ensure this \"destructor\" to be called,Python does offer some automatic control with the context protocol: you will then use your objects within a with statement block - and destroy it with inside an __exit__ method. This method is called automatically at the end of the with block. Of course, you will have to devise a way for the with block just to be left when work in the subprocess on the instance have finished. That is why in this case, I think an ordinary, explicit, clean-up method that would be called on your main process when consuming the \"result\" of whatever you executed off-process would be easier. In case you can't change the source code for the object's class, inherit it, \noverride __del__ with a no-op method, and force the object's __class__ atribute to the inherited class before submitting it to other processes: (please note that the \"with\" statement above is from the recommended usage for ProcessPoolExecutor, from the docs, not for the custom __exit__ method I suggested you using earlier in the answer. Having a with block equivalent that will allow you to take full advantage of the ProcessPoolExecutor will require some ingenuity into it)", "abstract": ""}, {"id": 53917343, "score": 1, "vote": 0, "content": "In general, methods belong to the class. While generally you can shadow a method on an instance, special \"dunder\" methods are optimized to check the class first regardless. So consider: You can read more about this behavior in the docs For custom classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object\u2019s type, not in the object\u2019s instance dictionary. I think the cleanest solution if you are using multiprocessing is to simply derive from the class and override __del__. I fear that monkey-patching the class will not play nice with multiprocessing, unless you monkey patch the class in all the processes. Not sure how the pickleing will work out here.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/32975036/why-is-del-called-at-the-end-of-a-with-block", "keywords": [], "tags": ["python", "mysql-python", "with-statement"], "question": {"id": 32975036, "title": "Why is __del__ called at the end of a with block?", "content": "The scope of the variables created in a with statement is outside the with block (refer: Variable defined with with-statement available outside of with-block?). But when I run the following code: The output shows that Foo.__del__ is called before printing foo (at # line 1 above): My question is, why is Foo.__del__ called here, if the with statement does not create a new execution scope? Also, if the connection's __del__ method is called in the second with block, I don't understand why my_curs1.connection is still open afterward (see # line 2 above).", "abstract": ""}, "answers": [{"id": 32977732, "score": 7, "vote": 0, "content": "It's important to note that foo is not an object of type Foo.  You do create a Foo and need to keep it around because it might contain state information needed to call __exit__.  But once that's done, the object is unneeded and Python's free to throw it away. Put another way, this: Is the same as this: The behavior you are expecting would happen if foo were a reference to the with block's foo.  For example... Prints I have no idea why Connection.__exit__ would leave its cursors open however.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/21766584/is-overriding-del-the-best-choice-here", "keywords": [], "tags": ["python", "python-2.7", "overriding", "del"], "question": {"id": 21766584, "title": "Is overriding __del__() the best choice here?", "content": "I am trying to figure out the best way to remove something, preferably without having to write in a lot of code. In my project I am simulating chemical compounds - I have Element instances bonded to other Element instances via a Bond instance.  In chemistry bonds often break, and I'd like to have a clean way to do that.  My current method is something like as follows I want to do something like Alternately, something like this would be fine Is any one of these ways of doing it preferable to the others, or is there some other way of doing this that I'm overlooking?", "abstract": ""}, "answers": [{"id": 21766679, "score": 5, "vote": 0, "content": "Python uses garbage collection to manager memory, which means you do not have to delete anything. This class is fine: note that del does not delete anything from memory! It simply removes a reference to an object, but objects can have more than one reference: After the last del c the interpreter can deallocate the list. In CPython the deallocation will be done immediately (in this simple case), however in other implementation of the language the interpreter might not deallocate the list immediately. Also note that __del__'s documentation cites this fact. Furthermore it is a really low-level method which you don't need 99.9% of the time, so it certainly isn't the right way to handle your situation.", "abstract": ""}, {"id": 21766697, "score": 1, "vote": 0, "content": "The first way is pretty tedious and error-prone. The second is fine, but the del self in Bond.breakBond is completely and utterly pointless (more on this below). The third is hacky, unreliable, and in this specific case not working at all (due to the circular reference between Bond and Elements, __del__ is never invoked unless you upgrade to Python 3.4, but even then it remains hacky and unreliable). del name only removes the local name, it does not call __del__ or otherwise affect the object. It has absolutely no effect on memory management, except possibly allowing earlier garbage collection if name was the last (reachable) reference. You should do this:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1684099/is-it-possible-to-delete-a-method-from-an-object-not-class-in-python", "keywords": [], "tags": ["python"], "question": {"id": 1684099, "title": "Is it possible to delete a method from an object (not class) in python?", "content": "I have a class with a few methods, some of which are only valid when the object is in a particular state. I would like to have the methods simply not be bound to the objects when they're not in a suitable state, so that I get something like: I can see how to add methods (types.MethodType(method, object)), but I can't see any way to delete a method for just a single object: Overriding __dir__ (and getting an InvalidState or NotEnoughMana exception on invocation instead of AttributeError on reference) might be okay, but I can't see how to mimic the built-in behaviour of dir() accurately. (Ideally I'd prefer a way that works in Python 2.5, too) Ideas?", "abstract": ""}, "answers": [{"id": 15821030, "score": 0, "vote": 0, "content": "While I agree that this is the wrong solution, my way to \"remove\" a method would be to overwrite the function with a property that raises an AttributeError. This way hasattr gives the correct result, but it is not as much hassle as using dir.", "abstract": ""}, {"id": 9537218, "score": 2, "vote": 0, "content": "As an additional possibility (twisting the question a little bit), if it makes more sense to only have certain methods on certain instances, you can always add those methods in the __init__ of the class to those instances for which it makes sense.  Ex: say we have your Wizard class, and the only time a Wizard instance should have the domagic() method is if a magic parameter passed to __init__() is True.  We could then do something like: Having said that, this code does have a bit of smell to it -- now before you call domagic() on a Wizard, you need to know if the method is defined or not.  I wonder if the inheritance heirarchy could be refined a bit to make this a bit more elegant.", "abstract": ""}, {"id": 1684969, "score": 1, "vote": 0, "content": "There seem to be some pretty good ideas to address the explicit question of how to hide/remove a method from a python object, so I'd like to address a higher level question.   Specifically, the problem statement from the original question: I have a class with a few methods,\n  some of which are only valid when the\n  object is in a particular state. This situation is a classic example of the problem solved via the State Design Pattern: This pattern is used in computer\n  programming to represent the state of\n  an object. This is a clean way for an\n  object to partially change its type at\n  runtime. I would consider using this pattern if your Wizard has the following properties:", "abstract": ""}, {"id": 1684488, "score": 4, "vote": 0, "content": "Looks like the way to dir() works by default is: (well, removing duplicates anyway) So an approach would be: With the behaviour in Py2.6 being:", "abstract": ""}, {"id": 1684267, "score": 15, "vote": 0, "content": "You can't delete a class method from an instance of that class because the instance doesn't have that method.  The protocol is:  if o is an instance of class Foo, and I call o.bar(), first o is examined to see if it has a method named bar.  If it doesn't, then Foo is examined.  The methods aren't bound to the instance unless they override its class. I don't see any good that can come from the road that you're going down here, either.", "abstract": ""}, {"id": 1684183, "score": 9, "vote": 0, "content": "This isn't directly answering your question, but I think a better approach to solving this problem would be to not add/remove the member method domagic on your wiz object: What I would do instead is within the domagic method, add a condition that checks for the relevant state of the wiz object, and then only perform the rest of the domagic method for a valid state, otherwise outputting an error message of your choosing.", "abstract": ""}, {"id": 1684219, "score": 2, "vote": 0, "content": "You can use a hack like that: Of course, this gives you wrong traceback, but exception is the same. ;-) Another (IMHO - better) way is to override __getattr__ and then put dispatch logic there, then you can use it like that:", "abstract": ""}, {"id": 1684190, "score": 6, "vote": 0, "content": "If an object is in a state where calling a given method on that object doesn't make sense, having it disappear from the object's interface seems like the wrong way to handle the problem.  More explicit error handling gives you the ability to explain the problem more precisely to your callers, throwing NotEnoughMana instead of presenting them with a method-not-found error. If you're worried about having a bunch of function prefixes that look like this: ...then you could use a decorator on each function.  It's shorter, and gives you an easy way to grep for all special-state-requiring functions.", "abstract": ""}]}]