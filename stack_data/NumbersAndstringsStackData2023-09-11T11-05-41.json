[{"link": "https://stackoverflow.com/questions/74427749/syntaxerror-cannot-assign-to-expression-and-syntaxerror-invalid-decimal-lit", "keywords": [], "tags": ["python", "python-3.x", "web-scraping", "beautifulsoup", "python-requests"], "question": {"id": 74427749, "title": "&quot;SyntaxError: cannot assign to expression&quot; and &quot;SyntaxError: invalid decimal literal&quot; for class name with spaces and numbers inside a div", "content": "I'm trying to make a web scraper for a website to let me know when an new item is available, but I encountered this problem in my code when trying to ask it to print me the URL: Line 16 shows: SyntaxError: cannot assign to expression Line 17 shows: SyntaxError: invalid decimal literal I tried changing the long name of the class for \"class_\" so it could take the entire class name: but it shows a new error: TypeError: 'NoneType' object is not iterable What I'm trying to do with this code is using beautifulsoup to get everything from the page with r.content, then making a soup.find to get inside the div, the class that is called \"h-full aspect-h-16 aspect-w-16 ng-tns-c75-1\" exactly like that inside the elements. Now inside the div of the class, I want to the \"a\" which got the link I'm after, the href, then I did the for for the name of the class inside the variable of the soup.find and asking it for the link inside the class name.find_all. But it shows those errors I think it's because of the name of the class, but not sure how to deal with it. I'm using sublimetext 3 with python version  3.11.0", "abstract": ""}, "answers": [{"id": 74428565, "score": 0, "vote": 0, "content": "This is one way of obtaining the data - as a dataframe - and then you can scrape that endpoint at regular intervals, like every 3 hours - and compare the results with something like first_df.compare(second_df): Result in terminal: Pandas documentation (to learn how you can implement compare, really straightforward) can be found at https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.compare.html For running the script at regular intervals, you can use schedule: https://pypi.org/project/schedule/\nTake this as a learning opportunity, I'm sure you'll be fine. If you still cannot manage it, do tell and me (or someone else) will offer further help.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/74097754/not-able-to-access-attribute-which-name-begins-with-a-digit", "keywords": [], "tags": ["python", "syntax-error", "pcap", "pyshark"], "question": {"id": 74097754, "title": "Not able to access attribute which name begins with a digit", "content": "I am using Pyshark to parse a PCAP. There are some object which name begin with digit say pkt.diameter.3gpp_reporting_reason. I'm not able to refer to this object, because I get an error \"invalid decimal literal\". Any ideas how to retrieve the attribute pkt.diameter.3gpp_reporting_reason.all_fields? Screenshot of error message", "abstract": ""}, "answers": [{"id": 74097891, "score": 2, "vote": 0, "content": "The issue is that names starting with digits aren't valid identifiers in python. While python is reading your code, it things you are entering a number. To still access the attribute, use getattr.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/9380077/why-cant-i-access-a-property-of-an-integer-with-a-single-dot", "keywords": [], "tags": ["javascript", "syntax"], "question": {"id": 9380077, "title": "Why can&#39;t I access a property of an integer with a single dot?", "content": "If I try to write there is a syntax error. Using double dots, putting in a space, putting the three in parentheses or using bracket notation allows it to work properly. Why doesn't the single dot notation work and which one of these alternatives should I use instead?", "abstract": ""}, "answers": [{"id": 67972383, "score": 0, "vote": 0, "content": "As others have mentioned, Javascript parser interprets the dot after Integer literals as a decimal point and hence it won't invoke the methods or properties on Number object. To explicitly inform JS parser to invoke the properties or methods on Integer literals, you can use any of the below options:", "abstract": ""}, {"id": 9380280, "score": 22, "vote": 0, "content": "The period is part of the number, so the code will be interpreted the same as: This will naturally give a syntax error, as you can't immediately follow the number with an identifier. Any method that keeps the period from being interpreted as part of the number would work. I think that the clearest way is to put parentheses around the number:", "abstract": ""}, {"id": 9380399, "score": 4, "vote": 0, "content": "This is an ambiguity in the Javascript grammar. When the parser has got some digits and then encounters a dot, it has a choice between \"NumberLiteral\" (like 3.5) or \"MemberExpression\" (like 3.foo). I guess this ambiguity cannot be resolved by lookahead because of scientific notation - should 3.e2 be interpreted as 300 or a property e2 of 3? Therefore they voluntary decided to prefer NumberLiterals here, just because there's actually not very much demand for things like 3.foo.", "abstract": ""}, {"id": 9380107, "score": 12, "vote": 0, "content": "You can't access it because of a flaw in JavaScript's tokenizer. Javascript tries to parse the dot notation on a number as a floating point literal, so you can't follow it with a property or method: 2.toString(); // raises SyntaxError As you mentioned, there are a couple of workarounds which can be used in order make number literals act as objects too. Any of these is equally valid. To understand more behind object usage and properties, check out the Javascript Garden.", "abstract": ""}, {"id": 9380123, "score": 5, "vote": 0, "content": "It doesn't work because JavaScript interprets the 3. as being either the start of a floating-point constant (such as 3.5) or else an entire floating-point constant (with 3. == 3.0), so you can't follow it by an identifier (in your case, a property-name). It fails to recognize that you intended the 3 and the . to be two separate tokens. Any of your workarounds looks fine to me.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64935152/python3-int-sizeof-produces-syntax-error", "keywords": [], "tags": ["python", "oop", "integer"], "question": {"id": 64935152, "title": "Python3 int.__sizeof__() produces syntax error", "content": "The following code produces a syntax error. Does anyone know why syntax errors result when using object attributes?", "abstract": ""}, "answers": [{"id": 64935249, "score": 7, "vote": 0, "content": "The lexer is greedy, so it recognizes 1.__sizeof__() as float literal 1. followed by an identifier __sizeof__, rather than an int literal followed by a . operator. Use parentheses to override assist the lexer:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/26255693/attribute-access-on-int-literals", "keywords": [], "tags": ["python", "parsing", "grammar", "lexical-analysis"], "question": {"id": 26255693, "title": "Attribute access on int literals", "content": "It has been covered here before that the second example doesn't work because the int literal is actually parsed as a float.   My question is, why doesn't python parse this as attribute access on an int, when the interpretation as a float is a syntax error?  The docs section on lexical analysis seem to suggest whitespace only required when other interpretations are ambiguous, but perhaps I'm reading this section wrong.   On a hunch it seems like the lexer is greedy (trying to take the biggest token possible), but I have no source for this claim.  ", "abstract": ""}, "answers": [{"id": 26258548, "score": 2, "vote": 0, "content": "Read carefully, it says Whitespace is needed between two tokens only if their concatenation could otherwise be interpreted as a different token (e.g., ab is one token, but a b is two tokens). 1.__hash__() is tokenized as: Python's lexer will choose a token which comprises the longest possible string that forms a legal token, when read from left to right; after parsing no two tokens should be able to be combined into a valid token. The logic is very similar to that in your other question. The confusion seems to be not recognizing the tokenizing step as a completely distinct step. If the grammar allowed splitting up tokens solely to make the parser happy then surely you'd expect  to tokenize as but there is no such rule, so it tokenizes as", "abstract": ""}, {"id": 26256242, "score": 3, "vote": 0, "content": "It\u2019s simply a matter of definition; for languages the grammar does the job. Attribute references are defined at a much broader level than floating point literals. So from a grammar level, the parser has to recognize 1. as a floating point literal and not as a attribute reference. Of course, the parser itself could backtrack when reaching the _ and try to figure out that it\u2019s not a floating point literal but an attribute reference instead. However, since CPython\u2019s parser is a LL(1) parser backtracking is not an option. As such, the grammar would have to be changed a lot to allow the parser to recognize this (although I\u2019m not sure right now if it\u2019s even possible with a LL(1) parser). We could also change Python\u2019s parser to something else, maybe one that does backtrack, but doing so is not only a very difficult task (it also would require to change the grammar) but would increase the complexity of the parsing process a lot (and with that likely decrease the speed). So maybe it would be possible, but it would require major changes in the language specification. And that alone would be problematic. It also would break existing code that make use of this early float recognition, e.g. 1.if True else 0.", "abstract": ""}, {"id": 26256232, "score": 3, "vote": 0, "content": "The lexer is very simple, and will not backtrack.  Language parsers are often divided into a lexing phase and a parsing phase, or a lexer and a parser.  The lexer breaks the character stream into tokens, and then the parser determines a program structure from the tokens.  The lexer sees four tokens: 1., __hash__, (, ): float, identifier, open-paren, close-paren.  The parser can't make sense of those tokens, but that doesn't mean the lexer will try to lex the characters differently.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/33054229/accessing-attributes-on-literals-work-on-all-types-but-not-int-why", "keywords": [], "tags": ["python", "python-2.7", "python-3.x", "language-lawyer"], "question": {"id": 33054229, "title": "Accessing attributes on literals work on all types, but not `int`; why?", "content": "I have read that everything in python is an object, and as such I started to experiment with different types and invoking __str__ on them \u2014 at first I was feeling really excited, but then I got confused.", "abstract": ""}, "answers": [{"id": 33054230, "score": 53, "vote": 0, "content": "123 is just as much of an object as 3.14, the \"problem\" lies within the grammar rules of the language; the parser thinks we are about to define a float \u2014 not an int with a trailing method call. We will get the expected behavior if we wrap the number in parenthesis, as in the below. Or if we simply add some whitespace after 123:  The reason it does not work for 123.__str__() is that the dot following the 123 is interpreted as the decimal-point of some partially declared floating-point. The parser tries to interpret __str__() as a sequence of digits, but obviously fails \u2014 and we get a SyntaxError basically saying that the parser stumbled upon something that it did not expect.  When looking at 123.__str__() the python parser could use either 3 characters and interpret these 3 characters as an integer, or it could use 4 characters and interpret these as the start of a floating-point. Just as a little child would like as much cake as possible on their plate, the parser is greedy and would like to swallow as much as it can all at once \u2014 even if this isn't always the best of ideas \u2014as such the latter (\"better\") alternative is chosen. When it later realizes that __str__() can in no way be interpreted as the decimals of a floating-point it is already too late; SyntaxError. Note In the above snippet, 123\u00a0 (note the space) must be interpreted as an integer since no number can contain spaces. This means that it is semantically equivalent to (123).__str__(). Note The above also works because a number can contain at most one decimal-point, meaning that it is equivalent to (123.).__str__().  This section contains the lexical definition of the relevant literals. Lexical analysis - 2.4.5 Floating point literals\n Lexical analysis - 2.4.4 Integer literals\n", "abstract": ""}, {"id": 10955711, "score": 41, "vote": 0, "content": "Add a space after the 4: Otherwise, the lexer will split this expression into the tokens \"4.\", \"__str__\", \"(\" and \")\", i.e. the first token is interpreted as a floating point number.  The lexer always tries to build the longest possible token.", "abstract": ""}, {"id": 10955713, "score": 89, "vote": 0, "content": "You need parens: The problem is the lexer thinks \"4.\" is going to be a floating-point number. Also, this works:", "abstract": ""}, {"id": 10955754, "score": 6, "vote": 0, "content": "actually (to increase unreadability...): is valid, too. it gives '0x1.0000000000000p+2' -- but then it's a float, of course...", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/31037609/why-is-1-real-a-syntax-error-but-1-real-valid-in-python", "keywords": [], "tags": ["python"], "question": {"id": 31037609, "title": "Why is &quot;1.real&quot; a syntax error but &quot;1 .real&quot; valid in Python?", "content": "So I saw these two questions on twitter. How is 1.real a syntax error but 1 .real is not?", "abstract": ""}, "answers": [{"id": 31038206, "score": 1, "vote": 0, "content": "1 .real works because it is the attribute .real called on the integer 1. 1.real does not work, because you imperatively need a space at the end of a float. Otherwise it is a syntax error.", "abstract": ""}, {"id": 31037690, "score": 11, "vote": 0, "content": "With 1.real Python is looking for a floating-point numeric literal like 1.0 and you can't have an r in a float. With 1 .real Python has taken 1 as an integer and is doing the attribute lookup on that. It's important to note that the floating-point syntax error handling happens before the . attribute lookup.", "abstract": ""}, {"id": 31037917, "score": 57, "vote": 0, "content": "I guess that the . is greedily parsed as part of a number, if possible, making it the float 1., instead of being part of the method call. Spaces are not allowed around the decimal point, but you can have spaces before and after the . in a method call. If the number is followed by a space, the parse of the number is terminated, so it's unambiguous. Let's look at the different cases and how they are parsed:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/30368910/why-does-00-0-cause-a-syntax-error", "keywords": [], "tags": ["javascript", "numbers", "syntax-error"], "question": {"id": 30368910, "title": "Why does 00.0 cause a syntax error?", "content": "This is weird.  This is what happens at the JavaScript console in Chrome (version 42.0.2311.135, 64-bit). Firefox 37.0.2 does the same, although its error message is: There's probably some technical explanation regarding the way JavaScript parses numbers, and perhaps it can only happen when tinkering at the console prompt, but it still seems wrong. Why does it do that?", "abstract": ""}, "answers": [{"id": 30371933, "score": 76, "vote": 0, "content": "The expressions 0.0 and 00.0 are parsed differently. Your code throws syntax error because 0 is not a valid JavaScript identifier. The following example works since toString is a valid identifier: 1 Section 7.8.3 \u2013 Leading 0 can be followed by decimal separator or ExponentPart\n2 Section B.1.1 \u2013 Leading 0 can be followed by OctalDigits", "abstract": ""}, {"id": 30369152, "score": 22, "vote": 0, "content": "00 is evaluated as an octal number and .0 is evaluated as accessing that number's property. But since integers are not allowed to be used as property accessors, the error is thrown. You get the same error for any other object: You can find related information about property accessors on MDN.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/29373310/syntaxerror-unterminated-string-literal", "keywords": [], "tags": ["javascript", "html"], "question": {"id": 29373310, "title": "SyntaxError: unterminated string literal", "content": "Hi I am trying to load some comtent in my html page from js. js code(relevant)- and it is alerting correctly but when I click on the button it gives error -  and when I checked inspect element I found problem in button tag - I don't know why it is happening. Someone please help me. Thanks in advance.", "abstract": ""}, "answers": [{"id": 29373511, "score": 1, "vote": 0, "content": "The short answer is: Because you are constructing HTML by mashing together strings. You've got an HTML attribute value that is delimited by ' characters. Inside that value you are putting a ' without escaping it (as &#34;). Since it isn't escaped, it terminates the attribute value. Use DOM (createElement, setAttribute, appendChild, etc.) instead.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11802214/integer-literal-is-an-object-in-python", "keywords": [], "tags": ["python", "syntax"], "question": {"id": 11802214, "title": "Integer literal is an object in Python?", "content": "Possible Duplicate:\naccessing a python int literals methods  Everything in Python is an object. Even a number is an object: I tried the following, because we should be able to access class members of an object:  Why does this not work?", "abstract": ""}, "answers": [{"id": 11802308, "score": 7, "vote": 0, "content": "Although the behaviour with 1.real seems unlogical, it is expected due to the language specification: Python interprets 1. as a float (see floating point literals). But as @mutzmatron pointed out (1).real works because the expression in brackets is a valid Python object.  Update: Note the following pits:", "abstract": ""}, {"id": 11802500, "score": 7, "vote": 0, "content": "a language is usually built in three layers. when you provide a program to a language it first has to \"read\" the program.  then it builds what it has read into something it can work with.  and finally it runs that thing as \"a program\" and (hopefully) prints a result. the problem here is that the first part of python - the part that reads programs - is confused.  it's confused because it's not clever enough to know the difference between  and  what seems to be happening is that it thinks you were trying to type a number like 1.234 but made a mistake and typed letters instead(!). so this has nothing to do with what 1 \"really is\" and whether or not is it an object.  all that kind of logic happens in the second and third stages i described earlier, when python tries to build and then run the program. what you've uncovered is just a strange (but interesting!) wrinkle in how python reads programs. [i'd call it a bug, but it's probably like this for a reason.  it turns out that some things are hard for computers to read.  python is probably designed so that it's easy (fast) for the computer to read programs.  fixing this \"bug\" would probably make the part of python that reads programs slower or more complicated.  so it's probably a trade-off.]", "abstract": ""}, {"id": 11802242, "score": 19, "vote": 0, "content": "Yes, an integer literal is an object in Python. To summarize, the parser needs to be able to understand it is dealing with an object of type integer, while the statement 1.real confuses the parser into thinking it has a float 1. followed by the word real, and therefore raises a syntax error.  To test this you can also try as well as, so in the case of 1.real python is interpreting the . as a decimal point.  Edit BasicWolf puts it nicely too - 1. is being interpreted as the floating point representation of 1, so 1.real is equivalent to writing (1.)real - so with no attribute access operator  i.e. period /full stop. Hence the syntax error.  Further edit As mgilson alludes to in his/her comment: the parser can handle access to int's attributes and methods, but only as long the statement makes it clear that it is being given an int and not a float.", "abstract": ""}, {"id": 11802420, "score": 3, "vote": 0, "content": "You can still access 1.real:", "abstract": ""}]}]