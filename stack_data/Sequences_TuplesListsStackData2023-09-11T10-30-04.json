[{"link": "https://stackoverflow.com/questions/6913512/how-to-sort-an-array-of-objects-by-multiple-fields", "keywords": [], "tags": ["javascript", "arrays", "sorting"], "question": {"id": 6913512, "title": "How to sort an array of objects by multiple fields?", "content": "From this original question, how would I apply a sort on multiple fields? Using this slightly adapted structure, how would I sort city (ascending) & then price (descending)? I liked the fact than an answer was given which provided a general approach.  Where I plan to use this code, I will have to sort dates as well as other things.  The ability to \"prime\" the object seemed handy, if not a little cumbersome. I've tried to build this answer into a nice generic example, but I'm not having much luck.", "abstract": ""}, "answers": [{"id": 76950598, "score": 0, "vote": 0, "content": "Fastest and easiest way is to use OR-chaining as many of people already suggested here. For the specified example data it looks like this: But if you want something configurable (and in TypeScript), you can try the following code:", "abstract": ""}, {"id": 76423529, "score": 0, "vote": 0, "content": "\n\n// Array of objects representing the data\nconst data = [\n  { name: 'John', surname: 'Doe', birthdate: new Date(1980, 5, 15) },\n  { name: 'Jane', surname: 'Smith', birthdate: new Date(1990, 2, 28) },\n  { name: 'Alex', surname: 'Johnson', birthdate: new Date(1985, 8, 10) },\n  // Additional objects...\n];\n\n// Custom comparator function for multiple field sorting\nfunction multiFieldSort(a, b) {\n  // Sorting fields and orders\n  const fields = [\n    { name: 'name', order: 'asc' },\n    { name: 'surname', order: 'desc' },\n    { name: 'birthdate', order: 'desc' },\n  ];\n\n  // Iterate over fields and perform comparisons\n  for (const field of fields) {\n    const aValue = a[field.name];\n    const bValue = b[field.name];\n\n    let comparison = 0;\n\n    if (typeof aValue === 'string' && typeof bValue === 'string') {\n      comparison = aValue.localeCompare(bValue);\n    } else if (typeof aValue === 'number' && typeof bValue === 'number') {\n      comparison = aValue - bValue;\n    } else if (aValue instanceof Date && bValue instanceof Date) {\n      comparison = aValue.getTime() - bValue.getTime();\n    }\n\n    if (comparison !== 0) {\n      return field.order === 'asc' ? comparison : -comparison;\n    }\n  }\n\n  // Default case: preserve the original order\n  return 0;\n}\n\n// Sort the data array using the multiFieldSort function\ndata.sort(multiFieldSort);\n\n// Output the sorted data\nconsole.log(data);\n\n\n", "abstract": ""}, {"id": 48958358, "score": 25, "vote": 0, "content": "To sort an array of objects by multiple fields: Notes", "abstract": ""}, {"id": 75844393, "score": 2, "vote": 0, "content": "my humble proposal: with these two functions, you may sort quite elegantly an array of objects the following way:", "abstract": ""}, {"id": 74563527, "score": 3, "vote": 0, "content": "To make things simple, use these helper functions. You can sort by as many fields as you need. For each sort field, specify the property name, and then, optionally, specify -1 as the sort direction to sort descending instead of ascending. \n\nconst data = [\n  {\"h_id\":\"3\",\"city\":\"Dallas\",\"state\":\"TX\",\"zip\":\"75201\",\"price\":\"162500\"},\n  {\"h_id\":\"4\",\"city\":\"Bevery Hills\",\"state\":\"CA\",\"zip\":\"90210\",\"price\":\"319250\"},\n  {\"h_id\":\"6\",\"city\":\"Dallas\",\"state\":\"TX\",\"zip\":\"75000\",\"price\":\"556699\"},\n  {\"h_id\":\"5\",\"city\":\"New York\",\"state\":\"NY\",\"zip\":\"00010\",\"price\":\"962500\"},\n  {\"h_id\":\"7\",\"city\":\"New York\",\"state\":\"NY\",\"zip\":\"00010\",\"price\":\"800500\"}\n]\n\nconst sortLexically   = (p,d=1)=>(a,b)=>d * a[p].localeCompare(b[p])\nconst sortNumerically = (p,d=1)=>(a,b)=>d * (a[p]-b[p])\nconst sortBy          = sorts=>(a,b)=>sorts.reduce((r,s)=>r||s(a,b),0)\n\n// sort first by city, then by price descending\ndata.sort(sortBy([sortLexically('city'), sortNumerically('price', -1)]))\n\nconsole.log(data)\n\n\n", "abstract": ""}, {"id": 73237693, "score": 1, "vote": 0, "content": "Here, you can try the smaller and convenient way to sort by multiple fields! \n\nvar homes = [\n    { \"h_id\": \"3\", \"city\": \"Dallas\", \"state\": \"TX\", \"zip\": \"75201\", \"price\": \"162500\" },\n    { \"h_id\": \"4\", \"city\": \"Bevery Hills\", \"state\": \"CA\", \"zip\": \"90210\", \"price\": \"319250\" },\n    { \"h_id\": \"6\", \"city\": \"Dallas\", \"state\": \"TX\", \"zip\": \"75000\", \"price\": \"556699\" },\n    { \"h_id\": \"5\", \"city\": \"New York\", \"state\": \"NY\", \"zip\": \"00010\", \"price\": \"962500\" }\n];\n\nhomes.sort((a, b)=> {\n  if (a.city === b.city){\n    return a.price < b.price ? -1 : 1\n  } else {\n    return a.city < b.city ? -1 : 1\n  }\n})\n\nconsole.log(homes);\n\n\n", "abstract": ""}, {"id": 72649463, "score": 1, "vote": 0, "content": "A very intuitive functional solution can be crafted by adding 3 relatively simple helpers. Before we dive in, let's start with the usage: \n\nfunction usage(homes, { asc, desc, fallback }) {\n  homes.sort(fallback(\n    asc(home => home.city),\n    desc(home => parseInt(home.price, 10)),\n  ));\n  console.log(homes);\n}\n\nvar homes = [{\n  h_id:  \"3\",\n  city:  \"Dallas\",\n  state: \"TX\",\n  zip:   \"75201\",\n  price: \"162500\",\n}, {\n  h_id:  \"4\",\n  city:  \"Bevery Hills\",\n  state: \"CA\",\n  zip:   \"90210\",\n  price: \"319250\",\n}, {\n  h_id:  \"6\",\n  city:  \"Dallas\",\n  state: \"TX\",\n  zip:   \"75000\",\n  price: \"556699\",\n}, {\n  h_id:  \"5\",\n  city:  \"New York\",\n  state: \"NY\",\n  zip:   \"00010\",\n  price: \"962500\",\n}];\n\nconst SortHelpers = (function () {\n  const asc  = (fn) => (a, b) => (a = fn(a), b = fn(b), -(a < b) || +(a > b));\n  const desc = (fn) => (a, b) => asc(fn)(b, a);\n  const fallback = (...fns) => (a, b) => fns.reduce((diff, fn) => diff || fn(a, b), 0);\n  return { asc, desc, fallback };\n})();\n\nusage(homes, SortHelpers);\n\n\n If you scrolled down the snippet you probably already saw the helpers: Let me quickly explain what each of these functions does. asc creates a comparator function. The provided function fn is called for both the comparator arguments a and b. The results of the two function calls are then compared. -1 is returned if resultA < resultB, 1 is returned if resultA > resultB, or 0 otherwise. These return values correspond with an ascending order direction. It could also be written like this: desc is super simple, since it just calls asc but swaps the a and b arguments, resulting in descending order instead of ascending. fallback (there might be a better name for this) allows us to use multiple comparator functions with a single sort. Both asc and desc can be passed to sort by themself. There is however an issue if you want to combine multiple comparator functions. sort only accepts a single comparator function. fallback combines multiple comparator functions into a single comparator. The first comparator is called with arguments a and b, if the comparator returns the value 0 (meaning that the values are equal) then we fall back to the next comparator. This continues until a non-0 value is found, or until all comparators are called, in which case the return value is 0. You can provide your custom comparator functions to fallback() as well. Say you want to use localeCompare() instead of comparing strings with < and >. In such a case you can replace asc(home => home.city) with (a, b) => a.city.localeCompare(b.city). One thing to note is that values that can be undefined will always return false when comparing with < and >. So if a value can be missing you might want to sort by its presence first. Since comparing strings with localeCompare() is such a common thing to do, you could include this as part of asc().", "abstract": ""}, {"id": 70638681, "score": 2, "vote": 0, "content": "Adding a couple helper functions lets you solved this kind of problem generically and simply. sortByKey takes an array and a function which should return a list of items with which to compare each array entry. This takes advantage of the fact that javascript does smart comparison of arrays of simple values, with [2] < [2, 0] < [2, 1] < [10, 0]. \n\n// Two helpers:\nfunction cmp(a, b) {\n    if (a > b) {\n        return 1\n    } else if (a < b) {\n        return -1\n    } else {\n        return 0\n    }\n}\n\nfunction sortByKey(arr, key) {\n    arr.sort((a, b) => cmp(key(a), key(b)))\n}\n\n// A demonstration:\nlet arr = [{a:1, b:2}, {b:3, a:0}, {a:1, b:1}, {a:2, b:2}, {a:2, b:1}, {a:1, b:10}]\nsortByKey(arr, item => [item.a, item.b])\n\nconsole.log(JSON.stringify(arr))\n// '[{\"b\":3,\"a\":0},{\"a\":1,\"b\":1},{\"a\":1,\"b\":10},{\"a\":1,\"b\":2},{\"a\":2,\"b\":1},{\"a\":2,\"b\":2}]'\n\nsortByKey(arr, item => [item.b, item.a])\nconsole.log(JSON.stringify(arr))\n// '[{\"a\":1,\"b\":1},{\"a\":2,\"b\":1},{\"a\":1,\"b\":10},{\"a\":1,\"b\":2},{\"a\":2,\"b\":2},{\"b\":3,\"a\":0}]'\n\n\n I've lovingly stolen this idea from Python's list.sort function.", "abstract": ""}, {"id": 20554416, "score": 319, "vote": 0, "content": "for a non-generic, simple solution to your exact problem:", "abstract": ""}, {"id": 71545078, "score": 6, "vote": 0, "content": "why complicate? just sort it twice! this works perfectly:\n(just make sure to reverse the importance order from least to most):", "abstract": ""}, {"id": 70505610, "score": 1, "vote": 0, "content": "You can use lodash orderBy function  lodash It takes two params array of fields, and array of directions ('asc','desc')", "abstract": ""}, {"id": 30446887, "score": 91, "vote": 0, "content": "Here is a simple functional generic approach. Specify sort order using array. Prepend minus to specify descending order. Edit: in ES6 it's even shorter! \n\n\"use strict\";\nconst fieldSorter = (fields) => (a, b) => fields.map(o => {\n    let dir = 1;\n    if (o[0] === '-') { dir = -1; o=o.substring(1); }\n    return a[o] > b[o] ? dir : a[o] < b[o] ? -(dir) : 0;\n}).reduce((p, n) => p ? p : n, 0);\n\nconst homes = [{\"h_id\":\"3\", \"city\":\"Dallas\", \"state\":\"TX\",\"zip\":\"75201\",\"price\":162500},     {\"h_id\":\"4\",\"city\":\"Bevery Hills\", \"state\":\"CA\", \"zip\":\"90210\", \"price\":319250},{\"h_id\":\"6\", \"city\":\"Dallas\", \"state\":\"TX\", \"zip\":\"75000\", \"price\":556699},{\"h_id\":\"5\", \"city\":\"New York\", \"state\":\"NY\", \"zip\":\"00010\", \"price\":962500}];\nconst sortedHomes = homes.sort(fieldSorter(['state', '-price']));\n\ndocument.write('<pre>' + JSON.stringify(sortedHomes, null, '\\t') + '</pre>')\n\n\n", "abstract": ""}, {"id": 69425906, "score": 2, "vote": 0, "content": "simply follow the list of your sorting criteria this code will always remain readable and understandable even if you have 36 sorting criteria to encase The solution proposed here by Nina is certainly very elegant, but it implies knowing that a value of zero corresponds to a value of false in Boolean logic, and that Boolean tests can return something other than true / false in JavaScript (here are numeric values) which will always be confusing for a beginner. Also think about who will need to maintain your code. Maybe it would be you: imagine yourself spending your days raking for days the code of another and having a pernicious bug ... and you are exhausted from reading these thousands of lines full of tips \n\nconst homes = \n  [ { h_id: '3', city: 'Dallas',       state: 'TX', zip: '75201', price: '162500' } \n  , { h_id: '4', city: 'Bevery Hills', state: 'CA', zip: '90210', price: '319250' } \n  , { h_id: '6', city: 'Dallas',       state: 'TX', zip: '75000', price: '556699' } \n  , { h_id: '5', city: 'New York',     state: 'NY', zip: '00010', price: '962500' } \n  ]\n  \nconst fSort = (a,b) =>\n  {\n  let Dx = a.city.localeCompare(b.city)              // 1st criteria\n  if (Dx===0) Dx = Number(b.price) - Number(a.price) // 2nd\n\n  // if (Dx===0) Dx = ... // 3rd\n  // if (Dx===0) Dx = ... // 4th....\n  return Dx\n  }\n\nconsole.log( homes.sort(fSort))\n\n\n", "abstract": ""}, {"id": 69316780, "score": 1, "vote": 0, "content": "", "abstract": ""}, {"id": 55620991, "score": 11, "vote": 0, "content": "A dynamic way to do that with MULTIPLE keys:  Use: ", "abstract": ""}, {"id": 63968639, "score": -6, "vote": 0, "content": "Simplest Way to sort array of object by multiple fields: Output:\n\"Bevery Hills\"\n\"Dallas\"\n\"Dallas\"\n\"Dallas\"\n\"New York\"", "abstract": ""}, {"id": 46256174, "score": 393, "vote": 0, "content": "You could use a chained sorting approach by taking the delta of values until it reaches a value not equal to zero. \n\nvar data = [{ h_id: \"3\", city: \"Dallas\", state: \"TX\", zip: \"75201\", price: \"162500\" }, { h_id: \"4\", city: \"Bevery Hills\", state: \"CA\", zip: \"90210\", price: \"319250\" }, { h_id: \"6\", city: \"Dallas\", state: \"TX\", zip: \"75000\", price: \"556699\" }, { h_id: \"5\", city: \"New York\", state: \"NY\", zip: \"00010\", price: \"962500\" }];\r\n\r\ndata.sort(function (a, b) {\r\n    return a.city.localeCompare(b.city) || b.price - a.price;\r\n});\r\n\r\nconsole.log(data);\n.as-console-wrapper { max-height: 100% !important; top: 0; }\n\n\n Or, using es6, simply:", "abstract": ""}, {"id": 56841633, "score": 0, "vote": 0, "content": "This is a recursive algorithm to sort by multiple fields while having the chance to format values before comparison. If a and b are equal it will just try the next field until none is available.", "abstract": ""}, {"id": 56194061, "score": 3, "vote": 0, "content": "Just another option. Consider to use the following utility function: Example of usage (in your case): It should be noted that this function can be even more generalized in order to be able to use nested properties like 'address.city' or 'style.size.width' etc.", "abstract": ""}, {"id": 56192318, "score": 8, "vote": 0, "content": "Here's a generic multidimensional sort, allowing for reversing and/or mapping on each level. Written in Typescript. For Javascript, check out this JSFiddle Sorting a people array by last name, then first name: Sort language codes by their name, not their language code (see map), then by descending version (see reverse).", "abstract": ""}, {"id": 55990011, "score": 0, "vote": 0, "content": "I was looking for something similar and ended up with this: First we have one or more sorting functions, always returning either 0, 1 or -1: You can create more functions for each other property you want to sort on. Then I have a function that combines these sorting functions into one: This can be used to combine the above sorting functions in a readable way: When a sorting function returns 0 the next sorting function will be called for further sorting.", "abstract": ""}, {"id": 55058380, "score": 0, "vote": 0, "content": "Here is mine for your reference, with example:", "abstract": ""}, {"id": 54835118, "score": 0, "vote": 0, "content": "I think this may be the easiest way to do it. https://coderwall.com/p/ebqhca/javascript-sort-by-two-fields It's really simple and I tried it with 3 different key value pairs and it worked great. Here is a simple example, look at the link for more details", "abstract": ""}, {"id": 48696437, "score": -1, "vote": 0, "content": "How about this simple solution:\n Based on this question javascript sort array by multiple (number) fields", "abstract": ""}, {"id": 48637997, "score": 0, "vote": 0, "content": "Wow, there are some complex solutions here. So complex I decided to come up with something simpler but also quite powerful. Here it is; And here is an example of how you use it. This will first sort by the precedence of the attributes, then by the value of the attributes.", "abstract": ""}, {"id": 47536415, "score": 0, "vote": 0, "content": "Adaptation of @chriskelly 's answer.  Most answers overlook that price will not sort properly if the value is in the ten thousands and lower or over a million. The resaon being JS sorts alphabetically. It was answered pretty well here, Why can't JavaScript sort \"5, 10, 1\" and here How to sort an array of integers correctly. Ultimately we have to do some evaluation if the field or node we're sorting by is an number. I am not saying that using parseInt() in this case is the correct answer, the sorted results are more important. \n\nvar homes = [{\r\n  \"h_id\": \"2\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75201\",\r\n  \"price\": \"62500\"\r\n}, {\r\n  \"h_id\": \"1\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75201\",\r\n  \"price\": \"62510\"\r\n}, {\r\n  \"h_id\": \"3\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75201\",\r\n  \"price\": \"162500\"\r\n}, {\r\n  \"h_id\": \"4\",\r\n  \"city\": \"Bevery Hills\",\r\n  \"state\": \"CA\",\r\n  \"zip\": \"90210\",\r\n  \"price\": \"319250\"\r\n}, {\r\n  \"h_id\": \"6\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75000\",\r\n  \"price\": \"556699\"\r\n}, {\r\n  \"h_id\": \"5\",\r\n  \"city\": \"New York\",\r\n  \"state\": \"NY\",\r\n  \"zip\": \"00010\",\r\n  \"price\": \"962500\"\r\n}];\r\n\r\nhomes.sort(fieldSorter(['price']));\r\n// homes.sort(fieldSorter(['zip', '-state', 'price'])); // alternative\r\n\r\nfunction fieldSorter(fields) {\r\n  return function(a, b) {\r\n    return fields\r\n      .map(function(o) {\r\n        var dir = 1;\r\n        if (o[0] === '-') {\r\n          dir = -1;\r\n          o = o.substring(1);\r\n        }\r\n        if (!parseInt(a[o]) && !parseInt(b[o])) {\r\n          if (a[o] > b[o]) return dir;\r\n          if (a[o] < b[o]) return -(dir);\r\n          return 0;\r\n        } else {\r\n          return dir > 0 ? a[o] - b[o] : b[o] - a[o];\r\n        }\r\n      })\r\n      .reduce(function firstNonZeroValue(p, n) {\r\n        return p ? p : n;\r\n      }, 0);\r\n  };\r\n}\r\ndocument.getElementById(\"output\").innerHTML = '<pre>' + JSON.stringify(homes, null, '\\t') + '</pre>';\n<div id=\"output\">\r\n\r\n</div>\n\n\n A fiddle to test with", "abstract": ""}, {"id": 42611624, "score": 2, "vote": 0, "content": "Another way \n\nvar homes = [\r\n    {\"h_id\":\"3\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75201\",\r\n     \"price\":\"162500\"},\r\n    {\"h_id\":\"4\",\r\n     \"city\":\"Bevery Hills\",\r\n     \"state\":\"CA\",\r\n     \"zip\":\"90210\",\r\n     \"price\":\"319250\"},\r\n    {\"h_id\":\"6\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75000\",\r\n     \"price\":\"556699\"},\r\n    {\"h_id\":\"5\",\r\n     \"city\":\"New York\",\r\n     \"state\":\"NY\",\r\n     \"zip\":\"00010\",\r\n     \"price\":\"962500\"}\r\n    ];\r\nfunction sortBy(ar) {\r\n  return ar.sort((a, b) => a.city === b.city ?\r\n      b.price.toString().localeCompare(a.price) :\r\n      a.city.toString().localeCompare(b.city));\r\n}\r\nconsole.log(sortBy(homes));\n\n\n", "abstract": ""}, {"id": 42767569, "score": 1, "vote": 0, "content": "Using : \n\nvar homes = [\r\n    {\"h_id\":\"3\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75201\",\r\n     \"price\":\"162500\"},\r\n    {\"h_id\":\"4\",\r\n     \"city\":\"Bevery Hills\",\r\n     \"state\":\"CA\",\r\n     \"zip\":\"90210\",\r\n     \"price\":\"319250\"},\r\n    {\"h_id\":\"6\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75000\",\r\n     \"price\":\"556699\"},\r\n    {\"h_id\":\"5\",\r\n     \"city\":\"New York\",\r\n     \"state\":\"NY\",\r\n     \"zip\":\"00010\",\r\n     \"price\":\"962500\"}\r\n    ];\r\nfunction sort(data, orderBy) {\r\n            orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];\r\n            return data.sort((a, b) => {\r\n                for (let i = 0, size = orderBy.length; i < size; i++) {\r\n                    const key = Object.keys(orderBy[i])[0],\r\n                        o = orderBy[i][key],\r\n                        valueA = a[key],\r\n                        valueB = b[key];\r\n                    if (!(valueA || valueB)) {\r\n                        console.error(\"the objects from the data passed does not have the key '\" + key + \"' passed on sort!\");\r\n                        return [];\r\n                    }\r\n                    if (+valueA === +valueA) {\r\n                        return o.toLowerCase() === 'desc' ? valueB - valueA : valueA - valueB;\r\n                    } else {\r\n                        if (valueA.localeCompare(valueB) > 0) {\r\n                            return o.toLowerCase() === 'desc' ? -1 : 1;\r\n                        } else if (valueA.localeCompare(valueB) < 0) {\r\n                            return o.toLowerCase() === 'desc' ? 1 : -1;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\nconsole.log(sort(homes, [{city : 'asc'}, {price: 'desc'}]));\n\n\n", "abstract": ""}, {"id": 32494726, "score": 3, "vote": 0, "content": "Here's my solution based on the Schwartzian transform idiom, hope you find it useful. Here's an example how to use it:", "abstract": ""}, {"id": 39729626, "score": 19, "vote": 0, "content": "This is a complete cheat but I think that it adds value to this question because it's basically a canned library function that you can use out-of-the box. If your code has access to lodash or a lodash compatible library like underscore then you can use the _.sortBy method. The snippet below is copied directly from the lodash documentation. The commented results in the examples looks like they return arrays of arrays but that's just showing the order and not the actual results which are an array of objects.", "abstract": ""}, {"id": 39657468, "score": 4, "vote": 0, "content": "I like SnowBurnt's approach but it needs a tweak to test for equivalence on city NOT a difference.", "abstract": ""}, {"id": 39306691, "score": 0, "vote": 0, "content": "How to use (put -(minus) sign before field if you want to sort in descending order particular field) Using above function you can sort any json array with multiple fields. No need to change function body at all", "abstract": ""}, {"id": 38037580, "score": 7, "vote": 0, "content": "Simpler one:", "abstract": ""}, {"id": 37949707, "score": -1, "vote": 0, "content": "Sorting on two date fields and a numeric field example: http://jsfiddle.net/hcWgf/57/", "abstract": ""}, {"id": 17265125, "score": 16, "vote": 0, "content": "The following function will allow you to sort an array of objects on one or multiple properties, either ascending (default) or descending on each property, and allow you to choose whether or not to perform case sensitive comparisons.  By default, this function performs case insensitive sorts. The first argument must be the array containing the objects.\nThe subsequent argument(s) must be a comma separated list of strings that reference the different object properties to sort by.  The last argument (which is optional) is a boolean to choose whether or not to perform case sensitive sorts - use true for case sensitive sorts. The function will sort each property/key in ascending order by default.  If you want a particular key to sort in descending order, then instead pass in an array in this format: ['property_name', true]. Here are some sample uses of the function followed by an explanation (where homes is an array containing the objects): objSort(homes, 'city') --> sort by city (ascending, case in-sensitive) objSort(homes, ['city', true]) --> sort by city (descending, case in-sensitive) objSort(homes, 'city', true) --> sort by city then price (ascending, case sensitive) objSort(homes, 'city', 'price') --> sort by city then price (both ascending, case in-sensitive) objSort(homes, 'city', ['price', true]) --> sort by city (ascending) then price (descending), case in-sensitive) And without further ado, here's the function: And here's some sample data:", "abstract": ""}, {"id": 30910572, "score": 0, "vote": 0, "content": "Here 'AffiliateDueDate' and 'Title' are columns, both are sorted in ascending order.", "abstract": ""}, {"id": 26000529, "score": 1, "vote": 0, "content": "Here is a generic version of @Snowburnt's solution: This is based on a sort routine I'm using.  I didn't test this specific code so it may have errors but you get the idea.  The idea is to sort based on the first field that indicates a difference and then stop and go to the next record.  So, if you're sorting by three fields and the first field in the compare is enough to determine the sort order of the two records being sorted then return that sort result and go to the next record.   I tested it (actually with a little more complex sort logic) on 5000 records and it did it in the blink of an eye.  If you're actually loading more than 1000 records to the client you should probably be using sever-side sorting and filtering. This code isn't handling case-sensitivity but I leave it to the reader to handle this trivial modification.", "abstract": ""}, {"id": 25561344, "score": -2, "vote": 0, "content": "", "abstract": ""}, {"id": 18045239, "score": 35, "vote": 0, "content": "I made a quite generic multi feature sorter today. You can have a look at thenBy.js here: https://github.com/Teun/thenBy.js It allows you to use the standard Array.sort, but with firstBy().thenBy().thenBy() style. It is way less code and complexity than the solutions posted above.", "abstract": ""}, {"id": 6913821, "score": 91, "vote": 0, "content": "A multi dimensional sorting method, based on this answer: Update: Here is an \"optimized\" version. It does a lot more preprocessing and creates a comparison function for each sorting option beforehand. It might need more more memory (as it stores a function for each sorting option, but it should preform a bit better as it does not have to determine the correct settings during the comparison. I have not done any profiling though. Example usage: DEMO Original function: DEMO", "abstract": ""}, {"id": 6914113, "score": 7, "vote": 0, "content": "Here's another one that's perhaps closer to your idea for the syntax Demo: http://jsfiddle.net/Nq4dk/2/ Edit: Just for fun, here's a variation that just takes an sql-like string, so you can do sortObjects(homes, \"city, price desc\")", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72899/how-to-sort-a-list-of-dictionaries-by-a-value-of-the-dictionary-in-python", "keywords": [], "tags": ["python", "list", "sorting", "dictionary", "data-structures"], "question": {"id": 72899, "title": "How to sort a list of dictionaries by a value of the dictionary in Python?", "content": "How do I sort a list of dictionaries by a specific key's value? Given: When sorted by name, it should become:", "abstract": ""}, "answers": [{"id": 76250224, "score": 5, "vote": 0, "content": "You can sort a list of dictionaries with a key as shown below: Output: In addition, you can sort a list of dictionaries with a key and a list of values as shown below: Output:", "abstract": ""}, {"id": 75935637, "score": 4, "vote": 0, "content": "It might be better to use dict.get() to fetch the values to sort by in the sorting key. One way it's better than dict[] is that a default value may be used to if a key is missing in some dictionary in the list. For example, if a list of dicts were sorted by 'age' but 'age' was missing in some dict, that dict can either be pushed to the back of the sorted list (or to the front) by simply passing inf as a default value to dict.get().", "abstract": ""}, {"id": 75367181, "score": 1, "vote": 0, "content": "You can use the following:", "abstract": ""}, {"id": 45094029, "score": 28, "vote": 0, "content": "Sometime we need to use lower() for case-insensitive sorting. For example,", "abstract": ""}, {"id": 72939809, "score": 1, "vote": 0, "content": "sorting by multiple columns, while in descending order on some of them:\nthe cmps array is global to the cmp function, containing field names and inv == -1 for desc 1 for asc", "abstract": ""}, {"id": 73050, "score": 3585, "vote": 0, "content": "The sorted() function takes a key= parameter Alternatively, you can use operator.itemgetter instead of defining the function yourself For completeness, add reverse=True to sort in descending order", "abstract": ""}, {"id": 69072597, "score": 2, "vote": 0, "content": "As indicated by @Claudiu to @monojohnny in comment section of this answer, given: to sort the list of dictionaries by key 'age', 'name'\n(like in SQL statement ORDER BY age, name), you can use: or, likewise print(newlist) [{'name': 'Bart', 'age': 10},  {'name': 'Milhouse', 'age': 10},\n{'name': 'Homer', 'age': 39}]", "abstract": ""}, {"id": 73044, "score": 119, "vote": 0, "content": "my_list will now be what you want. Or better: Since Python 2.4, there's a key argument is both more efficient and neater: ...the lambda is, IMO, easier to understand than operator.itemgetter, but your mileage may vary.", "abstract": ""}, {"id": 59802559, "score": 11, "vote": 0, "content": "If performance is a concern, I would use operator.itemgetter instead of lambda as built-in functions perform faster than hand-crafted functions. The itemgetter function seems to perform approximately 20% faster than lambda based on my testing. From https://wiki.python.org/moin/PythonSpeed: Likewise, the builtin functions run faster than hand-built equivalents. For example, map(operator.add, v1, v2) is faster than map(lambda x,y: x+y, v1, v2). Here is a comparison of sorting speed using lambda vs itemgetter. Both techniques sort the list in the same order (verified by execution of the final statement in the code block), but the first one is a little faster.", "abstract": ""}, {"id": 58179903, "score": 16, "vote": 0, "content": "I have been a big fan of a filter with lambda. However, it is not best option if you consider time complexity. 1000000 loops, best of 3: 0.736 \u00b5sec per loop 1000000 loops, best of 3: 0.438 \u00b5sec per loop", "abstract": ""}, {"id": 23102554, "score": 15, "vote": 0, "content": "Let's say I have a dictionary D with the elements below. To sort, just use the key argument in sorted to pass a custom function as below: Check this out.", "abstract": ""}, {"id": 28094888, "score": 17, "vote": 0, "content": "Here is the alternative general solution - it sorts elements of a dict by keys and values. The advantage of it - no need to specify keys, and it would still work if some keys are missing in some of dictionaries.", "abstract": ""}, {"id": 16772049, "score": 27, "vote": 0, "content": "Using the Schwartzian transform from Perl, do gives More on the Perl Schwartzian transform: In computer science, the Schwartzian transform is a Perl programming\nidiom used to improve the efficiency of sorting a list of items. This\nidiom is appropriate for comparison-based sorting when the ordering is\nactually based on the ordering of a certain property (the key) of the\nelements, where computing that property is an intensive operation that\nshould be performed a minimal number of times. The Schwartzian\nTransform is notable in that it does not use named temporary arrays.", "abstract": ""}, {"id": 2858683, "score": 75, "vote": 0, "content": "If you want to sort the list by multiple keys, you can do the following: It is rather hackish, since it relies on converting the values into a single string representation for comparison, but it works as expected for numbers including negative ones (although you will need to format your string appropriately with zero paddings if you are using numbers).", "abstract": ""}, {"id": 39281050, "score": 20, "vote": 0, "content": "Using the Pandas package is another method, though its runtime at large scale is much slower than the more traditional methods proposed by others: Here are some benchmark values for a tiny list and a large (100k+) list of dicts:", "abstract": ""}, {"id": 47892332, "score": 13, "vote": 0, "content": "If you do not need the original list of dictionaries, you could modify it in-place with sort() method using a custom key function. Key function: The list to be sorted: Sorting it in-place: If you need the original list, call the sorted() function passing it the list and the key function, then assign the returned sorted list to a new variable: Printing data_one and new_data.", "abstract": ""}, {"id": 42855105, "score": 52, "vote": 0, "content": "", "abstract": ""}, {"id": 73465, "score": 238, "vote": 0, "content": "To sort the list of dictionaries by key='name': To sort the list of dictionaries by key='age':", "abstract": ""}, {"id": 73186, "score": 28, "vote": 0, "content": "You could use a custom comparison function, or you could pass in a function that calculates a custom sort key. That's usually more efficient as the key is only calculated once per item, while the comparison function would be called many more times. You could do it this way: But the standard library contains a generic routine for getting items of arbitrary objects: itemgetter. So try this instead:", "abstract": ""}, {"id": 73098, "score": 42, "vote": 0, "content": "'key' is used to sort by an arbitrary value and 'itemgetter' sets that value to each item's 'name' attribute.", "abstract": ""}, {"id": 73019, "score": 32, "vote": 0, "content": "I guess you've meant: This would be sorted like this:", "abstract": ""}, {"id": 72950, "score": 24, "vote": 0, "content": "You have to implement your own comparison function that will compare the dictionaries by values of name keys. See Sorting Mini-HOW TO from PythonInfo Wiki", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44749903/how-do-i-implement-a-schwartzian-transform-in-python", "keywords": [], "tags": ["python", "sorting"], "question": {"id": 44749903, "title": "How do I implement a Schwartzian Transform in Python?", "content": "In Perl I sometimes use the Schwartzian Transform to efficiently sort complex arrays: How to implement this transform in Python?", "abstract": ""}, "answers": [{"id": 74964521, "score": 0, "vote": 0, "content": "While there should normally be no reason not to use the key argument for the sorted function or list.sort method, you can of course do without it, by creating a list of pairs (called tmp below) where the first item is the sort key and the second item is the original item. Due to lexicographical sorting, sorting this list will sort by the key first. Then you can take the items in the desired order from the sorted tmp list of pairs. Note that usually this would be written with list comprehensions instead of calling .append in a loop, but the purpose of this answer is to illustrate the underlying algorithm in a way most likely to be understood by beginners.", "abstract": ""}, {"id": 44749939, "score": 6, "vote": 0, "content": "You don't need to.  Python has this feature built in, and in fact Python 3 removed C-style custom comparisons because this is so much better in the vast majority of cases. To sort by word length: Or, because len is already an unary function: This also works with the built-in sorted function. If you want to sort on multiple criteria, you can take advantage of the fact that tuples sort lexicographically:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61683696/how-to-sort-hierarchical-data-represented-in-a-flat-list", "keywords": [], "tags": ["python", "sorting", "data-structures"], "question": {"id": 61683696, "title": "How to sort hierarchical data represented in a flat list?", "content": "I have a Python (version 2.7) list of objects that has an implied hierarchy. If one or more SubThings immediately follow a Thing, they belong with that Thing. I want to sort the Things by their value and when Things are moved for the sorting, I want their SubThings to move with them. All of these objects have values. Example input: I have working code for this in Python 2.7 but it's brute-force and feels inelegant - about 40 lines of code. First I create an intermediate data structure that groups Things with their SubThings, then I sort by Things' values, then I flatten the resulting structure. I have a feeling there is an elegant one or two (or three?)-liner for this. It even sounds like a classic opportunity for a Schwartzian Transform but I'm not making the \"Pythonic\" leap that easily groups SubThings with Things - maybe something with itertools.groupby()? For clarity: SubThings never occur without a parent Thing. Things may not have SubThings. I've simplified by leaving out the reality that the series of Things/SubThings can be preceded and followed by unrelated objects. It'd be awesome to see a solution that passes those through unsorted, i.e. in the position they were, but that's not as intellectually challenging to me.", "abstract": ""}, "answers": [{"id": 61685758, "score": 1, "vote": 0, "content": "You could use accumulate to propagate the original index of the parent \"Thing\" to all elements in its group.  Then tie the value of the parents to each group and then use a normal sort on these tuples to keep Subthings tied to their original parent while sorting both parents betwen each other and children under their parent.   Note that you will also need to keep track of which item is a parent so that parents keep appearing first within their group: This is all iterators and generators. There is no intermediate data structure (except internally during the sort).  The whole thing could be written on a single (monstrous) line but I tried to keep it understandable. As you suspected this is indeed a Schwartzian Transform so you can play with the tuple used in keys (decorate step) to get different sorting schemes. For example, if you only want to sort between the \"Thing\" groups but not the \"SubThing\" items within each group, replace (things[p],p,p<i,things[i]) with (things[p],p,i,things[i]) in the keys generator. If you only want to sort the \"SubThing\" items within each group without moving groups around, change it to (p,p<i,things[i]) [EDIT]  I just noticed that you are using Python 2.7 which I believe doesn't have the accumulate function in itertools.  If that is the case, you could write your own: I never used Python 2.7 so there may be some other differences that I am not aware of", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/48240069/idiomatic-lazy-sorting-by-multiple-criteria", "keywords": [], "tags": ["ruby", "performance", "sorting", "lazy-evaluation", "memoization"], "question": {"id": 48240069, "title": "Idiomatic lazy sorting by multiple criteria", "content": "In Ruby, the most common way to sort by multiple criteria is to use sort_by with the sorting function returning an array of the values corresponding to each sorting criterion, in order of decreasing importance, e.g.: will sort the directory entries by size, then by mtime, then finally by the filename.  This is efficient to the extent that it uses a Schwartzian transform to only calculate the size and mtime of each file once, not once per comparison.  However it is not truly lazy, since it calculates the mtime for every single file, but if (say) every file in the directory had a different size, it should not be necessary to calculate any mtimes. This is not a big problem in this case, since looking up the mtime immediately after looking up the size should be efficient due to caching at the kernel level (e.g. IIRC on Linux they both come from a stat(2) syscall), and I wouldn't be surprised if Ruby has its own optimizations too.  But imagine if the second criterion was not the mtime, but (say) the number of occurrences of a string within the file, and the files in question are huge.  In this case you'd really want lazy evaluation, to avoid reading the whole of these huge files if sorting by size is sufficient. At the time of writing, the Wikibooks entry for Algorithm Implementation/Sorting/Schwartzian transform suggests this solution: This kind of approach is copied from Perl, where works beautifully because Perl has a quirk where 0 or $foo evaluates to $foo.  But in Ruby, it's broken because 0 or foo evaluates to 0.  So in effect, the Wikibooks implementation totally ignores mtimes and filenames, and only sorts by size.  I've dusted off my Wikibooks account so that I can fix this, but I'm wondering: what is the cleanest way of combining the results of multiple <=> spaceship operator comparisons in Ruby? I'll give a concrete-ish example to clarify the question.  Let's assume we have two types of evaluation which may be required as criteria during the sort.  The first is relatively cheap: The second is expensive: And we want to sort first by size ascending, then descending by number of matches.  We can't use a Schwartzian transform, because that would non-lazily call matches() on every item. We could define a helper like and then do: If there are n criteria to sort by then you'd need n-1 invocations of nil_if_equal here, since only the last sorting criteria doesn't require it. So is there a more idiomatic way than this which can avoid the need for nil_if_equal?", "abstract": ""}, "answers": [{"id": 48244844, "score": 1, "vote": 0, "content": "No idea how idiomatic it is, but here's a way to use sort_by again. Instead of\nfor example do this to make count_a(s) and count_b(s) lazy and memoized: My lazy makes the block act like a lazy and memoizing version of the value it yields. Demo output, showing we only count what's necessary (i.e., don't count in 'so' since it has a unique size and don't count 'b' in 'foo' since its 'a'-count is unique among the size-3 strings): Demo code: A different way to make value memoizing: If it ever gets called, it immediately replaces itself with a method just returning the stored value:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46860219/how-do-i-make-a-merge-sort-built-for-a-single-list-sort-a-list-of-list-inste", "keywords": [], "tags": ["python"], "question": {"id": 46860219, "title": "How do I make a merge sort, built for a single list, sort a &quot;list of list&quot; instead?", "content": "So, let say I have a list of lists like this: If I wanted to sort this by the middle number in each sublist, it would end up like this: How can I cause a merge sort that is built to sort a list like this: [1, 2, 3, 4] To sort a list of list and specify it to merge based on the middle number of each sublist? Is there a trick with python that will allow this to work? Only thing I have been able to find about this is using the built-in sorting function, which I do not want to do. Below is the merge sort I am implementing. It works like this  mergeSort(list_here) And it merges the list. However, I would like to use a trick to make python merge based on a list of the list instead with the middle index of each sublist being what is being compared. Thanks for any guidance. Below is the merge sort:", "abstract": ""}, "answers": [{"id": 46860549, "score": 1, "vote": 0, "content": "Here's a version of your code that can accept a key function, like the built-in sort and related functions do. I use max to create the \"sentinel\" value. This is rather inefficient, since max has to scan the whole list to find its maximum. Also, the built-in sort only calls the key function once for each item in the list it's sorting, whereas this code has to call it twice every time it makes a comparison. output As you can see, it works, but it would be better to change your merging algorithm to eliminate the sentinels so we don't need max.  We can also make it more efficient by performing a Schwartzian transform on the data so that the key function only needs to be called once per item, but that does make the code a little more complicated, and of course it also requires more RAM to hold the transformed data.", "abstract": ""}, {"id": 46860389, "score": 0, "vote": 0, "content": "If did understand you right, the following code is what you want: where l is your input list.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/42899405/sort-a-list-with-longest-items-first", "keywords": [], "tags": ["python", "python-3.x", "sorting", "lambda"], "question": {"id": 42899405, "title": "Sort a list with longest items first", "content": "I am using a lambda to modify the behaviour of sort. Sorting a list containing the elements A1,A2,A3,A,B1,B2,B3,B, the result is A,A1,A2,A3,B,B1,B2,B3. My expected sorted list would be A1,A2,A3,A,B1,B2,B3,B. I've already tried to include the len(item) for sorting, which didn't work. How to modify the lambda so that the sort result is instead? ", "abstract": ""}, "answers": [{"id": 42902140, "score": 0, "vote": 0, "content": "I love Tries, so just for fun, I wrote a Trie-based solution : This should work for any string of any length. Note that the result is just printed to screen, not written back in a new list. You didn't write much code, so I'll leave it as an exercise ;)", "abstract": ""}, {"id": 42900060, "score": 7, "vote": 0, "content": "Here is one way to do it: Traditionally, lexicographic sort order longer strings after their otherwise identical prefixes (i.e.  'abc' goes before 'abcd'). To meet your sort expectation, we first \"fix-up\" the shorter string by adding the remaining part of the longer string plus another character to make it the longer of the two: The functools.cmp_to_key() tool then converts the comparison function to a key function. This may seem like a lot of work, but the sort expectations are very much at odds with the built-in lexicographic sorting rules. FWIW, here's another way of writing it, that might or might not be considered clearer: The logic is:", "abstract": ""}, {"id": 42899432, "score": 1, "vote": 0, "content": "My first answer was: just negate the len criterion to reverse only on that criterion. But that doesn't work, because there's a conflict between alpha sort and length. Alpha sort puts small strings first. So length criterion doesn't work. You need to merge both criteria. There's no clear priority between each other. I found a way: first compute the max length of your strings, then return the chr(127) filled (the biggest char provided you're using only ASCII) version of the string as key so smallest strings are filled with big chars in the end: they always come last. result: BTW don't call your list list for obvious reasons.", "abstract": ""}, {"id": 42899718, "score": 0, "vote": 0, "content": "One could construct the key by taking: For example:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/40358056/sorting-list-of-lists-and-getting-indices-in-unsorted-list", "keywords": [], "tags": ["python", "list", "sorting"], "question": {"id": 40358056, "title": "sorting list of lists and getting indices in unsorted list", "content": "These are the logical steps that I need to perform on my list of lists sort the list of lists in such a way that the output looks something like take the coordinates of the sorted elements in the original list, which in this case should produce as output I tried using of sort, sorted and argwhere in different ways but I am not getting sensible results, I guess first of all because sort and sorted can sort a list following only one axis at a time", "abstract": ""}, "answers": [{"id": 40360583, "score": 2, "vote": 0, "content": "Use Numpy, which is pretty much faster than regular python code when you are dealing with larger arrays:", "abstract": ""}, {"id": 40358916, "score": 2, "vote": 0, "content": "You can use a series of list comprehensions and zip blocks, although the readability suffers: If you need a dict, just replace the zip(*..) layer with dict()", "abstract": ""}, {"id": 40358248, "score": 8, "vote": 0, "content": "This code will work for a list of lists. The internal lists don't have to be the same length. At each level we iterate over a list using enumerate to get the list item and its index. At the top level, each item is another list, and the inner loop iterates over each of those lists to get their indices and values, storing the indices (as a tuple) in a tuple that also contains the value. We then sort the resulting list of tuples (b) on the values, and then split it using zip into a tuple of all the indices and a tuple of the values.   output", "abstract": ""}, {"id": 40358211, "score": 1, "vote": 0, "content": "You can flatten the list and then use it to sort and find indices. Output:", "abstract": ""}, {"id": 40358185, "score": 8, "vote": 0, "content": "Create a dictionary with the keys as the actual coordinates and the values as the numbers themselves, like this Now, sort the keys (coordinates) of positions based on their values, like this", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/5760733/perl-in-place-sort-lines-in-a-text-file", "keywords": [], "tags": ["python", "perl"], "question": {"id": 5760733, "title": "perl in-place sort lines in a text file", "content": "I wish to modify a text file by sorting each line based on a given key and save the old file as a backup.  The key is a numeric character contained in each line.   Is there a simple script to get this done, preferably in-place? Thanks!", "abstract": ""}, "answers": [{"id": 5761683, "score": 1, "vote": 0, "content": "Say your sort key is the run of digits at the beginning of each line, as in the following example. To sort one or more files named on the command line, you can use the code below. @ARGV contains the arguments from the command line. Running the program with no arguments produces a usage guide on the standard error. $^I holds the extension added to filenames when creating backups for in-place editing, which you can also enable with Perl's -i switch, covered in the perlrun documentation. -i[extension]\n  specifies that files processed by the <> construct are to be edited in-place. It does this by renaming the input file, opening the output file by the original name, and selecting that output file as the default for print statements. $/ is the input record separator. Setting it to the undefined value means you want subsequent calls to the readline operator to read through end-of-file. Performance will suffer with very large inputs. On each iteration of the while loop, the special variable $_ will hold the contents of the current file as a whole. To sort the lines, we first break them apart. Don't be intimidated by the print inside the loop. It's the Schwartzian Transform, a common technique in Perl even though it debuted to less-than-rave reviews. To understand what's happening, read it from the end to the beginning. In a more procedural style, you'd write the loop as Once you understand what's happening with the Schwartzian Transform, all the temporaries seem like undue clutter.", "abstract": ""}, {"id": 5761489, "score": 1, "vote": 0, "content": "There are in-place sorting algorithms with O(n log n) complexity such as Heapsort, but I don't see why you would want to use that rather than something simple such as the Unix sort command. Unless you have stringent performance requirements or huge datasets... but then, perl and python probably aren't the best tools for the job.", "abstract": ""}, {"id": 5761477, "score": 0, "vote": 0, "content": "There isn't a simple script to do this because what you're suggesting is actually fairly complex and inefficient. Unless your lines are all the exact same length in the file, it's almost impossible (or, incredibly silly).  If you absolutely can't do it in memory and want to write the code yourself, your best approach is probably a disk based merge sort. The example for how you would do it with tape drives should give you some guidance. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/2019951/how-do-i-sort-this-list", "keywords": [], "tags": ["c#", "python", "ruby", "sorting", "haskell"], "question": {"id": 2019951, "title": "How do I sort this list?", "content": "I have a list of lists. Now I want to sort li in such a way that higher the foo(x) for a x higher it should appear in a sorted list. What is the best way in C#/Python/any other lang to this?", "abstract": ""}, "answers": [{"id": 2032235, "score": 1, "vote": 0, "content": "Clojure:", "abstract": ""}, {"id": 2028789, "score": 1, "vote": 0, "content": "Ruby (shamelessly copying Beanish's input data):", "abstract": ""}, {"id": 2022799, "score": 0, "vote": 0, "content": "Tcl: ", "abstract": ""}, {"id": 2021958, "score": 2, "vote": 0, "content": "In Perl, this is often done with the well-known Schwartzian transform. Reusing Sort::Key is better, though.", "abstract": ""}, {"id": 2021122, "score": 2, "vote": 0, "content": "Ruby: I'm not sure the rules of Code Golf and I didn't write a foo method, but the sum could easily occur in foo. My test output: [[10, 23, 14], [3, 5, 9], [1, 2, 3], [1, 1, 1]]", "abstract": ""}, {"id": 2021093, "score": 1, "vote": 0, "content": "in erlang:", "abstract": ""}, {"id": 2020129, "score": 10, "vote": 0, "content": "The Haskell solution is particularly elegant with the on combinator from Data.Function. Output: There's also comparing from Data.Ord that lets us instead write The definition of comparing is a straightforward but we could also define it in terms of on: or completely point-free with Haskell manipulates functions as powerfully as Perl manipulates strings.", "abstract": ""}, {"id": 2020264, "score": 1, "vote": 0, "content": "Any other language? Ok, here's some F#: Example: sort by sum: Result (F# interactive): Golfed: The C# version:", "abstract": ""}, {"id": 2019975, "score": 5, "vote": 0, "content": "This is the Python way: Just pass the function as the key argument to sorted() or .sort():", "abstract": ""}, {"id": 2019973, "score": 10, "vote": 0, "content": "With a little bit of LINQ:", "abstract": ""}, {"id": 2019955, "score": 0, "vote": 0, "content": "You could adapt any of the popular sorting routines to do this. Just use foo(x) for comparison rather than x. ", "abstract": ""}]}]