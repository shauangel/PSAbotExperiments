[{"link": "https://stackoverflow.com/questions/17088812/caching-the-result-of-a-method-in-java", "keywords": [], "tags": ["java", "caching"], "question": {"id": 17088812, "title": "Caching the result of a method in Java", "content": "I have this method that loads a lot of data from the database: I am looking for a simple way to cache the results for some fixed time (2 minutes for example). I do not need to intercept the method invocation itself, just to cache the returned data. I can write another method that does the caching if necessary. I don't want to: Is there a library which can simplify this task, or should I do something else? An example use of such library would be I am looking for a library that does that, managing the cache is more trouble than it seems, especially if you have concurrent access", "abstract": ""}, "answers": [{"id": 17088883, "score": 8, "vote": 0, "content": "Check Guava Cache Builder. It may be useful.", "abstract": ""}, {"id": 25113382, "score": 4, "vote": 0, "content": "You can use @Cacheable annotation from jcabi-aspects: The result of load() will be cached for five seconds. This blog post of mine may help you understand it better: Cache Java Method Results (2014)", "abstract": ""}, {"id": 17088928, "score": 16, "vote": 0, "content": "Use Guava's Suppliers.memoizeWithExpiration(Supplier delegate, long duration, TimeUnit unit):", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/815110/is-there-a-decorator-to-simply-cache-function-return-values", "keywords": [], "tags": ["python", "caching", "decorator", "memoization"], "question": {"id": 815110, "title": "Is there a decorator to simply cache function return values?", "content": "Consider the following: I'm new, but I think the caching could be factored out into a decorator. Only I didn't find one like it ;) PS the real calculation doesn't depend on mutable values", "abstract": ""}, "answers": [{"id": 74650070, "score": 2, "vote": 0, "content": "Create your own decorator and use it Now at the function side", "abstract": ""}, {"id": 64537087, "score": 48, "vote": 0, "content": "functools.cache has been released in Python 3.9 (docs): In previous Python versions, one of the early answers is still a valid solution: Using lru_cache as an ordinary cache without the limit and lru features. (docs) If maxsize is set to None, the LRU feature is disabled and the cache\ncan grow without bound. Here is a prettier version of it:", "abstract": ""}, {"id": 67555155, "score": 2, "vote": 0, "content": "", "abstract": ""}, {"id": 70794903, "score": 1, "vote": 0, "content": "", "abstract": ""}, {"id": 9674327, "score": 290, "vote": 0, "content": "Starting from Python 3.2 there is a built-in decorator: @functools.lru_cache(maxsize=100, typed=False) Example of an LRU cache for computing Fibonacci numbers: If you are stuck with Python 2.x, here's a list of other compatible memoization libraries:", "abstract": ""}, {"id": 49082161, "score": 6, "vote": 0, "content": "Try joblib\nhttps://joblib.readthedocs.io/en/latest/memory.html", "abstract": ""}, {"id": 53918439, "score": 3, "vote": 0, "content": "@lru_cache is not good with default attrs my @mem decorator: output:", "abstract": ""}, {"id": 56097764, "score": 57, "vote": 0, "content": "Python 3.8 functools.cached_property decorator https://docs.python.org/dev/library/functools.html#functools.cached_property cached_property from Werkzeug was mentioned at: https://stackoverflow.com/a/5295190/895245 but a supposedly derived version will be merged into 3.8, which is awesome. This decorator can be seen as caching @property, or as a cleaner  @functools.lru_cache for when you don't have any arguments. The docs say: Transform a method of a class into a property whose value is computed once and then cached as a normal attribute for the life of the instance. Similar to property(), with the addition of caching. Useful for expensive computed properties of instances that are otherwise effectively immutable. Example: New in version 3.8. Note This decorator requires that the dict attribute on each instance be a mutable mapping. This means it will not work with some types, such as metaclasses (since the dict attributes on type instances are read-only proxies for the class namespace), and those that specify slots without including dict as one of the defined slots (as such classes don\u2019t provide a dict attribute at all).", "abstract": ""}, {"id": 53208382, "score": 4, "vote": 0, "content": "There is fastcache, which is \"C implementation of Python 3 functools.lru_cache. Provides speedup of 10-30x over standard library.\" Same as chosen answer, just different import: Also, it comes installed in Anaconda, unlike functools which needs to be installed.", "abstract": ""}, {"id": 29891043, "score": 8, "vote": 0, "content": "DISCLAIMER: I'm the author of kids.cache. You should check kids.cache, it provides a @cache decorator that works on python 2 and python 3. No dependencies, ~100 lines of code. It's very straightforward to use, for instance, with your code in mind, you could use it like this: Then Or you could put the @cache decorator after the @property (same result). Using cache on a property is called lazy evaluation, kids.cache can do much more (it works on function with any arguments, properties, any type of methods, and even classes...). For advanced users, kids.cache supports cachetools which provides fancy cache stores to python 2 and python 3 (LRU, LFU, TTL, RR cache). IMPORTANT NOTE: the default cache store of kids.cache is a standard dict, which is not recommended for long running program with ever different queries as it would lead to an ever growing caching store. For this usage you can plugin other cache stores using for instance (@cache(use=cachetools.LRUCache(maxsize=2)) to decorate your function/property/class/method...)", "abstract": ""}, {"id": 16459127, "score": 4, "vote": 0, "content": "If you are using Django Framework, it has such a property to cache a view or response of API's\nusing @cache_page(time) and there can be other options as well. Example: More details can be found here.", "abstract": ""}, {"id": 49310616, "score": 2, "vote": 0, "content": "If you are using Django and want to cache views, see Nikhil Kumar's answer.   But if you want to cache ANY function results, you can use django-cache-utils. It reuses Django caches and provides easy to use cached decorator:", "abstract": ""}, {"id": 36857036, "score": 3, "vote": 0, "content": "Along with the Memoize Example I found the following python packages:", "abstract": ""}, {"id": 30698822, "score": 10, "vote": 0, "content": "I coded this simple decorator class to cache function responses. I find it VERY useful for my projects: The usage is straightforward:", "abstract": ""}, {"id": 22552713, "score": 27, "vote": 0, "content": "Sample uses:", "abstract": ""}, {"id": 18774264, "score": 2, "vote": 0, "content": "I implemented something like this, using pickle for persistance and using sha1 for short almost-certainly-unique IDs. Basically the cache hashed the code of the function and the hist of arguments to get a sha1 then looked for a file with that sha1 in the name. If it existed, it opened it and returned the result; if not, it calls the function and saves the result (optionally only saving if it took a certain amount of time to process). That said, I'd swear I found an existing module that did this and find myself here trying to find that module... The closest I can find is this, which looks about right: http://chase-seibert.github.io/blog/2011/11/23/pythondjango-disk-based-caching-decorator.html The only problem I see with that is it wouldn't work well for large inputs since it hashes str(arg), which isn't unique for giant arrays. It would be nice if there were a unique_hash() protocol that had a class return a secure hash of its contents. I basically manually implemented that for the types I cared about.", "abstract": ""}, {"id": 5295190, "score": 12, "vote": 0, "content": "Werkzeug has a cached_property decorator (docs, source)", "abstract": ""}, {"id": 2061438, "score": 5, "vote": 0, "content": "There is yet another example of a memoize decorator at Python Wiki: http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize That example is a bit smart, because it won't cache the results if the parameters are mutable. (check that code, it's very simple and interesting!)", "abstract": ""}, {"id": 815160, "score": 40, "vote": 0, "content": "It sounds like you're not asking for a general-purpose memoization decorator (i.e., you're not interested in the general case where you want to cache return values for different argument values).  That is, you'd like to have this: while a general-purpose memoization decorator would give you this: I submit that the method-call syntax is better style, because it suggests the possibility of expensive computation while the property syntax suggests a quick lookup. [Update: The class-based memoization decorator I had linked to and quoted here previously doesn't work for methods.  I've replaced it with a decorator function.]  If you're willing to use a general-purpose memoization decorator, here's a simple one: Example usage: Another memoization decorator with a limit on the cache size can be found here.", "abstract": ""}, {"id": 816245, "score": 7, "vote": 0, "content": "Ah, just needed to find the right name for this: \"Lazy property evaluation\". I do this a lot too; maybe I'll use that recipe in my code sometime.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72440940/how-can-i-cache-methods-in-python", "keywords": [], "tags": ["python", "caching", "methods"], "question": {"id": 72440940, "title": "How can I cache methods in Python?", "content": "I have an object with a large number of recursive/iterative methods. I'd like to cache the method responses to speed up calls. The four ways I've found of doing this are: Example: I'd prefer not to reinvent the wheel. The lru_cache version of #3 seems like the most straight forward. Is there a convention for caching methods and having those cached results purged when the instance is deleted?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/70633223/cache-function-or-view", "keywords": [], "tags": ["python", "django", "django-rest-framework"], "question": {"id": 70633223, "title": "Cache function or view?", "content": "I want to use django-rest-framework with cache. It works well. So actually I want to cache not view but function There comes error TypeError: _wrapped_view() missing 1 required positional argument: 'request' Is it possible to use cache for function??", "abstract": ""}, "answers": [{"id": 72356388, "score": 0, "vote": 0, "content": "Django doesn't have a built-in decorator for caching functions using the cache-framework.  You have three options: Python's built-in functools.cache (or functools.lru_cache) decorator  will only cache in local memory, which means the cache entries aren't shared between processes, and don't persist.  (If you need a timeout, you can use cachetools library as mentioned in another answer) This technique be sufficient in certain cases (e.g., if your function is fairly inexpensive), but may not be ideal if your function is expensive (e.g., does complex database queries) and you need to minimize cache misses. You can use Django's low-level cache api, and get()/set() cache entries directly.  E.g., you would do: The simplest option may be to use the django-cache-memoize library, which provides a cache_memoize decorator built using the Django's low-level cache api described above.  It is analogous to cache_page, but for functions instead of views.  Then you can simply do: The library documentation explains how you can customize the cache key as well as other available options.", "abstract": ""}, {"id": 70634579, "score": 0, "vote": 0, "content": "you can add request to function parameters:", "abstract": ""}, {"id": 70633295, "score": 1, "vote": 0, "content": "you can use cachetools maxsize depends on your requirement.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70478158/java-method-should-cache-the-results", "keywords": [], "tags": ["java", "caching"], "question": {"id": 70478158, "title": "Java method should cache the results", "content": "I'm learning programming in the language java. I need to write an application that takes a string and returns the number of unique characters in the string.\nIt is expected that a string with the same character sequence may be passed several times to the method.\nSince the counting operation can be time-consuming, the method should cache the results, so that when the method is given a string previously encountered At this stage, my application is already able to count and display characters The result of the application Now I need to teach my application to cache and check the input data for an already existing result. I think LoadingCache from Guava will help me Please help me pair my app with LoadingCache. To all who will respond, thanks a lot!", "abstract": ""}, "answers": [{"id": 70480894, "score": 2, "vote": 0, "content": "Please help me pair my app with LoadingCache. Merry X-Mas! There you go: I refactored \"little\" (simplified String[] to String, removed \"half\" of your classes, made the main method interactive), this is what came  out: pom.xml: Main.java In- and Output: (2nd calculation of \"hello\" is cached.) We see: Once identifying/understanding/defining , it is easy to a apply a (guava) cache to a given \"operation\". For advanced cache configuration, please refer to CacheBuilder javadoc, for advanced usage to LoadingCache javadoc. Rather advanced and theoretical but very related to this topic/ use case: Similarity Caching. To receive \"words\" from command line arguments, we can use a main() method like this: To make it completely \"without external libs\" (i.e. guava)we would (remove/clean up that dependencies,) we would then use it, as outlined in (accepted answer of) Easy, simple to use LRU cache in java : for \"unlimited\" cache (might be sufficient for tutor;), just: (For a thread-safe version, we'd have to:) LinkedHashMap javadoc 17 We could wrap our \"cache loading\" then like: and main method like: ;)#", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/69367898/java-caching-the-result-of-a-method-call", "keywords": [], "tags": ["java", "caching"], "question": {"id": 69367898, "title": "Java - Caching the result of a method call", "content": "I want to cache the result of a method call and in the code example and I looking into a Json to know if there is a property and I want to cache the result. I got this code:", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/4929540/is-there-anyway-to-cache-function-method-in-c", "keywords": [], "tags": ["c#", ".net"], "question": {"id": 4929540, "title": "Is there anyway to cache function/method in C#", "content": "I got bored with writing same to code again and again to cache the objects in data access layer.  Is there anyway to cache c# function results without much changes to functions. Is there any framework supports this functionality at the moment?  Can i archive the same by writing custom \"c# function attributes\"? if so, drop me some points to start implementation?", "abstract": ""}, "answers": [{"id": 4929560, "score": 7, "vote": 0, "content": "You can create caching attributes with PostSharp. You can use the Cache attribute.", "abstract": ""}, {"id": 16161898, "score": 27, "vote": 0, "content": "Possibility 1: Use IL Weaving Postsharp was mentioned before. You could also try the MethodCache.Fody package. Possibility 2: Use an Proxy / Interception Framework Example (Ninject & Ninject.Interception): Then you could decorate functions like this: Intercepted functions have to be virtual and classes must be created by the Ninject kernel. If you rely on performance, you could proxy classes directly via Castle.DynamicProxy (which is internally used by Ninject.Extensions.Interception.DynamicProxy). Possibility 3: Use an Expression wrapper You could pass the function as expression, generate a caching key containing class, method and parameter information and invoke the expression if not found in your Cache. This adds more runtime overhead than AOP / Proxy frameworks, but will be sufficient for simple solutions.", "abstract": ""}, {"id": 62022564, "score": 0, "vote": 0, "content": "You could use a Dictionary to cache the function. A dictionary maps keys to values and a function maps arguments to values. So conceptually, a dictionary fits as a cache for a function. Here's a simple class to do that: And here's a couple of interfaces to go with it:", "abstract": ""}, {"id": 53339109, "score": 3, "vote": 0, "content": "I use this simple implementation of the System.Runetime.Caching namespace: Can be used in the following manner: First call to the method will cache the result, the next call will return the cached result.", "abstract": ""}, {"id": 10412813, "score": 6, "vote": 0, "content": "If I read you question correct, the right term for what you want is memoization. Wikipedia gives more details on this subjects. Unfortunately there is no reference to a C# library supporting it. ", "abstract": ""}, {"id": 8328528, "score": 5, "vote": 0, "content": "Lazy store it's value after first run.\nExample: http://msdn.microsoft.com/en-us/vstudio/bb870976", "abstract": ""}, {"id": 4929647, "score": 0, "vote": 0, "content": "I suggest Spring.Net AOP.\nIt basically creates a proxy and the calls can be redirected from/to the cache.\nhttp://www.springframework.net/doc/reference/html/aop-quickstart.html and then you can have something like that for your advice:", "abstract": ""}, {"id": 4929556, "score": 2, "vote": 0, "content": "The Cache Application block is Microsoft's answer to built in library for Caching in .NET.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/58763234/cache-the-results-of-two-methods-in-a-single-cache-in-spring", "keywords": [], "tags": ["java", "spring", "spring-cache"], "question": {"id": 58763234, "title": "Cache the results of two methods in a single cache in Spring", "content": "I have two methods, the first returning a list of elements and the second returning a single element: I would like Spring to cache the results of these two methods, so that when the list of elements method (getUsersFromExternalSystem()) is called it caches the results for the provided ids (userIds) and when the single element method (getUserFromExternalSystem()) is called with the id previously provided to the list of elements method it uses the cache. I can simply apply @Cacheable to these methods, then (if I understand correctly) when I call: the results will be cached but when I call  the cache will not be used. How this be done in Spring?", "abstract": ""}, "answers": [{"id": 58764168, "score": 0, "vote": 0, "content": "You can use following approach. Only first method getUser(Integer id) is cacheable, and second method just combines the results of getUser invocations. The trick with injecting a bean into himself and calling  self.getUser(id) instead of this.getUser(id) is required because @Cacheable will be actually invoked only when used on a Spring proxied bean, and this is not a proxy. More details here Transactions, Caching and AOP: understanding proxy usage in Spring", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/56094097/how-to-cache-a-method-with-two-parameters-in-spring-mvc", "keywords": [], "tags": ["java", "rest", "spring-mvc", "ehcache"], "question": {"id": 56094097, "title": "How to Cache a Method with two parameters in Spring-Mvc", "content": "I want  to convert transactions's amount fields to another currency and I decided to use cache mechanism with @Cacheable annotations. In this cacheable method, I call an rest api method to get currency rate. According to I am setting caching period to 60 seconds and always send same parameters, program executes cacheable methods scope for each coming transactions. I want to see logs for every minutes or calling different parameter, I used log.error() because of this.  If I send 1000 transactions in four minutes. I see outputs below; getCurrencyRate calleddd EUR-USD - counter 1 times\ngetCurrencyRate calleddd EUR-USD - counter 2 times\n...\ngetCurrencyRate calleddd EUR-USD - counter 999 times\ngetCurrencyRate calleddd EUR-USD - counter 1000 times                       but I want to see like below; getCurrencyRate calleddd EUR-USD - counter 1 times\ngetCurrencyRate calleddd EUR-USD - counter 2 times\ngetCurrencyRate calleddd EUR-USD - counter 3 times\ngetCurrencyRate calleddd EUR-USD - counter 4 times                   Thank you for your help.", "abstract": ""}, "answers": [{"id": 56109266, "score": 1, "vote": 0, "content": "I fixed this problem. If I call cached method from other methods in same class like above, does not work. If I call directly cached method from other classes, works properly. I should use like below;", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44069122/cache-method-call-results-in-es6", "keywords": [], "tags": ["javascript", "ecmascript-6"], "question": {"id": 44069122, "title": "cache method call results in es6", "content": "Is it possible to cache method call results in es6, and how it can be done correct? example es2015: I'm looking for something like this, but in es6. Thanks for help!", "abstract": ""}, "answers": [{"id": 44079458, "score": 2, "vote": 0, "content": "Caching return values to avoid unwanted intensive operations is a great idea. The most common scenario for caching in OOP is when you need to create a lot of similar objects from a factory class. This is actually a GoF pattern (see Flyweight). In your case, if I understand your problem well, you are trying to use caching to avoid useless AJAX calls. With ES6, I think a good implementation could involve Map for caching and Promise for better asynchronous handling. In the following implementation with the GitHub API, ajax\u00a0is a static method, getUser is a prototype property and cache is a static attribute. \n\nclass GitHub {\r\n  static ajax(username) {\r\n    return new Promise((resolve, reject) => {\r\n      let req = new XMLHttpRequest();\r\n\r\n      req.onreadystatechange = function () {\r\n        if (this.readyState === XMLHttpRequest.DONE) {\r\n          if (this.status === 200) {\r\n            let json = JSON.parse(this.responseText),\r\n                user = {\r\n                  name: json.name,\r\n                  bio: json.bio\r\n                };\r\n            GitHub.cache.set(username, user);\r\n            resolve(user);\r\n          } else {\r\n            reject(new Error(`${this.status} ${this.statusText}`));\r\n          }\r\n        }\r\n      };\r\n\r\n      req.open('GET', `https://api.github.com/users/${username}`, true);\r\n      req.send(null);\r\n    });\r\n  }\r\n  \r\n  getUser(username = 'Badacadabra') {\r\n    if (!GitHub.cache.has(username)) {\r\n      console.log('AJAX');\r\n      return GitHub.ajax(username);\r\n    } else {\r\n      console.log('Cache');\r\n      return GitHub.cache.get(username);\r\n    }\r\n  }\r\n}\r\nGitHub.cache = new Map();\r\n\r\nlet github = new GitHub();\r\n\r\ngithub.getUser()\r\n  .then(console.log)\r\n  .then(() => github.getUser())\r\n  .then(console.log)\r\n  .then(() => github.getUser())\r\n  .then(console.log)\r\n  .catch(console.error);\n\n\n", "abstract": ""}]}]