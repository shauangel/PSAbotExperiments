[{"link": "https://stackoverflow.com/questions/39541370/how-to-insert-multiple-elements-into-a-list", "keywords": [], "tags": ["python", "list", "insert"], "question": {"id": 39541370, "title": "How to insert multiple elements into a list?", "content": "In JavaScript, I can use splice to insert an array of multiple elements in to an array: myArray.splice(insertIndex, removeNElements, ...insertThese). But I can't seem to find a way to do something similar in Python without having concat lists. Is there such a way? (There is already a Q&A about inserting single items, rather than multiple.) For example myList = [1, 2, 3] and I want to insert otherList = [4, 5, 6] by calling myList.someMethod(1, otherList) to get [1, 4, 5, 6, 2, 3]", "abstract": ""}, "answers": [{"id": 75698620, "score": 0, "vote": 0, "content": "", "abstract": ""}, {"id": 75182956, "score": 0, "vote": 0, "content": "The python equivalent of JavaScript would be:", "abstract": ""}, {"id": 73749650, "score": 1, "vote": 0, "content": "I'm not certain this question is still being followed but I recently wrote a short code that resembles what is being asked here. I was writing an interactive script to perform some analyses so I had a series of inputs serving to read in certain columns from a CSV: Then, I brought the for-loop into 1 line to read into the desired index position: This may not necessarily be as concise as it could be (I would love to know what might work even better!) but this might clean some of the code up.", "abstract": ""}, {"id": 39541404, "score": 105, "vote": 0, "content": "To extend a list, you just use list.extend.  To insert elements from any iterable at an index, you can use slice assignment...", "abstract": ""}, {"id": 66025418, "score": -1, "vote": 0, "content": "use listname.extend([val1,val2,val,etc])", "abstract": ""}, {"id": 63317242, "score": 0, "vote": 0, "content": "The following accomplishes this while avoiding creation of a new list. However I still prefer @RFV5s method. Note that it's necessary to reverse the order of tmp_list because pop() gives up the values from original_list backwards from the end.", "abstract": ""}, {"id": 39542557, "score": 5, "vote": 0, "content": "Python lists do not have such a method. Here is helper function that takes two lists and places the second list into the first list at the specified position:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/533905/how-to-get-the-cartesian-product-of-multiple-lists", "keywords": [], "tags": ["python", "list", "cartesian-product"], "question": {"id": 533905, "title": "How to get the Cartesian product of multiple lists", "content": "How can I get the Cartesian product (every possible combination of values) from a group of lists? For example, given How do I get this? One common application for this technique is to avoid deeply nested loops. See Avoiding nested for loops for a more specific duplicate. Similarly, this technique might be used to \"explode\" a dictionary with list values; see Combine Python Dictionary Permutations into List of Dictionaries . If you want a Cartesian product of the same list with itself multiple times, itertools.product can handle that elegantly. See Operation on every pair of element in a list or How can I get \"permutations with repetitions\" from a list (Cartesian product of a list with itself)?. Many people who already know about itertools.product struggle with the fact that it expects separate arguments for each input sequence, rather than e.g. a list of lists. The accepted answer shows how to handle this with *. However, the use of * here to unpack arguments is fundamentally not different from any other time it's used in a function call. Please see Expanding tuples into arguments for this topic (and use that instead to close duplicate questions, as appropriate).", "abstract": ""}, "answers": [{"id": 75673244, "score": 1, "vote": 0, "content": "If you want to re-implement yourself, you can try with recursion. Something as simple as: is a working start. The recursion depth is how many lists of categories you have", "abstract": ""}, {"id": 73668766, "score": 1, "vote": 0, "content": "In 99% of cases you should use itertools.product. It is written in efficient C code, so it is probably going to be better than any custom implementation. In the 1% of cases that you need a Python-only algorithm (for example, if you need to modify it somehow), you can use the code below. The interface is the same as for itertools.product. For example: This algorithm has the following advantages over other Python-only solutions on this page: This code is based on the itertools.product algorithm from PyPy, which is released under the MIT licence.", "abstract": ""}, {"id": 533917, "score": 597, "vote": 0, "content": "Use itertools.product, which has been available since Python 2.6. This is the same as:", "abstract": ""}, {"id": 69216124, "score": 1, "vote": 0, "content": "This can be done as another variable? No problem:", "abstract": ""}, {"id": 70320315, "score": 2, "vote": 0, "content": "List comprehension is simple and clean:", "abstract": ""}, {"id": 68420802, "score": 0, "vote": 0, "content": "The following code is a 95 % copy from Using numpy to build an array of all combinations of two arrays, all credits go there! This is said to be much faster since it is only in numpy. You need to define the dtype as a parameter if you do not want to take the dtype from the first entry for all entries. Take dtype = 'object' if you have letters and numbers as items. Test: Out:", "abstract": ""}, {"id": 65270108, "score": 1, "vote": 0, "content": "You can use itertools.product in the standard library to get the cartesian product. Other cool, related utilities in itertools include permutations, combinations, and combinations_with_replacement. Here is a link to a python codepen for the snippet below:", "abstract": ""}, {"id": 59588779, "score": 1, "vote": 0, "content": "I believe this works:", "abstract": ""}, {"id": 53990437, "score": 8, "vote": 0, "content": "Recursive Approach: Iterative Approach:", "abstract": ""}, {"id": 41071316, "score": 3, "vote": 0, "content": "A minor modification to the above recursive generator solution in variadic flavor: And of course a wrapper which makes it work exactly the same as that solution: with one trade-off: it checks if recursion should break upon each outer loop, and one gain: no yield upon empty call, e.g.product(()), which I suppose would be semantically more correct (see the doctest). Regarding list comprehension: the mathematical definition applies to an arbitrary number of arguments, while list comprehension could only deal with a known number of them.", "abstract": ""}, {"id": 42358457, "score": 10, "vote": 0, "content": "Although there are many answers already, I would like to share some of my thoughts:", "abstract": ""}, {"id": 533934, "score": 11, "vote": 0, "content": "In Python 2.6 and above you can use 'itertools.product`. In older versions of Python you can use the following (almost -- see documentation) equivalent code from the documentation, at least as a starting point: The result of both is an iterator, so if you really need a list for furthert processing, use list(result).", "abstract": ""}, {"id": 40715897, "score": 38, "vote": 0, "content": "I would use list comprehension : ", "abstract": ""}, {"id": 33425736, "score": 2, "vote": 0, "content": "Just to add a bit to what has already been said: if you use sympy, you can use symbols rather than strings which makes them mathematically useful. About sympy.", "abstract": ""}, {"id": 17102114, "score": 17, "vote": 0, "content": "Here is a recursive generator, which doesn't store any temporary lists Output:", "abstract": ""}, {"id": 533928, "score": 29, "vote": 0, "content": "with itertools.product:", "abstract": ""}, {"id": 534085, "score": 44, "vote": 0, "content": "For Python 2.5 and older: Here's a recursive version of product() (just an illustration): Example:", "abstract": ""}, {"id": 533919, "score": 123, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/20196159/how-to-append-multiple-values-to-a-list-in-python", "keywords": [], "tags": ["python", "list"], "question": {"id": 20196159, "title": "How to append multiple values to a list in Python", "content": "I am trying to figure out how to append multiple values to a list in Python. I know there are few methods to do so, such as manually input the values, or put the append operation in a for loop, or the append and extend functions. However, I wonder if there is neater way to do so? Maybe a certain package or function?", "abstract": ""}, "answers": [{"id": 75585655, "score": 1, "vote": 0, "content": "Another solution is to unpack both lists inside a new list and assign it back to the copy of the original list: An example: or assign to an empty slice as in Saumya Prasad's answer (but at the end of the list): It's worth noting that list.extend and slice assignment to an empty slice both modify the list in-place whereas itertools.chain or unpacking or + operator create a new list.", "abstract": ""}, {"id": 72623367, "score": 1, "vote": 0, "content": "One way you can work around this type of problem is - Here we are inserting a list to the existing list by creating a variable new_values. Note that we are inserting the values in the second index, i.e. a[2] But here insert() method will append the values as a list. So here goes another way of doing the same thing, but this time, we'll actually insert the values in between the items.", "abstract": ""}, {"id": 69020070, "score": 1, "vote": 0, "content": "if the number of items was saved in a variable say n. you can use list comprehension and plus sign for list expansion.", "abstract": ""}, {"id": 20196202, "score": 705, "vote": 0, "content": "You can use the sequence method list.extend to extend the list by multiple values from any kind of iterable, being it another list or any other thing that provides a sequence of values. So you can use list.append() to append a single value, and list.extend() to append multiple values.", "abstract": ""}, {"id": 20196195, "score": 14, "vote": 0, "content": "If you take a look at the official docs, you'll see right below append, extend.  That's what your looking for. There's also itertools.chain if you are more interested in efficient iteration than ending up with a fully populated data structure.", "abstract": ""}, {"id": 20196187, "score": 53, "vote": 0, "content": "Other than the append function, if by \"multiple values\" you mean another list, you can simply concatenate them like so.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46985602/python-how-to-search-for-multiple-items-in-a-list", "keywords": [], "tags": ["python"], "question": {"id": 46985602, "title": "Python: How to search for multiple items in a list", "content": "So i have a list with number values such as \nmy_num = [1,2,2,3,4,5] What i want is a code that will check if 1, 2 and 3 are in the list.\nWhat i had in mind was: if 1 and 2 and 3 in my_num: do something but the problem is if 1 and 3 are in the list the do something code executes anyways even without the 2 being there.", "abstract": ""}, "answers": [{"id": 74461807, "score": 0, "vote": 0, "content": "Depend on Paul Cornelius answer, I add something and some improvements to make it more understandable Searching list in list of lists", "abstract": ""}, {"id": 46985660, "score": 6, "vote": 0, "content": "Check out the standard library functions any and all.  You can write this:", "abstract": ""}, {"id": 46985644, "score": 0, "vote": 0, "content": "If lists lenghs are long:", "abstract": ""}, {"id": 46985619, "score": 0, "vote": 0, "content": "is not doing what you think it does: it tests if 1 which is True, and if 2, which is also True, then if 3 in my_num You must test for each condition individually:", "abstract": ""}, {"id": 46985614, "score": 2, "vote": 0, "content": "Try this:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6159313/how-to-test-the-membership-of-multiple-values-in-a-list", "keywords": [], "tags": ["python"], "question": {"id": 6159313, "title": "How to test the membership of multiple values in a list", "content": "I want to test if two or more values have membership on a list, but I'm getting an unexpected result: So, Can Python test the membership of multiple values at once in a list?\nWhat does that result mean? See also: How to find list intersection?. Checking whether any of the specified values is in the list, is equivalent to checking if the intersection is non-empty. Checking whether all the values are in the list, is equivalent to checking if they are a subset.", "abstract": ""}, "answers": [{"id": 73589151, "score": 0, "vote": 0, "content": "In Python3 you can use intersection of sets as an any: of course you could wrap the result in a bool for True/False values: Making use of `is subset: The examples can be cleaned up by using variables:", "abstract": ""}, {"id": 73459403, "score": -1, "vote": 0, "content": "", "abstract": ""}, {"id": 60565794, "score": 0, "vote": 0, "content": "Here's how I did it:", "abstract": ""}, {"id": 41998101, "score": 2, "vote": 0, "content": "I would say we can even leave those square brackets out. ", "abstract": ""}, {"id": 53703053, "score": 27, "vote": 0, "content": "If you want to check all of your input matches, if you want to check at least one match,", "abstract": ""}, {"id": 6159331, "score": 11, "vote": 0, "content": "I'm pretty sure in is having higher precedence than , so your statement is being interpreted as 'a', ('b' in ['b' ...]), which then evaluates to 'a', True since 'b' is in the array. See previous answer for how to do what you want.", "abstract": ""}, {"id": 47335436, "score": 2, "vote": 0, "content": "The reason I think this is better than the chosen answer is that you really don't need to call the 'all()' function. Empty list evaluates to False in IF statements, non-empty list evaluates to True.  Example:", "abstract": ""}, {"id": 6159329, "score": 283, "vote": 0, "content": "This does what you want, and will work in nearly all cases: The expression 'a','b' in ['b', 'a', 'foo', 'bar'] doesn't work as expected because Python interprets it as a tuple: There are other ways to execute this test, but they won't work for as many different kinds of inputs. As Kabie points out, you can solve this problem using sets... ...sometimes: Sets can only be created with hashable elements. But the generator expression all(x in container for x in items) can handle almost any container type. The only requirement is that container be re-iterable (i.e. not a generator). items can be any iterable at all. In many cases, the subset test will be faster than all, but the difference isn't shocking -- except when the question is irrelevant because sets aren't an option. Converting lists to sets just for the purpose of a test like this won't always be worth the trouble. And converting generators to sets can sometimes be incredibly wasteful, slowing programs down by many orders of magnitude. Here are a few benchmarks for illustration. The biggest difference comes when both container and items are relatively small. In that case, the subset approach is about an order of magnitude faster: This looks like a big difference. But as long as container is a set, all is still perfectly usable at vastly larger scales: Using subset testing is still faster, but only by about 5x at this scale. The speed boost is due to Python's fast c-backed implementation of set, but the fundamental algorithm is the same in both cases. If your items are already stored in a list for other reasons, then you'll have to convert them to a set before using the subset test approach. Then the speedup drops to about 2.5x: And if your container is a sequence, and needs to be converted first, then the speedup is even smaller: The only time we get disastrously slow results is when we leave container as a sequence: And of course, we'll only do that if we must. If all the items in bigseq are hashable, then we'll do this instead: That's just 1.66x faster than the alternative (set(bigseq) >= set(bigsubseq), timed above at 4.36). So subset testing is generally faster, but not by an incredible margin. On the other hand, let's look at when all is faster. What if items is ten-million values long, and is likely to have values that aren't in container? Converting the generator into a set turns out to be incredibly wasteful in this case. The set constructor has to consume the entire generator. But the short-circuiting behavior of all ensures that only a small portion of the generator needs to be consumed, so it's faster than a subset test by four orders of magnitude.  This is an extreme example, admittedly. But as it shows, you can't assume that one approach or the other will be faster in all cases. Most of the time, converting container to a set is worth it, at least if all its elements are hashable. That's because in for sets is O(1), while in for sequences is O(n).  On the other hand, using subset testing is probably only worth it sometimes. Definitely do it if your test items are already stored in a set. Otherwise, all is only a little slower, and doesn't require any additional storage. It can also be used with large generators of items, and sometimes provides a massive speedup in that case.", "abstract": ""}, {"id": 19038226, "score": -1, "vote": 0, "content": "how can you be pythonic without lambdas! .. not to be taken seriously .. but this way works too: leave out the end part if you want to test if any of the values are in the array:", "abstract": ""}, {"id": 10766630, "score": 1, "vote": 0, "content": "Both of the answers presented here will not handle repeated elements. For example, if you are testing whether [1,2,2] is a sublist of [1,2,3,4], both will return True. That may be what you mean to do, but I just wanted to clarify.\nIf you want to return false for [1,2,2] in [1,2,3,4], you would need to sort both lists and check each item with a moving index on each list. Just a slightly more complicated for loop.", "abstract": ""}, {"id": 6159356, "score": 72, "vote": 0, "content": "Another way to do it:", "abstract": ""}, {"id": 6159334, "score": 4, "vote": 0, "content": "The Python parser evaluated that statement as a tuple, where the first value was 'a', and the second value is the expression 'b' in ['b', 'a', 'foo', 'bar'] (which evaluates to True). You can write a simple function do do what you want, though: And call it like:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/18272160/access-multiple-elements-of-list-knowing-their-index", "keywords": [], "tags": ["python", "python-3.x", "list", "indexing", "element"], "question": {"id": 18272160, "title": "Access multiple elements of list knowing their index", "content": "I need to choose some elements from the given list, knowing their index. Let say I would like to create a new list, which contains element with index 1, 2, 5, from given list [-2, 1, 5, 3, 8, 5, 6]. What I did is: Is there any better way to do it? something like c = a[b] ?", "abstract": ""}, "answers": [{"id": 72557156, "score": 0, "vote": 0, "content": "The results for the latest pandas==1.4.2 as of June 2022 are as follows. Note that simple slicing is no longer possible and benchmark results are faster.", "abstract": ""}, {"id": 69507679, "score": 3, "vote": 0, "content": "List comprehension is clearly the most immediate and easiest to remember - in addition to being quite pythonic! In any case, among the proposed solutions, it is not the fastest (I have run my test on Windows using Python 3.8.3): My results are: List comprehension            :0.007113 secs \nOperator.itemgetter           :0.003247 secs \nUsing Pandas series           :2.977286 secs \nUsing map and getitem         :0.005029 secs \nEnumeration (Why anyway?)     :0.135156 secs \nNumpy                         :0.157018 secs", "abstract": ""}, {"id": 60874279, "score": -1, "vote": 0, "content": "Kind of pythonic way:", "abstract": ""}, {"id": 57825921, "score": 3, "vote": 0, "content": "Here's a simpler way:", "abstract": ""}, {"id": 57431930, "score": 1, "vote": 0, "content": "Don't forget that if the list is small and the indexes don't change, as in your example, sometimes the best thing is to use sequence unpacking: The performance is much better and you can also save one line of code:", "abstract": ""}, {"id": 18272249, "score": 317, "vote": 0, "content": "You can use operator.itemgetter: Or you can use numpy: But really, your current solution is fine. It's probably the neatest out of all of them.", "abstract": ""}, {"id": 46256877, "score": 15, "vote": 0, "content": "Another solution could be via pandas Series: You can then convert c back to a list if you want: ", "abstract": ""}, {"id": 39101031, "score": 2, "vote": 0, "content": "I'm sure this has already been considered: If the amount of indices in b is small and constant, one could just write the result like:  Or even simpler if the indices itself are constants... Or if there is a consecutive range of indices...", "abstract": ""}, {"id": 32517356, "score": 11, "vote": 0, "content": "Basic and not very extensive testing comparing the execution time of the five supplied answers: using the following input: simple python loop was the quickest with lambda operation a close second, mapIndexValues and getIndexValues were consistently pretty similar with numpy method significantly slower after converting lists to numpy arrays.If data is already in numpy arrays the numpyIndexValues method with the numpy.array conversion removed is quickest.", "abstract": ""}, {"id": 25546024, "score": -1, "vote": 0, "content": "My answer does not use numpy or python collections. One trivial way to find elements would be as follows: Drawback: This method may not work for larger lists. Using numpy is recommended for larger lists.", "abstract": ""}, {"id": 18272245, "score": 64, "vote": 0, "content": "Alternatives:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65990613/how-to-append-multiple-items-to-a-list-in-python", "keywords": [], "tags": ["python", "list", "beautifulsoup", "web-crawler"], "question": {"id": 65990613, "title": "how to append multiple items to a list in python", "content": "I have a list that i want to append multiple items to it using python when i try to add the system crash and display the below error: I already tried append() function  extend() function the same crash and error. expected result :", "abstract": ""}, "answers": [{"id": 65990820, "score": 0, "vote": 0, "content": "dataframe: output:", "abstract": ""}, {"id": 65990742, "score": 1, "vote": 0, "content": "You can use the list.extend method, but use square brackets around the items like so:", "abstract": ""}, {"id": 65990669, "score": 0, "vote": 0, "content": "For Extend function you need to provide a list/touple/dict/set to add multiple items. Like :-", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65641391/how-to-fetch-multiple-elements-from-list", "keywords": [], "tags": ["python"], "question": {"id": 65641391, "title": "How to fetch multiple elements from List", "content": "I have list l = [1,3,4,5,7,6,4,5,10,1], and i want to fetch elements in position 4, 8. I am using command l[4,8] to fetch both elements, but it's not working. Is it not right method?", "abstract": ""}, "answers": [{"id": 65641740, "score": 0, "vote": 0, "content": "When accessing a list you give it an index i and it returns the i'th element: Notice how when accessing the element \"3\" it will actually give the fourth element of the list. This is because counting array positions (lists in python) starts at zero in almost every programming language. (f*** Lua) Python has two extra features with lists not typically found in other languages. The first is negative overroll where when you give the list a negative index it will count from the back of the list: The second is native list slicing, where you can give the list two numbers and it will return a subset of elements in between these two indices: As mentioned by other users, you can access the two elements separately by separating them with a comma: Out is a tuple, which is basically a list you can't write to. You can separate the variables from a tuple (or a list) into separate variables by separating those with a comma on the left side of a definition: If you need to do this very often, here's a function that takes in a list of values and a list of indices, creates a new list and copies all given values into the new list: I'm pretty sure that this is a terrible solution performance wise but the code is pretty readable, which I think is good enough for a learners context.", "abstract": ""}, {"id": 65641492, "score": 0, "vote": 0, "content": "You could go for something like this: Output:", "abstract": ""}, {"id": 65641409, "score": 2, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65561736/access-multiple-items-of-list", "keywords": [], "tags": ["python", "arrays", "list", "numpy"], "question": {"id": 65561736, "title": "Access multiple items of list", "content": "Im currently trying to implement a replay buffer, in which i store 20 numbers in a list and then want to sample 5 of these numbers randomly. I tried the following with numpy arrays: This works the way it should, but i want the same done with a list instead of a numpy array. But when i try to get sample = ac[batch] with a list i get this error message: TypeError: only integer scalar arrays can be converted to a scalar index How can i access multiple elements of a list like it did with numpy?", "abstract": ""}, "answers": [{"id": 65561806, "score": 0, "vote": 0, "content": "For a list it is quite easy. Just use the sample function from the random module: Also on a side note: When you want to create a numpy array with a range of numbers, you don't have to create an array with zeros and then fill it in a for loop, that is less convenient and also significantly slower than using the numpy function arange. If you really want to create a batch list that conaints the indexes you want to access, then you will have to use a list comprehension to access those, since you cant just index a list with multiple indexes like a numpy array.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/47812858/how-to-get-multiple-elements-of-a-list", "keywords": [], "tags": ["python", "slice"], "question": {"id": 47812858, "title": "How to get multiple elements of a list", "content": "Is any way to get multiple elements of a list in a single statement? I did the following: Which returned: Ultimately I was trying to make a while loop using this by doing: I know I can probably take a long way and type each scenario out but there has to be a easier way.", "abstract": ""}, "answers": [{"id": 47817659, "score": 1, "vote": 0, "content": "You can use slicing in python to access the elements. EX: More Info on Slicing", "abstract": ""}]}]