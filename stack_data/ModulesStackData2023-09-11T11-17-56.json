[{"link": "https://stackoverflow.com/questions/744373/what-happens-when-using-mutual-or-circular-cyclic-imports", "keywords": [], "tags": ["python", "python-import", "circular-dependency", "cyclic-reference"], "question": {"id": 744373, "title": "What happens when using mutual or circular (cyclic) imports?", "content": "In Python, what happens when two modules attempt to import each other? More generally, what happens if multiple modules attempt to import in a cycle? See also What can I do about \"ImportError: Cannot import name X\" or \"AttributeError: ... (most likely due to a circular import)\"? for the common problem that may result, and advice on how to rewrite code to avoid such imports. See Why do circular imports seemingly work further up in the call stack but then raise an ImportError further down? for technical details on why and how the problem occurs.", "abstract": ""}, "answers": [{"id": 746067, "score": 461, "vote": 0, "content": "If you do import foo (inside bar.py) and import bar (inside foo.py), it will work fine. By the time anything actually runs, both modules will be fully loaded and will have references to each other. The problem is when instead you do from foo import abc (inside bar.py) and from bar import xyz (inside foo.py). Because now each module requires the other module to already be imported (so that the name we are importing exists) before it can be imported. The article When are Python circular imports fatal? gives four examples when circular imports are, for the reason explained above, nonfatal. The article cited above does not discuss star imports.", "abstract": ""}, {"id": 76506193, "score": 0, "vote": 0, "content": "I encounter this error too. In my case, I fixed it by swapping import-statements in the __init__.py", "abstract": ""}, {"id": 75821841, "score": 0, "vote": 0, "content": "This issue arose in my case when one of my python file was the same name as a library. Example you have a package 'abc' and file 'abc.py'. import abc will throw a cyclic error.", "abstract": ""}, {"id": 67673741, "score": 42, "vote": 0, "content": "To my surprise, no one has mentioned cyclic imports caused by type hints yet.\nIf you have cyclic imports only as a result of type hinting, they can be avoided in a clean manner. Consider main.py which makes use of exceptions from another file: And the dedicated exception class exceptions.py: This will raise an ImportError since main.py imports exception.py and vice versa through Foo and SpecificException. Because Foo is only required in exceptions.py during type checking, we can safely make its import conditional using the TYPE_CHECKING constant from the typing module. The constant is only True during type checking, which allows us to conditionally import Foo and thereby avoid the circular import error.\nSomething to note is that by doing so, Foo is not declared in exceptions.py at runtime, which leads to a NameError. To avoid that, we add from __future__ import annotations which transforms all type annotations in the module to strings. Hence, we get the following code for Python 3.7+: In Python 3.6, the future import does not exist, so Foo has to be a string: In Python 3.5 and below, the type hinting functionality did not exist yet.\nIn future versions of Python, the annotations feature may become mandatory, after which the future import will no longer be necessary. Which version this will occur in is yet to be determined. This answer is based on Yet another solution to dig you out of a circular import hole in Python by Stefaan Lippens.", "abstract": ""}, {"id": 74067535, "score": -2, "vote": 0, "content": "bar.py foo.py", "abstract": ""}, {"id": 57812078, "score": 6, "vote": 0, "content": "There are a lot of great answers here. While there are usually quick solutions to the problem, some of which feel more pythonic than others, if you have the luxury of doing some refactoring, another approach is to analyze the organization of your code, and try to remove the circular dependency. You may find, for example, that you have: File a.py File b.py In this case, just moving one static method to a separate file, say c.py: File c.py will allow removing the save_result method from A, and thus allow removing the import of A from a in b: Refactored File a.py Refactored File b.py In summary, if you have a tool (e.g. pylint or PyCharm) that reports on methods that can be static, just throwing a staticmethod decorator on them might not be the best way to silence the warning. Even though the method seems related to the class, it might be better to separate it out, especially if you have several closely related modules that might need the same functionality and you intend to practice DRY principles.", "abstract": ""}, {"id": 64761960, "score": 2, "vote": 0, "content": "Suppose you are running a test python file named request.py\nIn request.py, you write so this also most likely a circular import. Solution: Just change your test file to another name such as aaa.py, other than request.py. Do not use names that are already used by other libs.", "abstract": ""}, {"id": 52721478, "score": 1, "vote": 0, "content": "I solved the problem the following way, and it works well without any error. \nConsider two files a.py and b.py. I added this to a.py and it worked.  The output I get is ", "abstract": ""}, {"id": 51202552, "score": 14, "vote": 0, "content": "Module a.py : Module b.py Running \"Module a\" will output: It output this 3 lines while it was supposed to output infinitival because of circular importing.\nWhat happens line by line while running\"Module a\" is listed here:", "abstract": ""}, {"id": 51113816, "score": 2, "vote": 0, "content": "Circular imports can be confusing because import does two things: The former is done only once, while the latter at each import statement. Circular import creates situation when importing module uses imported one with partially executed code. In consequence it will not see objects created after import statement. Below code sample demonstrates it. Circular imports are not the ultimate evil to be avoided at all cost. In some frameworks like Flask they are quite natural and tweaking your code to eliminate them does not make the code better.  main.py b.by a.py python main.py output with comments", "abstract": ""}, {"id": 42563958, "score": 4, "vote": 0, "content": "I completely agree with pythoneer's answer here. But I have stumbled on some code that was flawed with circular imports and caused issues when trying to add unit tests. So to quickly patch it without changing everything you can resolve the issue by doing a dynamic import. Again, this isn't a permanent fix but may help someone that wants to fix an import error without changing too much of the code. Cheers! ", "abstract": ""}, {"id": 744410, "score": 128, "vote": 0, "content": "Cyclic imports terminate, but you need to be careful not to use the cyclically-imported modules during module initialization. Consider the following files: a.py: b.py: If you execute a.py, you'll get the following: On the second import of b.py (in the second a in), the Python interpreter does not import b again, because it already exists in the module dict. If you try to access b.x from a during module initialization, you will get an AttributeError. Append the following line to a.py: Then, the output is: This is because modules are executed on import and at the time b.x is accessed, the line x = 3 has not be executed yet, which will only happen after b out.", "abstract": ""}, {"id": 33547682, "score": 50, "vote": 0, "content": "As other answers describe this pattern is acceptable in python: Which will avoid the execution of the import statement when the file is imported by other modules. Only if there is a logical circular dependency, this will fail. Most Circular Imports are not actually logical circular imports but rather raise ImportError errors, because of the way import() evaluates top level statements of the entire file when called. These ImportErrors can almost always be avoided  if you positively want your imports on top: Consider this circular import: From David Beazleys excellent talk Modules and Packages: Live and Let Die! - PyCon 2015, 1:54:00, here is a way to deal with circular imports in python: This tries to import SimplifiedImageSerializer and if ImportError is raised, because it already is imported, it will pull it from the importcache. PS: You have to read this entire post in David Beazley's voice.", "abstract": ""}, {"id": 28356950, "score": 0, "vote": 0, "content": "Ok, I think I have a pretty cool solution.\nLet's say you have file a and file b.\nYou have a def or a class in file b that you want to use in module a, but you have something else, either a def, class, or variable from file a that you need in your definition or class in file b. \nWhat you can do is, at the bottom of file a, after calling the function or class in file a that is needed in file b, but before calling the function or class from file b that you need for file a, say import b\nThen, and here is the key part, in all of the definitions or classes in file b that need the def or class from file a (let's call it CLASS), you say from a import CLASS This works because you can import file b without Python executing any of the import statements in file b, and thus you elude any circular imports. For example: Voila.", "abstract": ""}, {"id": 746655, "score": 12, "vote": 0, "content": "I got an example here that struck me! foo.py bar.py main.py At the command line: $ python main.py", "abstract": ""}, {"id": 744403, "score": 365, "vote": 0, "content": "There was a really good discussion on this over at comp.lang.python last year. It answers your question pretty thoroughly. Imports are pretty straightforward really. Just remember the following: 'import' and 'from xxx import yyy' are executable statements. They execute\n  when the running program reaches that line. If a module is not in sys.modules, then an import creates the new module\n  entry in sys.modules and then executes the code in the module. It does not\n  return control to the calling module until the execution has completed. If a module does exist in sys.modules then an import simply returns that\n  module whether or not it has completed executing. That is the reason why\n  cyclic imports may return modules which appear to be partly empty. Finally, the executing script runs in a module named __main__, importing\n  the script under its own name will create a new module unrelated to\n  __main__. Take that lot together and you shouldn't get any surprises when importing\n  modules. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/74020217/how-can-i-have-two-modules-interact-with-each-other-without-having-a-circular-im", "keywords": [], "tags": ["python", "circular-dependency"], "question": {"id": 74020217, "title": "How can I have two modules interact with each other without having a circular import on Python?", "content": "I am making a small game with several files including : Entity.py , Map.py. I want Map to be able to manage an Entity position, so I have to import Entity in Map, but I also want Entity to be able to know the map on which it is, so I have to import Map in Entity. Obviously this leads to circular imports, and I know a lot of answers to this problem is \"You just have to modify your design pattern\" and ofc I could do that, but I want to know if there is a way in python to have this kind of structure that I got used to be able to use in Java.", "abstract": ""}, "answers": [{"id": 76547095, "score": 0, "vote": 0, "content": "Here is something that may work for you: a.py: b.py: No output from: Output from: Lots of variations on the theme. Hope this helps.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73164709/how-to-import-dependent-code-from-two-modules", "keywords": [], "tags": ["python", "import"], "question": {"id": 73164709, "title": "How to import dependent code from two modules?", "content": "I have the following situation: The first file, named a.py contains: The second file, named b.py contains: The third file, named c.py contains: and raises the given error. I always thought that the import statement basically \"copies\" code into the calling namespace, so it should be the same as: but apparently this is not the case. What am I missing?", "abstract": ""}, "answers": [{"id": 73164787, "score": 1, "vote": 0, "content": "When you import a module, the code in that module is run by the interpreter (see this for example; add a print statement in there and you'll see it in action). Therefore you can't use variables etc without defining them or importing them. In b.py do this at the top: Then, unless you need var in c.py, you won't need to import anything from a.py in c.py. I know this is fake code, but avoid using globals in your functions.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70805354/how-to-setup-imports-and-dependencies-between-modules-in-the-same-python-package", "keywords": [], "tags": ["python", "module", "package"], "question": {"id": 70805354, "title": "How to setup imports and dependencies between modules in the same python package", "content": "I am writing a library in python. It has one package and 3 modules, such as If I just leave the __init__.py empty, my users must figure out which functions are in which modules, which is annoying. The fact that I have three modules is an implementation detail that is not important. Maybe I should import the main functions into the __init__.py, like this so that my users can just do Is that best practice? What about the alternative to put ALL symbols into the __init__.py, such as And if there are any functions that I don't want to expose, I will prefix them with underscore. Is that better?  It certainly is easier for me. What if the fileio.py needs to call some functions in the utils.py?  I could put into the fileio.py, but won't that create a circular or redundant reference? What's the best way to handle this?", "abstract": ""}, "answers": [{"id": 70805470, "score": 3, "vote": 0, "content": "Maybe I should import the main functions into the init.py, like this [...] Is that best practice? I wouldn't say there is a \"best practice\", it depends on the specific case, but this is surely pretty common: you define a bunch of stuff in each module, and import the relevant ones in __init__. This is an easy way to not bother the users with remembering which submodule has the needed function, however it can get pretty annoying if you have a lot of functions to import from each module. What about the alternative to put ALL symbols into the init.py, such as You most likely don't want to do this. This will import everything in user scripts, including other imported modules and internal functions. You should avoid it. What if the fileio.py needs to call some functions in the utils.py? [...] won't that create a circular or redundant reference? Yeah, that is something that can happen and you usually want to avoid it at all costs. If you need some functions from utils.py in fileio.py, you should import them explicitly as from .utils import x, y, z. Remember to also always use relative imports when importing things between modules of the same package (i.e. use from .utils import x, not from package.utils import x). A good compromise between these two options you mention which solves most of the above problems (although not circular imports, you would have to avoid those yourself) would be to define an __all__ list inside each one of your modules to specify which functions should be exported when using from x import *, like this: If you properly define an __all__ list in all your modules, then in your __init__.py you will be able to safely do: This will only import relevant functions (for example user_api_one and user_api_two for utils, and not internal_function nor sys).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/28800006/python-import-of-modules-with-mutual-dependency", "keywords": [], "tags": ["python"], "question": {"id": 28800006, "title": "Python: import of Modules with mutual dependency", "content": "I have two files rest_api.py and Contact.py. Contact is similar to a domain object (contains Contact class), while rest_api has functions for setting up the application. In rest_api I have the following lines: In Contact I try to do the following: This fails with the following error:\nImportError: cannot import name Contact What is the correct way of importing contact, so that it can also use variables/functions from rest_api? p.s If I move the collection code to a different file, and import that file instead things work, but I assume there is some other way..", "abstract": ""}, "answers": [{"id": 30415520, "score": 0, "vote": 0, "content": "Assuming you haven't a clue which modules are going to import which ever other ones, you can track that yourself and NOT do the import. In your __init__.py, define these -- Then, at the top of each class file, where you define your classes add the following to this_module.py: and this to that_module.py: now you get your imports regardless of which gets imported first or whatever.", "abstract": ""}, {"id": 28800149, "score": 2, "vote": 0, "content": "This is a circular import dependency, which cannot be solved as such. The problem is, that importing a python module really runs  the code, which has to follow some order, one of the modules has to go first. I would say that having the support code in a different file would be the proper way to go. In this case however, the dbcollection is not actually needed at import time. Thus you can solve this by removing the import from the module level, into the get function. For example A similar approach would be the following: This should work, as python does some effort to resolve circular import dependencies: When it start importing a module, it creates an empty module dict for that one. Then when it finds a nested import, it proceeds with that one. If that in turn imports a module that is already in the import process it just skips it. Thus at the time Contact.py is being loaded, the import rest_api just takes the module dict that is already there. Since it does not contain dbcollection yet, from rest_api import dbcollection fails. A simple import rest_api does work however, since it's member is only addressed after Contact.py finishes importing (unless you call Contact.get at module level from within).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/59977711/python-import-module-which-need-to-import-other-module", "keywords": [], "tags": ["python", "import", "module"], "question": {"id": 59977711, "title": "Python - Import module which need to import other module", "content": "I made a module that makes a linear regression model and draws a graph.\nSo the module needs to import some packages such as sklearn and matplotlib.\nAnd I want to import this module to another python file and use it. I think either of the two python files needs to import the above packages..\nwhich of them needs to import? In below case, my_module.py should import LinearRegression? or my_module2.py should? ex)", "abstract": ""}, "answers": [{"id": 59977764, "score": 0, "vote": 0, "content": "First you import it in my_module.py, then import * from my_module.py to my_module2.py.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44538400/how-do-i-import-files-that-mutually-import-each-other", "keywords": [], "tags": ["python", "python-3.x", "dictionary", "recursion", "tinydb"], "question": {"id": 44538400, "title": "How do i import files that mutually import each other?", "content": "how do i import a function and a dictionary that mutually imports each other. These two files are already in the same directory thus, there is no nid to import sys. Also, i this it is recursive that is why it is unable to import. How do i import a dictionary from each other's file without making it recursive and causing an error? I did go to this website here but it did not answer my question nor did it provide any example code to guide me thus, i created this question with a test code to explain my issue. let's say i have these two files: boxA and boxR, each has a dictionary keyA and keyR and functions named generatekeyA and generatekeyR in boxA: in boxR: Let me explain the codes above. I have 2 files that generate keys for me after which, i have to export the output into a json file. output.json file prints out keyA's own serial no and secret id and only keyR's secretid and viceversa into output2.json file. but the thing is that eventhough i research on recursive outputs, i still do not understand how to fix it because it does not provide any sample code as a guide. What is the best way to approach this such that i do not have to make much changes to the file(s)? Error tells me that it could be a recursive error:", "abstract": ""}, "answers": [{"id": 44561967, "score": 0, "vote": 0, "content": "I'm still struggling to figure out the exact shape of your code, which is crucial in Python. In future it would be helpful to read over your question more thoroughly and be certain the formatting is correct. Based on some assumptions I've made (most importantly that the with statement that adds to the database occurs outside the while loop) here is what I've come up with. In summary, the changes are: Changed the key generation functions to return the keys that they generate. Created a new Python file (called new.py, but you can call it whatever you want) which handles the updating of the database. Imported the generation functions into new.py and called them there, before executing the with statement that requires both keys. And here is the code that I ended up with. Hope it helps. boxA.py boxR.py new.py", "abstract": ""}, {"id": 44539380, "score": 0, "vote": 0, "content": "in boxA: in boxR: UPDATE If you're still seeing the issue, you probably haven't removed the import for keyR from the global scope of boxA and the import of keyA from the global scope of boxR. For example, this works as expected: From the bash prompt:", "abstract": ""}, {"id": 44538594, "score": 1, "vote": 0, "content": "This is a circular dependency. I am not sure how you can solve it without changing the basic structure of the modules and therefore the dependency graph. Why don't you try to define both the dicts in a separate file and import them. As it looks like form your code they are empty dicts anyway. You may find this article interesting. In essence, when you do a recursive dependency the imported modules find each other as empty module at the time of import statement execution. And thus this error shows up", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/32829691/python-modules-partially-importing-from-each-other", "keywords": [], "tags": ["python", "python-module"], "question": {"id": 32829691, "title": "Python modules (partially) importing from each other", "content": "I'm breaking up a large-ish (for me anyway!) project into 2 or 3 modules, including a 'main' module with the top level menu etc.   It will import a two or three 'sub-modules' for different aspects of the application.   However those modules will need various settings etc from the main module.   Yes, they could be passed as arguments but there are quite a few of them and they are liable to change.  Different modules will need different sub-sets of the settings. I'd like to be able to have the subordinate modules simply 'reach back' for their settings as needed (sort of global across modules as it were). Here is a mickie-mouse example of what I mean: test1: test2: And the results is Presumably this is due to potential circularity.  (Though, if its able to detect the circularity - not hard in this case!, ie that taskA has already been imported, you'd think its able to simply break out of the circularity, as opposed to throwing an error).  Is there a way to achieve this?   There's several obvious ways to code around it - keep it as one module; pass the settings as arguments (but that will have pitfalls if 'test2' has to modify any of the settings, if only as Im still getting my head around python's handling of mutable objects and binding); move all the settings to a separate module (test0) accessed by both test1 and test2. Given that these modules are intimately connected (I believe the term is strongly coupled), logically it should all be one module.  Except that its getting big.   My question is twofold ... how best to do what I want; but also to understand why Python cant handle mutual imports.", "abstract": ""}, "answers": [{"id": 32830199, "score": 1, "vote": 0, "content": "(1) Try moving your \"mode = 1\" line before the import.  This makes it no longer sequentially dependent on the import statement. (2) If that doesn't work, put the mode into a separate package and have both test1 and test2 import mode from there. The basic problem is that you've mingled levels of dependency.  You created an artificial link between \"mode\" and other items in that module. I don't see where you're having trouble with setting \"mode\"; I did it just fine on the first try. test0.py test1.py test2.py execution In your original example:\n(A) in test1.py, move the mode=1 line to before the import: This switch shows that mode cannot depend on anything in module taskA, breaking the pathological circular dependence. (B) Run the program with test2.py as the top-level module: Does that get you where you want to be? In general, you should design your dependencies in a Directed Acyclic Graph (DAG).  C can be simple-minded, but good with this, separating header (.h) and code (.c) files. That's why I suggested the third file to hold your \"mode\" declaration.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11698530/two-python-modules-require-each-others-contents-can-that-work", "keywords": [], "tags": ["python", "python-module"], "question": {"id": 11698530, "title": "Two Python modules require each other&#39;s contents - can that work?", "content": "I have a Bottle webserver module with the following line: And the foobar.formtools module contains this line: Of course, both result in the following errors (respectively): ImportError: cannot import name auto_process_form_insert\n  ImportError: cannot import name redirect Is it simply a fact that in Python two modules can't import each other and all module imports must be hierarchical in nature, or am I doing something wrong? Alternatively, is there a workaround short of placing all these nice functions in new modules?", "abstract": ""}, "answers": [{"id": 11698542, "score": 105, "vote": 0, "content": "Modules can import each other cyclically, but there's a catch. In the simple case, it should work by moving the import statements to the bottom of the file or not using the from syntax. Here's why that works: When you import a module, Python first checks sys.modules. If it's in there, it just imports from there. If it's not there, it tries to import it in the normal way; basically, it finds the file and runs the stuff in it. Running a module populates the module's contents. For example, say we have this module, creatively named example_opener: At the start, the module is empty. Then Python executes: After that, the module only contains webbrowser. Then Python executes this: Python creates open_example. Now the module contains webbrowser and open_example. Say webbrowser contained this code: Say example_opener is imported first. This code is executed: webbrowser has not yet been imported, so Python executes the contents of webbrowser: example_opener has been imported, but not yet fully executed. Python doesn't care. Python pulls the module out of sys.modules. At this point, example_opener is still empty. It hasn't defined open_example yet, nor even completed importing webbrowser. Python can't find open_example in example_opener, so it fails. What if we imported open_example from the end of webbrowser and webbrowser from the end of example_opener? Python would start by executing this code: webbrowser does not exist yet, but it doesn't matter until open_example is called. Now example_opener contains only open_example. It then executes: It has not been imported yet, so Python executes webbrowser. It starts: It defines open. Then it executes: example_opener is in sys.modules, so it uses that. example_opener contains open_example, so it succeeds. Python finishes importing webbrowser. That concludes importing webbrowser from example_opener. That's the last thing in example_opener, so the import of example_opener finishes, successful, as well.", "abstract": ""}, {"id": 11698590, "score": 39, "vote": 0, "content": "Don't do from ... import ....  Just do import ... and reference its objects using the module name.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/9642451/python-files-import-from-each-other", "keywords": [], "tags": ["python", "import", "compilation", "package", "importerror"], "question": {"id": 9642451, "title": "Python files - import from each other", "content": "I would like for two of my python files to import some methods from each other.  This seems to be giving me import errors.  Example:  file_A.py: file_B.py: The reason I am trying to do this is because I would like to organize my project in the way it intuitively makes sense to me as opposed to organizing it with respect to what makes sense to the compiler. Is there a way to do this? Thanks!", "abstract": ""}, "answers": [{"id": 9642488, "score": 35, "vote": 0, "content": "Don't use the names within the other module directly.", "abstract": ""}]}]