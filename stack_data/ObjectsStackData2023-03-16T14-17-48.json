[{"link": "https://stackoverflow.com/questions/3786881/what-is-a-method-in-python", "keywords": [], "tags": ["python", "methods"], "question": {"id": 3786881, "title": "What is a &quot;method&quot; in Python?", "content": "Can anyone, please, explain to me in very simple terms what a \"method\" is in Python? The thing is in many Python tutorials for beginners this word is used in such way as if the beginner already knew what a method is in the context of Python. While I am of course familiar with the general meaning of this word, I have no clue what this term means in Python. So, please, explain to me what the \"Pythonian\" method is all about. Some very simple example code would be very much appreciated as a picture is worth thousand words.", "abstract": ""}, "answers": [{"id": 74548037, "score": 0, "vote": 0, "content": "The python doc explains about a method as shown below: ... A method is a function that \u201cbelongs to\u201d an object. (In Python, the\nterm method is not unique to class instances: other object types can\nhave methods as well. For example, list objects have methods called\nappend, insert, remove, sort, and so on. ... And, the python doc also explains about a function as shown below: A series of statements which returns some value to a caller. It can\nalso be passed zero or more arguments which may be used in the\nexecution of the body. ... And, the python doc also explains about an object as shown below: Objects are Python\u2019s abstraction for data. All data in a Python\nprogram is represented by objects or by relations between objects. (In\na sense, and in conformance to Von Neumann\u2019s model of a \u201cstored\nprogram computer\u201d, code is also represented by objects.) Every object has an identity, a type and a value. An object\u2019s identity\nnever changes once it has been created; you may think of it as the\nobject\u2019s address in memory. The \u2018is\u2019 operator compares the identity of\ntwo objects; the id() function returns an integer representing its\nidentity.", "abstract": ""}, {"id": 70011059, "score": 0, "vote": 0, "content": "A method is a function that \u2018belongs\u2019 to an object and has a specific name: where obj is some object (this may be an expression), and methodname is the name of a method that is defined by the object\u2019s type. It is worth of noting: we call method like any other function.\nMore can be found in python tutorial.", "abstract": ""}, {"id": 3786900, "score": 92, "vote": 0, "content": "It's a function which is a member of a class: Simple as that! (There are also some alternative kinds of method, allowing you to control the relationship between the class and the function.  But I'm guessing from your question that you're not asking about that, but rather just the basics.)", "abstract": ""}, {"id": 59040078, "score": 0, "vote": 0, "content": "To understand methods you must first think in terms of object oriented programming:\nLet's take a car as a a class. All cars have things in common and things that make them unique, for example all cars have 4 wheels, doors, a steering wheel.... but Your individual car (Lets call it, my_toyota) is red, goes from 0-60 in 5.6s \nFurther the car is currently located at my house, the doors are locked, the trunk is empty... All those are properties of the instance of my_toyota. your_honda might be on the road, trunk full of groceries ... However there are things you can do with the car. You can drive it, you can open the door, you can load it. Those things you can do with a car are methods of the car, and they change a properties of the specific instance.  as pseudo code you would do: to change the location from my home to the shop or by this the trunk is now loaded with [milk, butter, bread].  As such a method is practically a function that acts as part of the object: the code then would be:", "abstract": ""}, {"id": 54966515, "score": 0, "vote": 0, "content": "If you think of an object as being similar to a noun, then a method is similar to a verb. Use a method right after an object (i.e. a string or a list) to apply a method's action to it.", "abstract": ""}, {"id": 35812834, "score": 28, "vote": 0, "content": "In Python, a method is a function that is available for a given object because of the object's type. For example, if you create my_list = [1, 2, 3], the append method can be applied to my_list because it's a Python list: my_list.append(4). All lists have an append method simply because they are lists. As another example, if you create my_string = 'some lowercase text', the upper method can be applied to my_string simply because it's a Python string: my_string.upper(). Lists don't have an upper method, and strings don't have an append method. Why? Because methods only exist for a particular object if they have been explicitly defined for that type of object, and Python's developers have (so far) decided that those particular methods are not needed for those particular objects. To call a method, the format is object_name.method_name(), and any arguments to the method are listed within the parentheses. The method implicitly acts on the object being named, and thus some methods don't have any stated arguments since the object itself is the only necessary argument. For example, my_string.upper() doesn't have any listed arguments because the only required argument is the object itself, my_string. One common point of confusion regards the following: Is sqrt a method of the math object? No. This is how you call the sqrt function from the math module. The format being used is module_name.function_name(), instead of object_name.method_name(). In general, the only way to distinguish between the two formats (visually) is to look in the rest of the code and see if the part before the period (math, my_list, my_string) is defined as an object or a module.", "abstract": ""}, {"id": 19699546, "score": 0, "vote": 0, "content": "http://docs.python.org/2/tutorial/classes.html#method-objects Usually, a method is called right after it is bound: In the MyClass example, this will return the string 'hello world'.\n  However, it is not necessary to call a method right away: x.f is a\n  method object, and can be stored away and called at a later time. For\n  example: will continue to print hello world until the end of time. What exactly happens when a method is called? You may have noticed\n  that x.f() was called without an argument above, even though the\n  function definition for f() specified an argument. What happened to\n  the argument? Surely Python raises an exception when a function that\n  requires an argument is called without any \u2014 even if the argument\n  isn\u2019t actually used... Actually, you may have guessed the answer: the special thing about\n  methods is that the object is passed as the first argument of the\n  function. In our example, the call x.f() is exactly equivalent to\n  MyClass.f(x). In general, calling a method with a list of n arguments\n  is equivalent to calling the corresponding function with an argument\n  list that is created by inserting the method\u2019s object before the first\n  argument. If you still don\u2019t understand how methods work, a look at the\n  implementation can perhaps clarify matters. When an instance attribute\n  is referenced that isn\u2019t a data attribute, its class is searched. If\n  the name denotes a valid class attribute that is a function object, a\n  method object is created by packing (pointers to) the instance object\n  and the function object just found together in an abstract object:\n  this is the method object. When the method object is called with an\n  argument list, a new argument list is constructed from the instance\n  object and the argument list, and the function object is called with\n  this new argument list.", "abstract": ""}, {"id": 11512621, "score": 4, "vote": 0, "content": "Sorry, but--in my opinion--RichieHindle is completely right about saying that method... It's a function which is a member of a class. Here is the example of a function that becomes the member of the class. Since then it behaves as a method of the class. Let's start with the empty class and the normal function with one argument: Now we add a member to the C class, which is the reference to the function. After that we can create the instance of the class and call its method as if it was defined inside the class: We can use also the alternative way of calling the method: The o.func even manifests the same way as the class method: And we can try the reversed approach. Let's define a class and steal its method as a function: So far, it looks the same. Now the function stealing: The truth is that the method does not accept 'whatever' argument: IMHO, this is not the argument against method is a function that is a member of a class. Later found the Alex Martelli's answer that basically says the same. Sorry if you consider it duplication :)", "abstract": ""}, {"id": 3787670, "score": 45, "vote": 0, "content": "A method is a function that takes a class instance as its first parameter. Methods are members of classes. As you wanted to know what it specifically means in Python, one can distinguish between bound and unbound methods. In Python, all functions (and as such also methods) are objects which can be passed around and \"played with\". So the difference between unbound and bound methods is: 1) Bound methods Bound methods are methods that belong to instances of a class. In this example, instance.method is bound to the instance called instance. Everytime that bound method is called, the instance is passed as first parameter automagically - which is called self by convention. 2) Unbound methods When you access C.method (the method inside a class instead of inside an instance), you get an unbound method. If you want to call it, you have to pass the instance as first parameter because the method is not bound to any instance. Knowing that difference, you can make use of functions/methods as objects, like passing methods around. As an example use case, imagine an API that lets you define a callback function, but you want to provide a method as callback function. No problem, just pass self.myCallbackMethod as the callback and it will automatically be called with the instance as first argument. This wouldn't be possible in static languages like C++ (or only with trickery). Hope you got the point ;) I think that is all you should know about method basics. You could also read more about the classmethod and staticmethod decorators, but that's another topic.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44741054/python-class-methods-when-is-self-not-needed", "keywords": [], "tags": ["python"], "question": {"id": 44741054, "title": "Python class methods: when is self not needed", "content": "I'm trying to rewrite some code using classes. At some point what I want is assign a member function a particular definition using a parameter value for each instance of an object. Coming from other languages (JavaScript, C++, Haskell, Fortran, ...) I am struggling to understand a few things on Python. One thing is the following distinction of self in class methods. For instance, the following code obviously won't work: which gives the error that \"sq() takes 0 positional arguments but 1 was given\".  The reason, as I understand it, is that at execution time the function is passed a reference to the calling object (the instance calling sq) as first argument before any other parameter/argument we may have defined/called sq with. So the solution is simple: change the code of sq to def sq(self):. Indeed, the Python tutorial 1 seems to suggest that object methods should always be defined with self as first parameter. Doing so we get as expected 666 666 49. So far so good. However, when I try to implement my class like this: I get the error Yet, a workaround ( solution??) is defining the the step function without the parameter self (!) as Then I get the expected behavior (at least for this trivial test) of 1. So, not only is self not needed here, but it even is incorrect an use here! But according to the tutorial mentioned above, or to the answers in threads like this 2 or this 3, it seems to me this code shouldn't work...or should have some unexpected consequences at some point(?). Indeed, if I remove all references to self in the definition of _getActivation I get the error message _getActivation() takes from 0 to 1 positional arguments but 2 were given which I can understand according to that rule. The thread \"Why is self not used in this method\" 4 does not provide a clear answer to me: What syntax detail of the code above tells me that self is not needed? For instance, how is that code different from this tutorial example ? Instantiating this class works as expected, but it complains about missing parameter (I know it could be any label) if defined with none.  This makes me question whether my code is not hiding a time bomb somehow: is self passed as the value for x? It works as expected so I'd say no, but then I'm facing this conundrum.  I guess I'm missing some key ideas of the language. I admit I also struggle with the question the OP of reference 3 is asking^. [^]: In JS one just uses this in the function body, and the function itself is defined either as member of the object's prototype or as an instance member which then gets assigned correctly using...this.  EDIT: \nThe thread is long. For those browsing for some help, if you are new to Python, then you may want to check the selected solution and its comments. However, if you already know about bound/unbound methods in Python, you just want to check directly the use of descriptor as described in Blckknght's answer. I finally opted for this way in my code using __get__ in the assignment to run.  ", "abstract": ""}, "answers": [{"id": 44741389, "score": 15, "vote": 0, "content": "In Python, every normal method is forced to accept a parameter commonly named self. This is an instance of class - an object. This is how Python methods interact with a class's state. You are allowed to rename this parameter whatever you please. but it will always have the same value: However, what you are probably confused about is how this code works differently: This is because of the distinction between bound, and unbound methods in Python. When we do this in __init__(): We are referring to the unbound method method. That means that our reference to method is not bound to any specific instance of Class, and thus, Python will not force method to accept an object instance.  because it does not have one to give. The above code would be the same as doing this: In both examples, we are calling the method method of the class object Class , and not an instance of the Class object. We can further see this distinction by examining the repr for a bound and unbound method: As you can see, in the first example when we do Class.method, Python shows:\n<function Class.method at 0x03E43D68>. I've lied to you a little bit. When we have an unbound method of a class, Python treats them as plain functions. So method is simply a function that is not bound to any instance of `Class. However in the second example, when we create an instance of Class, and then access the method object of it, we see printed: <bound method Class.method of <__main__.Class object at 0x03BD2FB0>>. The key part to notice is bound method Class.method. That means method is **bound** to cls - a specfic an instance of Class. As @jonshapre mentioned, writing code like in your example leads to confusion (as proof by this question), and bugs. It would be a better idea if you simply defined nonLinearBipolarStep() outside of Activation, and reference that from inside of Activation.activation_functions: I guess a more specific question would be: what should I pay attention to on that code in order to become evident that ag.run(x) would be a call to an unbound function? If you'd still like to let nonLinearBipolarStep be unbound, then I recommend simply being carefully. If you think your method would make for the cleanest code then go for it, but make sure you know what you are doing and the behavior your code will have. If you still wanted to make is clear to users of your class that ag.run() would be static, you could document it in a docstring somewhere, but that is something the user really shouldn't even have to be concerned with at all.", "abstract": ""}, {"id": 44741253, "score": 1, "vote": 0, "content": "You're using unbound method (nonLinearBipolarStep) in this code: Longer answer: methods are functions defined within class body and always take at least one argument, so called self (unless you use @staticfunction and turn them into normal functions). Self is an object of a given class, on which method is called (like this in C++). In python there's almost nothing special about this argument, it doesnt have to be named self. Now when you call unbound method, then first argument you've given will be interpreted as self and consumed. If you call bound methods, then this consumption doesnt happen (the method already has its self object). For example: UPDATE:\nWhy it works at all. Short answer: because dot (.) operator will update unbound method to bound when it can. Consider, what happens, when you write a.foo(1). First python check object a for foo and finds nothing (foo is not a value assigned to a). So it goes to a class (named A) and lo and behold - foo is there and is used. But here is a trick. Python will bind object a to unbound method A.foo (details escape me now, so imagine dragon did it) and make it into bound method. So a.foo is bound and doesnt need self anymore from arguments, thus 1 goes into argument x and everything works. Now to your code: you use 'bipolar': nonLinearBipolarStep in map, which is unbound method. Then in constructor (init) you set self.run to value returned from _getActivation, which is taken from activationFunctions map. In given example you return nonLinearBipolarStep unbound method and assign it to self.run. Now you call ag.run. Going by the logic from the previous paragraph ag.run is first looked inside ag object. And here is your error - its found. As python found ag.run value inside ag object, it never consulted ag type (Activation) for run object and never had a chance to bind it. So ag.run is unbound method and expect self argument as first. You've in general two options. Either do ag.run(ag, 4), which will work, but its ugly, or manually bind method to self in constructor. The latter you can do like this:", "abstract": ""}, {"id": 44741149, "score": 2, "vote": 0, "content": "I think what has confused you here is that you're accessing the method via the class attribute activationFunctions, rather than (as an instance would normally be accessed) on the instance itself. For example, given: When we call the method directly from the dictionary: You can see that we're passing 1 as the self parameter; the method isn't being called on an instance, so no instance is being injected. By contrast, when we call it on an instance: Now our arguments are foo and bar, and the instance is self. That's why you think a different number of parameters seem to be required. In this case, as you don't actually need the instance state in your method, just make it a regular function (note minor revisions for PEP-8 compliance): This is likely less confusing.", "abstract": ""}, {"id": 44741455, "score": 6, "vote": 0, "content": "You're running into one of the more subtle parts of Python's method implementation. It comes down to how the self argument for normal method calls (e.g. some_instance.method()) is bound. It uses the \"descriptor\" protocol, which is not very well documented (at least, it's not made obvious to new Python programmers). A descriptor is an object that has a __get__ method (and optionally __set__ and/or __delete__ method, but I'm only going to talk about __get__ here). When such an object is stored in a class variable, Python will call its __get__ method whenever the corresponding name is looked up on an instance. Note that this special behavior does not happen for descriptor objects stored in instance variables, only those that are class variables. Functions are descriptors. That means that when you save a function as a class variable, its __get__ method will be called when you look it up on an instance. That method will return a \"bound method\" object which will pass along the self argument to the function automatically. If you store a function somewhere other than a top-level class variable (such as in a dictionary or in an instance variable), you won't get this binding behavior, since the descriptor protocol won't be invoked when the object is looked up. This usually means you either need to pass self manually, or you should omit the self argument from the function definition in the first place (in which case I'd suggest moving the function out of the class to make it clear it's not intended to be used as a method). But you can also construct bound methods by hand if you want to. The type is exposed in the types module, as types.MethodType. So you could change your code like this and it should work:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/41817578/basic-method-chaining", "keywords": [], "tags": ["python", "method-chaining"], "question": {"id": 41817578, "title": "Basic method chaining", "content": "I found this method chaining in python, but even with it I couldn't understand method chaining in Python. Here the goals are two: solve the coding problem and understand method chaining (given that I am still not 100% confident with callables). Down to the problem definition. I want a class that has two methods: one sets a parameter of the object = 'line' and the other overwrites to 'bar'. This is what I got so far: Sadly, with this code I can achieve my goal doing this But I would like to obtain the same result by writing this code How do I achieve this? I guess is something wrong in how I defined the __call__ method. Thanks in advance for your help.", "abstract": ""}, "answers": [{"id": 62772515, "score": 0, "vote": 0, "content": "ther's an another interesting way of achieving this with this code u don't have to pass .my_print() but one thing to note here is the Foo class will take anything as argument like if we try print(my_obj.bar.line.bar.bar.circle()) it will return circle. You can also edit this code to take the args while calling any function.", "abstract": ""}, {"id": 41817688, "score": 101, "vote": 0, "content": "Method chaining is simply being able to add .second_func() to whatever .first_func() returns. It is fairly easily implemented by ensuring that all chainable methods return self. (Note that this has nothing to do with __call()__). You can use foo objects in a non-chained way by ignoring their returned values: Or, since every function now returns the object itself, you can operate\ndirectly on the returned value. You can use method chaining with this equivalent code: Or even: The question of getting rid of the () calling syntax is a completely separate concept from method chaining. If you want chain properties, and have those properties mutate their object, use the @property decorator. (But mutating objects via a property seems dangerous. Better to use a method and name it with a verb: .set_line() instead of .line, for example.)", "abstract": ""}, {"id": 41817632, "score": 9, "vote": 0, "content": "Use properties (descriptors).  Note, though, that you overwrite nothing, the modification doesn't work inplace (which is arguably good, btw). Anyway, this doesn't look like a good design choice for most real-world cases, because at some point your methods will require arguments. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/68719172/how-to-define-one-method-as-both-instance-method-and-class-method-sharing-the-s", "keywords": [], "tags": ["python", "oop", "overloading", "class-method", "instance-methods"], "question": {"id": 68719172, "title": "How to define one method as both instance method and class method (sharing the same name), each with different arguments?", "content": "In essence, I'm trying to accomplish the below but where bar and baz have the same handle (e.g. just bar) rather than being two differently-named functions. I'm trying to do this for intelligibility's sake. The real function names are long with many underscores, and making two slightly differently-named functions (e.g. prepending one function name with a _) for every function to which I want to do this is only going to confuse an already complicated situation. The function will mostly be used internally, but I'd like the ability to call the function in a static context with ad hoc parameters that might not necessarily match the instance variables of a given object of MyClass (in fact, I would only call it this way if they didn't match). I'm using @classmethod rather than @staticmethod because the real functions use some internal class variables. I've already tried simply implementing the above with bar for both function names, but as expected, the instance method has been overridden by the class method. I suppose one awkward solution would be to define bar as: and then, if I wanted to call it statically elsewhere, I would need to use: I don't really like this because it requires me to call bar from a specific object of MyClass. This is technically not an issue if I already have an instance of MyClass somewhere, but I want a class method for a reason: bar in this context doesn't depend on any instance variables (though it does on class variables). Another potential solution would be to make a separate class for this function (and others): and to call it within MyClass as Functions.bar(self.arg1, self.arg2) and externally as Functions.bar(arg1, arg2) I'm not super keen on this either since I'm putting bar and similar functions in MyClass for a reason: they're relevant to MyClass conceptually. I saw some answers to similar SO posts that use Descriptors, but I was hoping there might be a more elegant solution. Any wise Python wizards out here have advice?", "abstract": ""}, "answers": [{"id": 68719277, "score": 2, "vote": 0, "content": "You can let self take a default argument as well, so that you can distinguish between mine.bar() and MyClass.bar(). The price is that the other two arguments must be keyword arguments.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66668746/how-does-python-turn-a-function-into-a-method", "keywords": [], "tags": ["python"], "question": {"id": 66668746, "title": "How does Python turn a function into a method?", "content": "I know that functions are just descriptors, like this: I thought at first that c.func equals C.func.__get__(c)\uff0cyes\uff0cC.func.__get__(c) return a bound method. But when I set the __get__ of func to None, c.func still returns a bound method. output: So I'm confused. Moreover, I found that when calling a function from an instance, Python actually calls the class's ___getAttribute__ method, which returns a bound method. output: func.__get__ doesn't seem to have any effect. So, What happended in __getattribute__? How does Python turn a function into a method? I've Googled and done some research, but I still can't find the answer. Maybe I'm making things complicated, In my understanding, function is itself a descriptor, but just like the code below, I set the func to None, it works normally: but if it's a descriptor, it will raise TypeError:", "abstract": ""}, "answers": [{"id": 66693099, "score": -1, "vote": 0, "content": "Well, if I understand correctly from what I found. (Since I didn't know the descriptors, that's exactly why I like to help, still learning) First, let's look at __getattr__ and __getattribute__. Let's have an empty class A If I initialize an object and try to call a property, because there is none at the moment, we get AttributeError. The following occurs:\n Simple check of flow: This is probably understandable, including the use. But to be sure, I'll give an example. This logic is used as a dynamic representation of the result from the databases (mapping of attributes to ordinary dict, list, etc.). But it can also be just logic for accessing an attribute (property), such as an access counter or validation (but this applies to __setattr__ and __setattribute__) And what about descriptors? First let's look at data-descriptors, they are easier for me to understand.\nThis is a class or decoder that has __get__ and one or both of __set__ and __delete__. Once this is defined, python, when used in the property definition with it and then does not return a class but the value it obtains through __get__, does not overwrite an already declared class when declaring a value, but uses its __set__. Example: Demo: Decorator descriptor: And now for non-data descriptors... A non-data descriptor is one that has only __get__.\nAs I understand it, each method automatically has its own descriptor, thanks to which the functions get references to the object - self. We can write our own descriptor for a function / method, but it's not that straightforward, we have to help ourselves and get around it a bit. Source of last code block, but in czech lang. And finally, your mentioned problem, when we set __get__ to None and you still get a reference to the function. It's simple, python doesn't directly distinguish between primitive data types and functions, it's all a variable (or attribute / property) that has a value. Whether it's just value or it's callable is a different matter. Therefore, when we ask for the obj.func method or call it obj.func() directly, the first two changed magic is called first - __getattribute__ and __getattr__.\nAnd if we call a method, it is called only after we get a reference to a function in memory. Again a simple example: Demo: Sources:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64468324/no-value-for-argument-self-when-calling-a-method-in-python", "keywords": [], "tags": ["python", "methods", "self", "method-call"], "question": {"id": 64468324, "title": "No value for argument &#39;self&#39; when calling a method in Python", "content": "I did quite a lot of research both within and outside of stackoverflow. Yes, there are similar topics. But I could not find the answer to my specific problem. Maybe because I can not see the bigger picture yet with my current understanding of Python. In the last line I get the error \"No value for argument 'self' in method call\". How would I have to properly call the method here? Or is it not possible at all to call methods within the same class? It might seem that there would be no reason for this class because I do not need to instantiate it. But I want to use the code of Main() in another class Gui() which is responsible for all the GUI stuff. So the different classes are a way for me to organize the code.\nGood approach or not? Thanks in advance for your help!", "abstract": ""}, "answers": [{"id": 64488468, "score": 0, "vote": 0, "content": "Thanks for all of your comments! I figured something out that works. I hope it makes sense, too. And I fixed my indentations.", "abstract": ""}, {"id": 64469238, "score": 1, "vote": 0, "content": "The problem here is that you are writing your class without a init function and that your class doesn't have self variables. For example: Only works because there is the init function. The reasoning for self variables like self.name is so the values can be edited later, like you tried with Main.bps. If you have self.bps in an init function, it can be edited later within your function, given you also write self.bps in the function. I'm not sure about just using things like bpm on their own in a class rather than self.bps because i'm sure bps would be private within the scope of Main disregarding functions. Also, be sure to check your indentations! :)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/57866318/get-the-name-of-the-current-method-function-in-python", "keywords": [], "tags": ["function", "class", "methods", "python-3.6", "method-names"], "question": {"id": 57866318, "title": "Get the name of the current method/function in Python", "content": "For now, I got two ways to fetch the name of the current function/method in python Function based Class based Any other ways which are more easier and efficient than this?", "abstract": ""}, "answers": [{"id": 57866356, "score": 4, "vote": 0, "content": "I believe that this post answers your problem:\nDetermine function name from within that function (without using traceback) There are no built-in ways to get the function's name. Glancing over your code I believe those are the easiest you will encounter. I may be wrong though, feel free to correct me.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46636190/python-method-vs-function", "keywords": [], "tags": ["python", "function", "class", "methods"], "question": {"id": 46636190, "title": "Python method vs function", "content": "I am seeking for a confirmation if my thinking is correct in terms of Python method vs function: A method is a part of a class. A function is defined outside of a class. so e.g. I understand def foo defines method and def bar defines function. Am I correct?", "abstract": ""}, "answers": [{"id": 46636343, "score": 7, "vote": 0, "content": "Yes. To be clear, methods are functions, they are simply attached to the class, and when that function is called from an instance it gets  that instance passed implicitly as the first argument automagically*. It doesn't actually matter where that function is defined. Consider: *I highly recommend reading the descriptor HOWTO. Spoiler alert, Functions are descriptors. This is how Python magically passes instances to methods (that is, all function objects are descriptors who's __get__ method passes the instance as the first argument to the function itself when accessed by an instance on a class!. The HOWTO shows Python implementations of all of these things, including how you could implement property in pure Python!", "abstract": ""}, {"id": 46636396, "score": 5, "vote": 0, "content": "Actually, methods and functions in Python are exactly the same thing! It matters not one bit where it is defined. What matters is how it is looked up. which gives the output (This will only work in Python 3: Two of these will produce a TypeError in Python 2.) What is important to notice about the output is that, in the first two cases, the functions receive two arguments: 1 and 2. In the last two cases they receive three arguments: instance, 1 and 2. In the cases where instance is passed to the function, the function is behaving like a method. In the cases where instance is not passed in, the function is behaving like a plain function. But notice that both behaviours are exhibited by both the function which was defined inside the classe and the one which was defined outside the class. What matters is how the function was looked up. If it was looked up as an attribute of an instance of a class, then the function behaves like a method; otherwise it behaves like a free function. [Incidentally, this binding behaviour only works for pure Python functions; it does not work for functions defined using the Python/C API. The latter always behave like functions and never like methods: will give you a directory of the global scope, not of instance, indicating that dir recived zero arguments, rather that receiving instance as an argument.\n]", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/35387367/python-method-which-computes-the-result-only-on-the-first-call-without-extra-pa", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 35387367, "title": "Python method which computes the result only on the first call, without extra parameters", "content": "Is there an idiomatic way to implement an \"once method\", that is: a method whose return value gets evaluated on the first call only?  Something like what the following simplified code does for the return value of x:", "abstract": ""}, "answers": [{"id": 35387640, "score": 12, "vote": 0, "content": "As of Python 3.2, you can use the functools.lru_cache decorator (but it may be overkill for what you need): output: Alternatively, you can write your own decorator: And use it on any function you want to run only once and cache the result                ", "abstract": ""}, {"id": 35387624, "score": 1, "vote": 0, "content": "The old-school method is to just have a global that holds the result. If None is a valid result, define an empty class and use that instead", "abstract": ""}, {"id": 35387587, "score": 1, "vote": 0, "content": "Since you tagged this as Python 3.X, you can also use a function annotation as a state flag: For a class, timgeb method works great. ", "abstract": ""}, {"id": 35387411, "score": 8, "vote": 0, "content": "One way is to give the function itself an attribute which will only be True on the first call. Another option is to (ab)use a mutable default parameter. The advantage is that you don't have to set an attribute on the function after defining it: edit: For completeness, if you have instance attributes that should only be computed once, use a property: Demo:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/32129064/what-are-the-parentheses-for-at-the-end-of-python-method-names", "keywords": [], "tags": ["python", "class", "methods", "parentheses"], "question": {"id": 32129064, "title": "What are the parentheses for at the end of Python method names?", "content": "I'm a beginner to Python and programming in general. Right now, I'm having trouble understanding the function of empty parentheses at the end of method names, built-in or user-created. For example, if I write: ...why is there an empty pair of parentheses after \"upper?\" Does it do anything? Is there a situation in which one would put something in there? Thanks!", "abstract": ""}, "answers": [{"id": 32129098, "score": 3, "vote": 0, "content": "upper() is a command asking the upper method to run, while upper is a reference to the method itself.  For example,", "abstract": ""}, {"id": 32129091, "score": 7, "vote": 0, "content": "the parentheses indicate that you want to call the method upper() returns the value of the method applied to the string if you simply say upper, then it returns a method, not the value you get when the method is applied", "abstract": ""}, {"id": 32129077, "score": 16, "vote": 0, "content": "Because without those you are only referencing the method object. With them you tell Python you wanted to call the method. In Python, functions and methods are first-order objects. You can store the method for later use without calling it, for example: Here get_uppercase stores a reference to the bound str.upper method of your string. Only when we then add () after the reference is the method actually called. That the method takes no arguments here makes no difference. You still need to tell Python to do the actual call. The (...) part then, is called a Call expression, listed explicitly as a separate type of expression in the Python documentation: A call calls a callable object (e.g., a function) with a possibly empty series of arguments.", "abstract": ""}]}]