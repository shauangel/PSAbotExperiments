[{"link": "https://stackoverflow.com/questions/66631340/what-is-t-self-in-swift5", "keywords": [], "tags": ["swift"], "question": {"id": 66631340, "title": "What is T.self in Swift5?", "content": "I'm currently going through the Landmarks app tutorial and I'm at the section where you load in JSON into a Struct. They give the following code. Reference: https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation I specifically don't understand the T.self reference nor the <T: Decodable> at the beginning of the func. Would someone be able to break the function down? Thank you.", "abstract": ""}, "answers": [{"id": 75587453, "score": -1, "vote": 0, "content": "you missing var landMarks: [Landmark] = load(\"landmarkData.json\") this code, because the func load(_:)->T return value type is [Landmark] type ,so the T is [Landmark] Array type. this is my understand", "abstract": ""}, {"id": 66632495, "score": 12, "vote": 0, "content": "I see that this question was answered in comments, but I felt it was worth an actual answer for people who are new to Swift trying to understand generics. To answer the question, let's look at what T is, which is defined in the function's signature This says that the generic function load(_:String) -> T returns some type T that conforms to Decodable, so T is a generic way of referring to the type of the return value, where that type will be determined from the context of the call site, specifically, by the type of whatever is receiving the returned value. The line being asked about is Here T.self is a way of referring to the type, T, itself.   If you look at the function signature for decode you'll find it looks something like this: Note that it says T.Type for the type of the parameter, type.  That means that the parameter type will hold the type T rather than a value of type T.  This is Swift's way of differentiating between specifying that a variable is a value of a type vs its value being the type itself.  This can be a little confusing at first, but it makes sense once you get your head around generics. Because Swift is a strongly typed language, where types are defined at compile-time, decode needs to know the type of the thing its attempting to decode.  In a typeless language, like JavaScript or Python, this isn't necessary.  In those languages, objects are basically dictionaries, so it can always decode a dictionary (or an array, or one of a small set of primitive types). In Swift, struct and class are not just syntactic sugar for a dictionary.  They are more like C-style struct - a bundle of binary data with a specific memory layout determined by the type.  In order to decode properly, decode has to know what it's decoding, and most often, how to tell that thing to decode itself via its init(from: Decoder) throws method (which may have been synthesized by the compiler).  Does it call NSImage.init(from: Decoder), or String.init(from: Decoder), etc... ? If you're familiar with the way run-time polymorphism is implemented in OOP, providing the type, even generically, provides a means of obtaining the type's protocol witness table - which is sort of the protocol equivalent of the \"vtable\" that classes use for runtime dynamic dispatch for virtual methods. So it let's it do something analogous to calling a virtual method in OOP, except often it can figure it out at compile-time, and it can work for both value types and reference types.  Understanding how his works also gives some insight into different but related issues like why you get different polymorphic behavior for the required methods declared directly in a protocol than for those declared only in a protocol extension (basically the ones declared in the protocol directly are in the witness table, so they can be dynamically dispatched, whereas the ones only in the extension aren't in the witness table, so any type-specific implementations are lost, and instead only the implementation in the protocol's extension can be called). The following function uses this to print the type of its parameter (there are better ways of doing this, but this illustrates the roles of T.Type and T.self):", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/26835013/what-is-self-used-for-in-swift", "keywords": [], "tags": ["ios", "swift", "self"], "question": {"id": 26835013, "title": "What is &quot;self&quot; used for in Swift?", "content": "I am new to Swift and I'm wondering what self is used for and why. I have seen it in classes and structures but I really don't find them essential nor necessary to even mention them in my code. What are they used for and why? In what situations it's necessary to use it? I have been reading lots of questions and answers for this question but none of them fully answers my questions and they always tend to compare it with this as in Java, with which I'm not familiar whatsoever.", "abstract": ""}, "answers": [{"id": 26836477, "score": 36, "vote": 0, "content": "You will also use self a lot when creating your extensions, example: now let's say you want to change the var result itself\nyou have to use the mutating func to make change itself now let's mutate it // now let's see another example using strings : now let's change myString1", "abstract": ""}, {"id": 73295291, "score": 0, "vote": 0, "content": "I have an elegant case for using self in Swift. I use it in blocks like this: This way, I guarantee that there will be no strong references to self in the block. The syntax is very clear. I use this way to prevent memory leaks.", "abstract": ""}, {"id": 57403014, "score": 4, "vote": 0, "content": "I arrived at this question while searching for self as a class function, which looks like this: Int.self, String.self, or YourClass.self Previously, as near as I can tell, only Dmitri Pavlutin's answer touches on this, when he said: When self is accessed in a type method (static func or class func), it refers to the actual type (rather than an instance). When self is used this way, it actually returns what in Swift is called a Metatype. You can read the Swift documentation page on Types for more information. There is also an article with more details about using and understanding metatypes called \"What's .self, .Type and .Protocol? Understanding Swift Metatypes\" on swiftrocks.com.", "abstract": ""}, {"id": 40583959, "score": 3, "vote": 0, "content": "\"How to use correctly 'self' keyword in Swift\" explains self in detail. self is a property on the instance that refers to itself. It's used to access class, structure and enumeration instance within methods. When self is accessed in a type method like static func or class func, it refers to the actual type rather than an instance. Swift allows omitting self when you want to access instances properties. When a method parameter has the same name as an instance property, you have to explicitly use self.myVariable = myVariable to make a distinction. \nNotice that method parameters have a priority over instance properties.  ", "abstract": ""}, {"id": 26835100, "score": 68, "vote": 0, "content": "Yes it is the same as this in Java and self in Objective-C, but with Swift, self is only required when you call a property or method from a closure or to differentiate property names inside your code, such as initializers. So you can use almost all of your class components safely without using self unless you are making the call from a closure. \u201cThe self Property Every instance of a type has an implicit property\n  called self, which is exactly equivalent to the instance itself. You\n  use the self property to refer to the current instance within its\n  own instance methods. The increment() method in the example above could have been written\n  like this: In practice, you don\u2019t need to write self in your code very often.\n  If you don\u2019t explicitly write self, Swift assumes that you are\n  referring to a property or method of the current instance whenever you\n  use a known property or method name within a method. This assumption\n  is demonstrated by the use of count (rather than self.count)\n  inside the three instance methods for Counter. The main exception to this rule occurs when a parameter name for an\n  instance method has the same name as a property of that instance. In\n  this situation, the parameter name takes precedence, and it becomes\n  necessary to refer to the property in a more qualified way. You use\n  the self property to distinguish between the parameter name and the\n  property name. Here, self disambiguates between a method parameter called x and\n  an instance property that is also called x:\u201d Excerpt From: Apple Inc. \u201cThe Swift Programming Language (Swift 2 Prerelease).\u201d  This is how Ray Wenderlich recommends the use of self in Swift for their tutorials: For conciseness, avoid using self since Swift does not require it to access an object's properties or invoke its methods. Use self when required to differentiate between property names and arguments in initializers, and when referencing properties in closure expressions as required by the compiler: And this is GitHub's recommendations on self for their applications: Only explicitly refer to self when required When accessing properties or methods on self, leave the reference to self implicit by default: Only include the explicit keyword when required by the language \u2014 for example, in a closure, or when parameter names conflict: Rationale: This makes the capturing semantics of self stand out more in closures, and avoids verbosity elsewhere.", "abstract": ""}, {"id": 26836085, "score": 12, "vote": 0, "content": "This is why we need self. When we define a class, like: We are creating a \"Class Object\". Yes, Class is an object too. Then no matter how many instances are created using the class, all instances will have a reference pointer to its Class Object. You can imagine that all instance methods defined by the Class are in the Class Object, and there will be only one copy of them.  That means all instances created using the Class are sharing the same method. Now imagine  you are the myMethod in the Class Object, and because you are shared for all instances, you must have a way to tell which instance you are working on. When someone says instance1.myMethod(), it means \"Hi! myMethod, please do your work and instance1 is the object you are working on\". To reference the object that the caller sent to you, use self. \u201cIn practice, you don\u2019t need to write self in your code very often. If\n  you don\u2019t explicitly write self, Swift assumes that you are referring\n  to a property or method of the current instance whenever you use a\n  known property or method name within a method.\u201d Excerpt From: Apple Inc. \u201cThe Swift Programming Language.\u201d iBooks.\n  https://itun.es/tw/jEUH0.l", "abstract": ""}, {"id": 51185196, "score": 1, "vote": 0, "content": "self is a property on the instance that refers to itself. It's used to access the class, structure and enumeration instance within methods. When a method parameter has the same name as an instance property, you have to explicitly use self.myVariable = myVariable to make a distinction.  Notice that method parameters have a priority over instance properties.", "abstract": ""}, {"id": 38647092, "score": 9, "vote": 0, "content": "The reserved word self in Swift is similar to this but it's not the same as in Java or JavaScript. As @Dave Gomez correctly quoted:  Every instance of a type has an implicit property called self, which is exactly equivalent to the instance itself.  Here lies one of the main differences, because: Here are a few examples:  See : Why 'self.self' compiles and run in swift for more information.", "abstract": ""}, {"id": 61171886, "score": 2, "vote": 0, "content": "I'm a total noob at coding in general - and whilst these answers are great, from the perspective of a total noob who just wants it answered as practically as possible without all these difficult words and concepts, here's my Super Noob dumbed down version:  'self' is used because the coding application doesn't know which variable to use if you type the variable in the scope of your functions. It's all about the scope and making it clear which variable you're using if some other variable has the same name. Scope is the area inside the curly {} brackets. so for example: { scope1 {scope2} } Here you don't need to use self: Here you do need to use self: There's also this situation:", "abstract": ""}, {"id": 26835369, "score": 19, "vote": 0, "content": "In what situations it's necessary to use it It is necessary to use it only when the name of a local variable overshadows the name of a property. However, as a matter of style (and readability), I always use it: I use it with property names, because otherwise I am left wondering what this variable is (since it is neither locally declared nor an incoming parameter). I use it as the receiver of function (method) calls, in order to differentiate such methods from top-level or local functions.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/49737642/what-is-self-in-keras", "keywords": [], "tags": ["python"], "question": {"id": 49737642, "title": "What is &quot;self&quot; in Keras?", "content": "I'm new to machine learning and Python.\nI have been using Keras for a project. \nThe first argument of almost all attributes of Model is self.  For example: Can someone please tell me what this self refers to?", "abstract": ""}, "answers": [{"id": 49737764, "score": 0, "vote": 0, "content": "In a method of Model, self is the particular instance of class Model that you're working with. If a class were a species, an instance (or object) of that class is a particular individual of that species. In a procedural language (like e.g. C), all data is passed to functions as parameters. In a language that supports object orientation (like e.g. Python), functions (methods) are regarded as belonging to certain classes of objects. Rather than passing such an object as an explicit parameter to the function, it is passed \"anonymously\" in self. <object>.<function> (<explicit params>) leads to calling <function> (self = <object>, <explicit params>). In some object oriented languages (like e.g. C++), this self (or, in that case this parameter doesn't even have to be mentioned if the call is made from another method of the same object, but it's there anyhow implicitly.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71580346/what-is-self-and-what-does-it-do-in-lua", "keywords": [], "tags": ["lua", "self"], "question": {"id": 71580346, "title": "What is self and what does it do in lua?", "content": "I'm a new programmer in lua, and there are lots of things I still probably don't know about. I googled what self is in lua, but I still don't understand it. If anyone could give me the easiest explanation for what \"self\" does in lua, it would be really helpful.", "abstract": ""}, "answers": [{"id": 71585049, "score": 13, "vote": 0, "content": "self is just a variable name. It is usually automatically defined by Lua if you use a special syntax. is syntactic sugar for That means Lua will automatically create a first parameter named self. This is used together with a special function call: which is syntactic sugar for That way self usually refers to the table. This is helpful when you do OOP in Lua and need to refer to the object from inside your method. Similar to this in C++.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71320867/what-is-self-in-swift", "keywords": [], "tags": ["ios", "swift", "xcode", "self"], "question": {"id": 71320867, "title": "What is `self` in swift?", "content": "I found this code in one of the old projects: I assume `` was used in older versions of the language. But I would like to know why it is used/was used. Also, I would like to know if there are any problems if do not change the code and \"leave it as is\" in the latest versions of Swift and Xcode. Does it work correctly? Should I replace this with", "abstract": ""}, "answers": [{"id": 71327154, "score": 1, "vote": 0, "content": "self is a keyword and normally you cannot use keywords and reserved words in places outside their context. However, that sometimes creates problems. For that reason there is a special syntax to make the keyword to be a normal identifier, e.g.: (also see Swift variable name with ` (backtick)) Historically self was not allowed as as a constant name inside guard-let-else and therefore backticks were commonly (ab)used.\nThey are no longer needed since Swift 4.2. The code will still work correctly since you can wrap any identifier in backticks and it will just be a normal identifier.", "abstract": ""}, {"id": 71320979, "score": 1, "vote": 0, "content": "The Xcode IDE suggestion you using `` to help to use the same default key in Foundation SDK. Example: default is a constant name in Foundation, if you want using default to create new variable name is default you need add ``. But you using SwiftLint with default rules, Using a default contants name is a code smell.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/68140768/whatt-the-meaning-of-self-object-in-python", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 68140768, "title": "What&#39;t the meaning of self.object in python?", "content": "I am learning Object-oriented programming and I am having trouble with the parameter of \"self\". Here is my code for analysing text. I just learned that self refers to instance of the class. However, I can't understand the meaning of self.fmtText and self.freqAll(). Can anyone give me a specific explanation, please?  Thanks in advance!", "abstract": ""}, "answers": [{"id": 68140811, "score": 1, "vote": 0, "content": "self represents the instance of the class. By using the \u201cself\u201d keyword we can access the attributes and methods of the class in python. It binds the attributes with the given arguments. self.fmtText is used to access the class variable and self.freqAll() calls the instance method freqAll().", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65978620/tcloo-what-is-the-difference-between-my-and-self", "keywords": [], "tags": ["tcl"], "question": {"id": 65978620, "title": "TclOO : What is the difference between my and self?", "content": "The documentation probably explains it very well but I do not see the difference between this 2 commands in my case : The only difference I can see is that with [self] I can pass it as an argument in a procedure and not with my. \nWhat is the best solution in my case ? \nBoth solutions have equal performance ?", "abstract": ""}, "answers": [{"id": 65992017, "score": 1, "vote": 0, "content": "The self command (with no extra arguments) is equivalent to self object which returns the current public name of the object that is executing the method (you can rename the object). The self command overall provides access to bits of \u201cruntime\u201d state. The my command is actually the object's internal name; it's created in each object's instance namespace. You can invoke all exported and non-exported methods via my, unlike with the public name. This makes it useful for both calling your internal methods directly, and also for setting up things like callbacks to internal methods (you'll need something like namespace which or namespace code when setting up the callback). Unlike with the public name, you can delete the internal name command without automatically destroying the object. It'll likely break code (your methods most probably) if you do that, but the base system allows you to do it. Aside: Tcl 8.7 includes this helper procedure (which also works in 8.6) for creating callback scripts within methods (the funny name means it gets mapped into your methods automatically as callback): In this case, if the callback was exported, you'd be able to do this instead: but that would be more vulnerable to rename problems. (In all cases, the uplevel 1 is because we want to run a little bit of name-resolving code in the calling context, not inside the scope of the procedure itself.)", "abstract": ""}, {"id": 65980428, "score": 1, "vote": 0, "content": "I'm not sure how they are implemented, but one reason you'd want to use my is to access non-exported (private) methods. A demo: then: my is the mechanism for an object to invoke its methods.\nself is the mechanism for introspection on how the current method was called. Spend some time with the my and self man pages.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65184615/what-is-the-use-of-the-keyword-self-in-python-object-oriented-programming", "keywords": [], "tags": ["python", "class", "self"], "question": {"id": 65184615, "title": "What is the use of the keyword &quot;self&quot; in Python Object Oriented Programming?", "content": "I just started learning Python, and I'm starting to get into Object-Oriented Programming. I wrote the following code which simply draws shapes using the turtle module, but I still don't quite understand the use of the \"self\" keyword:", "abstract": ""}, "answers": [{"id": 65184652, "score": 1, "vote": 0, "content": "self refers to the instance of the class from inside the class.\nhttps://www.programiz.com/article/python-self-why Here is the content of the link: If you have been programming in Python (object-oriented programming) for some time, then you have definitely come across methods that have self as their first parameter. Let us first try to understand what this recurring self parameter is.\nWhat is self in Python? In object-oriented programming, whenever we define methods for a class, we use self as the first parameter in each case. Let's look at the definition of a class called Cat. In this case all the methods, including init, have the first parameter as self. We know that class is a blueprint for the objects. This blueprint can be used to create multiple numbers of objects. Let's create two different objects from the above class. The self keyword is used to represent an instance (object) of the given class. In this case, the two Cat objects cat1 and cat2 have their own name and age attributes. If there was no self argument, the same class couldn't hold the information for both these objects. However, since the class is just a blueprint, self allows access to the attributes and methods of each object in python. This allows each object to have its own attributes and methods. Thus, even long before creating these objects, we reference the objects as self while defining the class.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/54555141/what-is-self-in-python", "keywords": [], "tags": ["python", "self"], "question": {"id": 54555141, "title": "What is self() in python?", "content": "I thought I understood self on some pretty decent level. But I came across this: What does self(...) do?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/39192798/what-does-self-mean-in-a-method", "keywords": [], "tags": ["python", "python-2.7", "python-3.x"], "question": {"id": 39192798, "title": "What does self[] mean in a method?", "content": "When reading a python program, I once find a function uses self in the following way.  The line of name_b_out = self._biases_str.format(i + 1) + \"_out\"  looks usual to me, i.e., we always self. to define something. But I am not very clear about the usage of self[self._biases_str.format(n) + suffix]. In specifc, what does self[] mean here, or what does it do?", "abstract": ""}, "answers": [{"id": 39192852, "score": 10, "vote": 0, "content": "It doesn't mean anything other than what variable[something] would mean. In Python variable[something] in an expression will just call variable.__getitem__(something), and self is the name conventionally used for the current object, or the receiver, in Python, so self[self._biases_str.format(n) + suffix] would mean pretty much the same as self.__getitem__(self._biases_str.format(n) + suffix) I guess there is a method __getitem__ defined for that class as well.", "abstract": ""}]}]