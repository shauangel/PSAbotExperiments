[{"link": "https://stackoverflow.com/questions/509211/understanding-slicing", "keywords": [], "tags": ["python", "slice", "sequence"], "question": {"id": 509211, "title": "Understanding slicing", "content": "How does Python's slice notation work? That is: when I write code like a[x:y:z], a[:], a[::2] etc., how can I understand which elements end up in the slice? Please include references where appropriate. See Why are slice and range upper-bound exclusive? for more discussion of the design decisions behind the notation. See Pythonic way to return list of every nth item in a larger list for the most common practical usage of slicing (and other ways to solve the problem): getting every Nth element of a list. Please use that question instead as a duplicate target where appropriate. For more specific answers about slice assignment, see How does assignment work with list slices? (although this is also addressed here).", "abstract": ""}, "answers": [{"id": 75061865, "score": 2, "vote": 0, "content": "For simple way and simple understandable: In Python, the slice notation a[start:stop:step] can be used to select a range of elements from a sequence (such as a list, tuple, or string). The start index is the first element that is included in the slice, The stop index is the first element that is excluded from the slice, and last one The step value is the number of indices between slice elements. For example, consider the following list: If we want to select all elements of a, we can use the slice notation a[:]: If we want to select all elements of a, but skip every other element, we can use the slice notation a[::2]: If we want to select all elements from the third element (index 2) to the seventh element (index 6), we can use the slice notation a[2:7]: If we want to select all elements from the third element (index 2) to the seventh element (index 6), but skip every other element, we can use the slice notation a[2:7:2]: If we want to select all elements from the third element (index 2) to the end of the list, we can use the slice notation a[2:]: If we want to select all elements from the beginning of the list to the seventh element (index 6), we can use the slice notation a[:7]: If you want to learn more about slice notation, you can refer to the official Python documentation:\nLink 1 Link 2", "abstract": ""}, {"id": 74979870, "score": 1, "vote": 0, "content": "You can use slice syntax to return a sequence of characters. Specify a start and end index, separated by colons, to return part of the string. Example: Get the characters from position 2 to position 5 (not included): Slice From the Start By omitting the starting index, the range will start from the first character: Example: Get the characters from the start to position 5 (not included): Slice To the End By omitting the end index, the range will end: Example: Get the characters from position 2, and all the way to the end: Negative Indexing Use a negative index to start slicing from the end of the string:\nexample. Get the characters: From: \"o\" in \"World!\" (position -5) To, but not included: \"d\" in \"World!\" (position -2):", "abstract": ""}, {"id": 509377, "score": 523, "vote": 0, "content": "Enumerating the possibilities allowed by the grammar for the sequence x: Of course, if (high-low)%stride != 0, then the end point will be a little lower than high-1. If stride is negative, the ordering is changed a bit since we're counting down: Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.", "abstract": ""}, {"id": 73011643, "score": -4, "vote": 0, "content": "Here's a simple mnemonic for remembering how it works: So array[j:k] will include the jth element and exclude the kth element.", "abstract": ""}, {"id": 72372369, "score": 1, "vote": 0, "content": "Lots of answers already, but I wanted to add a performance comparison So, if you are using the same slice repeatedly, it would be beneficial and improve readability to use a slice object. However, if you are slicing only a handful of times, [:] notation should be preferred.", "abstract": ""}, {"id": 509295, "score": 6318, "vote": 0, "content": "The syntax is: There is also the step value, which can be used with any of the above: The key point to remember is that the :stop value represents the first value that is not in the selected slice. So, the difference between stop and start is the number of elements selected (if step is 1, the default). The other feature is that start or stop may be a negative number, which means it counts from the end of the array instead of the beginning. So: Similarly, step may be a negative number: Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen. A slice object can represent a slicing operation, i.e.: is equivalent to: Slice objects also behave slightly differently depending on the number of arguments, similarly to range(), i.e. both slice(stop) and slice(start, stop[, step]) are supported.\nTo skip specifying a given argument, one might use None, so that e.g. a[start:] is equivalent to a[slice(start, None)] or a[::-1] is equivalent to a[slice(None, None, -1)]. While the :-based notation is very helpful for simple slicing, the explicit use of slice() objects simplifies the programmatic generation of slicing.", "abstract": ""}, {"id": 24713353, "score": 288, "vote": 0, "content": "In short, the colons (:) in subscript notation (subscriptable[subscriptarg]) make slice notation, which has the optional arguments start, stop, and step: Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with. To begin with, let's define a few terms: start: the beginning index of the slice, it will include the element at this index unless it is the same as stop, defaults to 0, i.e. the first index. If it's negative, it means to start n items from the end. stop: the ending index of the slice, it does not include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end. step: the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse. You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the start and stop, and for the step, you simply decrement your index. This example is from the documentation's tutorial, but I've modified it slightly to indicate which item in a sequence each index references: To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually implement the __getitem__ method of the sequence, according to the Python data model.) Slice notation works like this: And recall that there are defaults for start, stop, and step, so to access the defaults, simply leave out the argument. Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this: When I see this, I read the part in the brackets as \"9th from the end, to the end.\" (Actually, I abbreviate it mentally as \"-9, on\") The full notation is and to substitute the defaults (actually when step is negative, stop's default is -len(my_list) - 1, so None for stop really just means it goes to whichever end step takes it to): The colon, :,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is And clearing them is with: (Python 3 gets a list.copy and list.clear method.) By default, when the step argument is empty (or None), it is assigned to +1. But you can pass in a negative integer, and the list (or most other standard sliceables) will be sliced from the end to the beginning. Thus a negative slice will change the defaults for start and stop! I like to encourage users to read the source as well as the documentation. The source code for slice objects and this logic is found here. First we determine if step is negative: If so, the lower bound is -1  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this -1 is different from a -1 that users may pass indexes in Python indicating the last item.) Otherwise step is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list. Then, we may need to apply the defaults for start and stop\u2014the default then for start is calculated as the upper bound when step is negative: and stop, the lower bound: You may find it useful to separate forming the slice from passing it to the list.__getitem__ method (that's what the square brackets do). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing. However, you can't just assign some integers separated by colons to a variable. You need to use the slice object: The second argument, None, is required, so that the first argument is interpreted as the start argument otherwise it would be the stop argument. You can then pass the slice object to your sequence: It's interesting that ranges also take slices: Since slices of Python lists create new objects in memory, another important function to be aware of is itertools.islice. Typically you'll want to iterate over a slice, not just have it created statically in memory. islice is perfect for this. A caveat, it doesn't support negative arguments to start, stop, or step, so if that's an issue you may need to calculate indices or reverse the iterable in advance. and now: The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.", "abstract": ""}, {"id": 51479594, "score": 7, "vote": 0, "content": "The basic slicing technique is to define the starting point, the stopping point, and the step size\u2014also known as stride. First, we will create a list of values to use in our slicing. Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B): Index the number 3 from A and the number 6 from B. Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to None\u2014the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element. It is important to note, the first element is index 0, not index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element, 0, etc.). With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon. To retrieve a subset of elements, the start and stop positions need to be defined. Given the pattern aList[start:stop], retrieve the first two elements from List A.", "abstract": ""}, {"id": 71640042, "score": 1, "vote": 0, "content": "The important idea to remember about indices of a sequence is that In other words, negative indices are shifted right by the length of the sequence: With that in mind, subscription and slicing are straightforward. Subscription uses the following syntax:* Subscription selects a single item in the sequence at index: Subscription raises an IndexError for an index that is out of range: Slicing uses the following syntax:** Slicing selects a range of items in the sequence, beginning at start inclusive and ending at stop exclusive: Slicing defaults to the fullest range of items in the sequence, so it uses the following default values for any start, stop, or step that is omitted or equal to None:*** Slicing raises a ValueError for a step that is equal to zero: Slicing does not raise an IndexError for a start or stop that is out of range (contrary to subscription): * The expressions sequence[index] and sequence.__getitem__(index) are equivalent. ** The expressions sequence[start:stop:step], sequence[slice(start, stop, step)], and sequence.__getitem__(slice(start, stop, step)) are equivalent, where the built-in class slice instance packs start, stop, and step. *** The expressions sequence[:], sequence[::], and sequence[None:None:None] use default values for start, stop, and step.", "abstract": ""}, {"id": 56591541, "score": 3, "vote": 0, "content": "I got a little frustrated in not finding an online source, or Python documentation that describes precisely what slicing does. I took Aaron Hall's suggestion, read the relevant parts of the CPython source code, and wrote some Python code that performs slicing similarly to how it's done in CPython. I've tested my code in Python 3 on millions of random tests on integer lists. You may find the references in my code to the relevant functions in CPython helpful.", "abstract": ""}, {"id": 63047385, "score": 20, "vote": 0, "content": "I- Convert upper bound  and lower bound into common signs. II- Then check if the step size is a positive or a negative value. (i) If the step size is a positive value, upper bound should be greater than lower bound, otherwise empty string is printed. For example: The output: However if we run the following code: It will return an empty string. (ii) If the step size if a negative value, upper bound should be lesser than lower bound, otherwise empty string will be printed. For example: The output: But if we run the following code: The output will be an empty string. Thus in the code: In the first str2=str[l-1:0:-1], the upper bound is lesser than the lower bound, thus dcb is printed. However in str2=str[l-1:-1:-1], the upper bound is not less than the lower bound (upon converting lower bound into negative value which is -1: since index of last element is -1 as well as 3).", "abstract": ""}, {"id": 57628026, "score": 18, "vote": 0, "content": "I personally think about it like a for loop: Also, note that negative values for start and end are relative to the end of the list and computed in the example above by given_index + a.shape[0].", "abstract": ""}, {"id": 47765245, "score": 18, "vote": 0, "content": "In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on). Let's work with the following string ... For those who don't know, you can create any substring from azString using the notation azString[x:y] Coming from other programming languages, that's when the common sense gets compromised. What are x and y? I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt. My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as azString[index1, index2] or even more clearer as azString[index_of_first_character, index_after_the_last_character]. Here is an example visualization of that ... So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring \"cdefgh\", you can use azString[2:8], because the index on the left side of \"c\" is 2 and the one on the right size of \"h\" is 8. Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ... a b [ c d e f g h ] i j That trick works all the time and is easy to memorize.", "abstract": ""}, {"id": 49647978, "score": 12, "vote": 0, "content": "I want to add one Hello, World! example that explains the basics of slices for the very beginners. It helped me a lot. Let's have a list with six values ['P', 'Y', 'T', 'H', 'O', 'N']: Now the simplest slices of that list are its sublists. The notation is [<index>:<index>] and the key is to read it like this: Now if you make a slice [2:5] of the list above, this will happen: You made a cut before the element with index 2 and another cut before the element with index 5. So the result will be a slice between those two cuts, a list ['T', 'H', 'O'].", "abstract": ""}, {"id": 47880987, "score": 8, "vote": 0, "content": "If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with len - index. So for example, replace -3 with len(list) - 3. The best way to illustrate what slicing does internally is just show it in code that implements this operation:", "abstract": ""}, {"id": 46614773, "score": 11, "vote": 0, "content": "Most of the previous answers clears up questions about slice notation. The extended indexing syntax used for slicing is aList[start:stop:step], and basic examples are: : More slicing examples: 15 Extended Slices", "abstract": ""}, {"id": 46040689, "score": 13, "vote": 0, "content": "In Python, the most basic form for slicing is the following: where l is some collection, start is an inclusive index, and end is an exclusive index. When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose: Negative integers are useful when doing offsets relative to the end of a collection: It is possible to provide indices that are out of bounds when slicing such as: Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values: If you omit the start and end index, you will make a copy of the collection: If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced: Besides basic slicing, it is also possible to apply the following notation: where l is a collection, start is an inclusive index, end is an exclusive index, and step is a stride that can be used to take every nth item in l. Using step provides a useful trick to reverse a collection in Python: It is also possible to use negative integers for step as the following example: However, using a negative value for step could become very confusing. Moreover, in order to be Pythonic, you should avoid using start, end, and step in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).", "abstract": ""}, {"id": 45370737, "score": 9, "vote": 0, "content": "The below is the example of an index of a string: Slicing example: [start:end:step] Below is the example usage:", "abstract": ""}, {"id": 42522149, "score": 29, "vote": 0, "content": "The previous answers don't discuss multi-dimensional array slicing which is possible using the famous NumPy package: Slicing can also be applied to multi-dimensional arrays. The \":2\" before the comma operates on the first dimension and the \"0:3:2\" after the comma operates on the second dimension.", "abstract": ""}, {"id": 41548529, "score": 31, "vote": 0, "content": "To make it simple, remember slice has only one form\uff1a and here is how it works: Another import thing: all start,end, step can be omitted! And if they are omitted, their default value will be used: 0,len(s),1 accordingly. So possible variations are: NOTE: If start >= end (considering only when step>0), Python will return a empty slice []. The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them. The very first thing that confuses Python learners is that an index can be negative!\nDon't panic: a negative index means count backwards. For example: Making things more confusing is that step can be negative too! A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result. NOTE: when step is negative, the default value for start is len(s) (while end does not equal to 0, because s[::-1] contains s[0]). For example: Be surprised: slice does not raise an IndexError when the index is out of range! If the index is out of range, Python will try its best to set the index to 0 or len(s) according to the situation. For example: Let's finish this answer with examples, explaining everything we have discussed:", "abstract": ""}, {"id": 29237560, "score": 39, "vote": 0, "content": "This is how I teach slices to newbies: Understanding the difference between indexing and slicing: Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.  It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it. Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time. Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box. You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions. The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like. Slicing With Step: Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa. How Python Figures Out Missing Parameters: When slicing, if you leave out any parameter, Python tries to figure it out automatically. If you check the source code of CPython, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python. This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice. This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters. Note: This post was originally written in my blog, The Intelligence Behind Python Slices.", "abstract": ""}, {"id": 56332104, "score": 7, "vote": 0, "content": "I don't think that the Python tutorial diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride. This is the diagram: From the diagram, I expect a[-4,-6,-1] to be yP but it is ty. What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride. This way, I can think of a[-4:-6:-1] as a(-6,-4] in interval terminology.", "abstract": ""}, {"id": 9827284, "score": 33, "vote": 0, "content": "This is just for some extra info...\nConsider the list below  Few other tricks for reversing the list:", "abstract": ""}, {"id": 9923354, "score": 54, "vote": 0, "content": "I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination. It's instructive to understand range() first: Begin from start, increment by step, do not reach stop.  Very simple. The thing to remember about negative step is that stop is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. 'abcde'[1:-2][::-1] slices off one char from left, two from right, then reverses. (See also reversed().) Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence: TODO: The code below had a bug with \"never go outside the sequence\" when abs(step)>1; I think I patched it to be correct, but it's hard to understand. Don't worry about the is None details - just remember that omitting start and/or stop always does the right thing to give you the whole sequence. Normalizing negative indexes first allows start and/or stop to be counted from the end independently: 'abcde'[1:-2] == 'abcde'[1:3] == 'bc' despite range(1,-2) == [].\nThe normalization is sometimes thought of as \"modulo the length\", but note it adds the length just once: e.g. 'abcde'[-53:42] is just the whole string.", "abstract": ""}, {"id": 4729334, "score": 433, "vote": 0, "content": "The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art: One heuristic is, for a slice from zero to n, think: \"zero is the beginning, start at the beginning and take n items in a list\". Another heuristic is, \"for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning\" The first rule of slice assignment is that since slicing returns a list, slice assignment requires a list (or other iterable): The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment: The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned: The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around indexing an empty slice: And then once you've seen that, slice assignment to the empty slice makes sense too: Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments. Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning? With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number. There are some weird consequences to the \"once you're done, you're done\" rule: In fact, compared to indexing, Python slicing is bizarrely error-proof: This can come in handy sometimes, but it can also lead to somewhat strange behavior: Depending on your application, that might... or might not... be what you were hoping for there! Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it. This may also clarify the difference between slicing and indexing.", "abstract": ""}, {"id": 567094, "score": 70, "vote": 0, "content": "After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a for loop... Any of them are optional: Then the negative indexing just needs you to add the length of the string to the negative indices to understand it. This works for me anyway...", "abstract": ""}, {"id": 53953716, "score": 2, "vote": 0, "content": "It is easy to understand if we could relate slicing to range, which gives the indexes. We can categorize slicing into the following two categories: Suppose the sequence is s=[1,2,3,4,5]. For example, [0:3:2] -> range(0,3,2) -> 0, 2 For example, [0:100:2] -> range(0,len(s),2) -> range(0,5,2) -> 0, 2, 4 For example, [0:-3:2] -> range(0,len(s)-3,2) -> range(0,2,2) -> 0 For another example, [0:-1:2] -> range(0,len(s)-1,2) -> range(0,4,2) -> 0, 2 For example, [:4:2] -> range(0,4,2) -> range(0,4,2) -> 0, 2 For example, [0::2] -> range(0,len(s),2) -> range(0,5,2) -> 0, 2, 4 Suppose the sequence is s=[1,2,3,4,5]. For example, [5:0:-2] -> range(5,0,-2) -> 5, 3, 1 For example, [100:0:-2] -> range(len(s)-1,0,-2) -> range(4,0,-2) -> 4, 2 For example, [-2:-10:-2] -> range(len(s)-2,-1,-2) -> range(3,-1,-2) -> 3, 1 For example, [:0:-2] -> range(len(s)-1,0,-2) -> range(4,0,-2) -> 4, 2 For example, [2::-2] -> range(2,-1,-2) -> 2, 0 For another example, [::-1] -> range(len(s)-1,-1,-1) -> range(4,-1,-1) -> 4, 3, 2, 1, 0 ", "abstract": ""}, {"id": 509297, "score": 680, "vote": 0, "content": "The Python tutorial talks about it (scroll down a bit until you get to the part about slicing). The ASCII art diagram is helpful too for remembering how slices work: One way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of n characters has index n.", "abstract": ""}, {"id": 13005464, "score": 111, "vote": 0, "content": "In Python 2.7 Slicing in Python Understanding index assignment is very important. When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range: But this range continues in both directions infinitely: For example: If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list. One last thing: if a and b are equal, then also you get an empty list:", "abstract": ""}, {"id": 14682039, "score": 43, "vote": 0, "content": "I hope this will help you to model the list in Python. Reference: http://wiki.python.org/moin/MovingToPythonFromOtherLanguages", "abstract": ""}, {"id": 37455246, "score": 14, "vote": 0, "content": "My brain seems happy to accept that lst[start:end] contains the start-th item. I might even say that it is a 'natural assumption'. But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the end-th element. In these moments I rely on this simple theorem: This pretty property tells me that lst[start:end] does not contain the end-th item because it is in lst[end:]. Note that this theorem is true for any n at all. For example, you can check that returns True.", "abstract": ""}, {"id": 26442691, "score": 17, "vote": 0, "content": "You can run this script and experiment with it, below is some samples that I got from the script. When using a negative step, notice that the answer is shifted to the right by 1.", "abstract": ""}, {"id": 20443928, "score": 29, "vote": 0, "content": "As a general rule, writing code with a lot of hardcoded index values leads to a readability\nand maintenance mess. For example, if you come back to the code a year later, you\u2019ll\nlook at it and wonder what you were thinking when you wrote it. The solution shown\nis simply a way of more clearly stating what your code is actually doing.\nIn general, the built-in slice() creates a slice object that can be used anywhere a slice\nis allowed. For example: If you have a slice instance s, you can get more information about it by looking at its\ns.start, s.stop, and s.step attributes, respectively. For example:", "abstract": ""}, {"id": 16267103, "score": 38, "vote": 0, "content": "Python slicing notation: The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use: Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use deepcopy().", "abstract": ""}, {"id": 15824717, "score": 34, "vote": 0, "content": "You can also use slice assignment to remove one or more elements from a list:", "abstract": ""}, {"id": 7315935, "score": 101, "vote": 0, "content": "Found this great table at http://wiki.python.org/moin/MovingToPythonFromOtherLanguages", "abstract": ""}, {"id": 522212, "score": 44, "vote": 0, "content": "I use the \"an index points between elements\" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this: X is the index of the first element you want.\nY is the index of the first element you don't want.", "abstract": ""}, {"id": 509415, "score": 158, "vote": 0, "content": "And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax: Easy way to reverse sequences! And if you wanted, for some reason, every second item in the reversed sequence:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1514553/how-do-i-declare-an-array-in-python", "keywords": [], "tags": ["python", "arrays", "list"], "question": {"id": 1514553, "title": "How do I declare an array in Python?", "content": "How do I declare an array in Python?", "abstract": ""}, "answers": [{"id": 6768818, "score": 26, "vote": 0, "content": "For calculations, use numpy arrays like this: these numpy arrays can be saved and loaded from disk (even compressed) and complex calculations with large amounts of elements are C-like fast. Much used in scientific environments. See here for more.", "abstract": ""}, {"id": 1515282, "score": 7, "vote": 0, "content": "Following on from Lennart, there's also numpy which implements homogeneous multi-dimensional arrays.", "abstract": ""}, {"id": 70124255, "score": 2, "vote": 0, "content": "You can read and write to any element in this list with a[n] notation in the same as you would with an array. It does seem to have the same random access performance as an array. I cannot say how it allocates memory because it also supports a mix of different types including strings and objects if you need it to.", "abstract": ""}, {"id": 39003823, "score": 22, "vote": 0, "content": "A couple of contributions suggested that arrays in python are represented by lists. This is incorrect. Python has an independent implementation of array() in the standard library module array  \"array.array()\" hence it is incorrect to confuse the two. Lists are lists in python so be careful with the nomenclature used.  There is one very important difference between list and array.array().  While both of these objects are ordered sequences, array.array() is an ordered homogeneous sequences whereas a list is a non-homogeneous sequence. ", "abstract": ""}, {"id": 49868020, "score": 3, "vote": 0, "content": "You can create lists and convert them into arrays or you can create array using numpy module. Below are few examples to illustrate the same. Numpy also makes it easier to work with multi-dimensional arrays. You can also reshape this array into a 2X2 matrix using reshape function which takes in input as the dimensions of the matrix.", "abstract": ""}, {"id": 48014491, "score": 25, "vote": 0, "content": "JohnMachin's comment should be the real answer.\nAll the other answers are just workarounds in my opinion!\nSo:", "abstract": ""}, {"id": 38303109, "score": 12, "vote": 0, "content": "To add to Lennart's answer, an array may be created like this: where values can take the form of a tuple, list, or np.array, but not array: and the output will still be the same: Most methods for list work with array as well, common\nones being pop(), extend(), and append(). Judging from the answers and comments, it appears that the array\ndata structure isn't that popular. I like it though, the same\nway as one might prefer a tuple over a list. The array structure has stricter rules than a list or np.array, and this can\nreduce errors and make debugging easier, especially when working with numerical\ndata. Attempts to insert/append a float to an int array will throw a TypeError: Keeping values which are meant to be integers (e.g. list of indices) in the array\nform may therefore prevent a \"TypeError: list indices must be integers, not float\", since arrays can be iterated over, similar to np.array and lists: Annoyingly, appending an int to a float array will cause the int to become a float, without throwing an exception. np.array retain the same data type for its entries too, but instead of giving an error it will change its data type to fit new entries (usually to double or str): This is true during assignment as well. If the data type is specified, np.array will, wherever possible, transform the entries to that data type: or, in essence: while array will simply give: Because of this, it is not a good idea to use np.array for type-specific commands. The array structure is useful here. list preserves the data type of the values. And for something I find rather pesky: the data type is specified as the first argument in array(), but (usually) the second in np.array(). :| The relation to C is referred to here:\nPython List vs. Array - when to use? Have fun exploring! Note: The typed and rather strict nature of array leans more towards C rather than Python, and by design Python does not have many type-specific constraints in its functions. Its unpopularity also creates a positive feedback in collaborative work, and replacing it mostly involves an additional [int(x) for x in file]. It is therefore entirely viable and reasonable to ignore the existence of array. It shouldn't hinder most of us in any way. :D", "abstract": ""}, {"id": 1514557, "score": 410, "vote": 0, "content": "Now variable refers to an empty list*. Of course this is an assignment, not a declaration. There's no way to say in Python \"this variable should never refer to anything other than a list\", since Python is dynamically typed. *The default built-in Python type is called a list, not an array. It is an ordered container of arbitrary length that can hold a heterogenous collection of objects (their types do not matter and can be freely mixed). This should not be confused with the array module, which offers a type closer to the C array type; the contents must be homogenous (all of the same type), but the length is still dynamic.", "abstract": ""}, {"id": 36042565, "score": 187, "vote": 0, "content": "This is surprisingly complex topic in Python.  Arrays are represented by class list (see reference and do not mix them with generators). Check out usage examples: Under the hood Python's list is a wrapper for a real array which contains references to items. Also, underlying array is created with some extra space. Consequences of this are: Check this awesome table of operations complexity. Also, please see this picture, where I've tried to show most important differences between array, array of references and linked list:\n", "abstract": ""}, {"id": 13300517, "score": 8, "vote": 0, "content": "How about this...", "abstract": ""}, {"id": 21780274, "score": 4, "vote": 0, "content": "I had an array of strings and needed an array of the same length of booleans initiated to True. This is what I did", "abstract": ""}, {"id": 15822462, "score": 6, "vote": 0, "content": "Python calls them lists. You can write a list literal with square brackets and commas:", "abstract": ""}, {"id": 1514559, "score": 38, "vote": 0, "content": "This is how:", "abstract": ""}, {"id": 1514561, "score": 16, "vote": 0, "content": "You don't declare anything in Python. You just use it. I recommend you start out with something like http://diveintopython.net.", "abstract": ""}, {"id": 4476624, "score": 67, "vote": 0, "content": "I think you (meant)want an list with the first 30 cells already filled.\nSo An example to where this could be used is in Fibonacci sequence.\nSee problem 2 in Project Euler", "abstract": ""}, {"id": 1514649, "score": 137, "vote": 0, "content": "You don't actually declare things, but this is how you create an array in Python: For more info see the array module: http://docs.python.org/library/array.html Now possible you don't want an array, but a list, but others have answered that already. :)", "abstract": ""}, {"id": 1514564, "score": 13, "vote": 0, "content": "I would normally just do a = [1,2,3] which is actually a list but for arrays look at this formal definition", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/10487278/how-to-declare-and-add-items-to-an-array-in-python", "keywords": [], "tags": ["python", "arrays"], "question": {"id": 10487278, "title": "How to declare and add items to an array in Python?", "content": "I'm trying to add items to an array in python. I run  Then, I try to add something to this array by doing: There doesn't seem to be a .append method for this.  How do I add items to an array?", "abstract": ""}, "answers": [{"id": 74075799, "score": 0, "vote": 0, "content": "Isn't it a good idea to learn how to create an array in the most performant way? It's really simple to create and insert an values into an array: But, now we have two ways to insert one more value into this array: Slow mode: my_array.insert(0,\"A\") - moves all values \u200b\u200bto the right when entering an \"A\" in the zero position: Fast mode: my_array.append(\"A\") Adds the value \"A\" to the last position of the array, without touching the other positions: If you need to display the sorted data, do so later when necessary. Use the way that is most useful to you, but it is interesting to understand the performance of each method.", "abstract": ""}, {"id": 10487291, "score": 62, "vote": 0, "content": "If you do it this way: you are making a dictionary, not an array. If you need an array (which is called a list in python ) you declare it like this: Then you can add items like this:", "abstract": ""}, {"id": 53665125, "score": 2, "vote": 0, "content": "You can also do: Note that the numpy.append() method returns a new object, so if you want to modify your initial array, you have to write: array = ...", "abstract": ""}, {"id": 52318103, "score": 16, "vote": 0, "content": "Just for sake of completion, you can also do this: If it's a list of strings, this will also work:", "abstract": ""}, {"id": 51612333, "score": -2, "vote": 0, "content": "I believe you are all wrong. you need to do:  array = array[] in order to define it, and then:  array.append [\"hello\"] to add to it.", "abstract": ""}, {"id": 51117606, "score": 3, "vote": 0, "content": "In some languages like JAVA you define an array using curly braces as following but in python it has a different meaning: Java: However, in Python, curly braces are used to define dictionaries, which needs a key:value assignment as {'a':1, 'b':2} To actually define an array (which is actually called list in python) you can do: Python: or other examples like:", "abstract": ""}, {"id": 10487303, "score": 833, "vote": 0, "content": "{} represents an empty dictionary, not an array/list.  For lists or arrays, you need []. To initialize an empty list do this: or To add elements to the list, use append To extend the list to include the elements from another list use extend To remove an element from a list use remove Dictionaries represent a collection of key/value pairs also known as an associative array or a map.  To initialize an empty dictionary use {} or dict() Dictionaries have keys and values To extend a dictionary with the contents of another dictionary you may use the update method To remove a value from a dictionary", "abstract": ""}, {"id": 10487306, "score": 19, "vote": 0, "content": "Arrays (called list in python) use the [] notation. {} is for dict (also called hash tables, associated arrays, etc in other languages) so you won't have 'append' for a dict.  If you actually want an array (list), use:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/53211114/what-does-python-array-module-do-and-why-should-i-use-it-instead-of-a-list", "keywords": [], "tags": ["python", "arrays"], "question": {"id": 53211114, "title": "what does python &quot;array&quot; module do and why should i use it instead of a list?", "content": "I have recently stumbled across the \"array\" module in python. i saw it used something like this:  what does line 2 do? why should i use \"array\" instead of a simple list?", "abstract": ""}, "answers": [{"id": 72477228, "score": 0, "vote": 0, "content": "The line 2 of your code means:\nThe first 'array' represents the module name. The second 'array' represents the class name array for which we are creating an array object. The 'i' here represents the typedata since in arrays are a collection of same data type. The 'i' represents the integer elements will be stored in the array a. We should use array when we want to store same type of data because its execution is much faster than the lists. Also, arrays take up less space than lists.", "abstract": ""}, {"id": 53212066, "score": 4, "vote": 0, "content": "The difference between an array and a list is that the type of object stored in the array container is constrained. In line 2: You are initializing an array of signed ints.  A list allows you to have a combination of varying datatypes (both custom and basic) if desired. For example:  You would choose to use an array over a list for efficiency purposes if you can assure the datatype found in the array to all be the same and of a certain, basic type.  More information can be found here: Description of Array Module Usage", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/69426559/what-does-python-array-1-mean", "keywords": [], "tags": ["python"], "question": {"id": 69426559, "title": "What does python array -1 mean?", "content": "I found something like losss_test[-1] in python script. I was looking for web pages to get some answers for [-1]. But, I can not get the proper answer. If someone know it, please tell me the meaning on it...", "abstract": ""}, "answers": [{"id": 69426610, "score": 0, "vote": 0, "content": "Negative numbers for an index takes the values starting from the end of the array.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/67325080/sorting-arrays-in-python", "keywords": [], "tags": ["python", "list"], "question": {"id": 67325080, "title": "Sorting arrays in python", "content": "I have an array of variable numbers.\nI have another array that I want to be the of labels for the numbers array. I want to sort the array by highest to lowest value. I did this by: However, how do I rearrange the labels so that they are in line with the values?\nI need to keep it so that a sortedlabellist is its own individual array (for future things). so i will probably have to link the values to the labels and then pull out a sortedlabellist separately?", "abstract": ""}, "answers": [{"id": 67325996, "score": 1, "vote": 0, "content": "The problem here is that the data structures you've choosen are not adecuate. If you just want to associate each element of myList with elements of mylables then a list of tuples [(\"cats\", T1_sum), (\"dogs\", T2_sum), ...] should be enough. Assuming both lists have same length (so as not to lose information), gets a list of tuples. Then you should sort it by first component. Now, if you have more information about the lists, say every element in mylables ([\"cats\", \"dogs\", ...]) appears only once, then choosing a dictionary (data structure in python) with mylables elements as keys and myList elements as values will make search operations and sorting operations more efficient. Assuming both lists have the same length (so as not to lose information), gets you a dictionary that can be sorted with the next line:", "abstract": ""}, {"id": 67325176, "score": 5, "vote": 0, "content": "You can just form a dictionary in order to maintain the order of both the lists while sorting: Then you can just sort this dictionary based on values, like this:", "abstract": ""}, {"id": 67325263, "score": 1, "vote": 0, "content": "You can do this.", "abstract": ""}, {"id": 67325253, "score": 3, "vote": 0, "content": "If you want to avoid using a dictionary you can use zip and unzip (*zip): In fact, the unpacking returns the sequences as tuples. If you need it as list, you can cast it to list again:", "abstract": ""}, {"id": 67325211, "score": 1, "vote": 0, "content": "You could use list comprehension and zip():", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/67505118/python-array-and-a-list", "keywords": [], "tags": ["python", "arrays", "list", "module"], "question": {"id": 67505118, "title": "Python Array and a List", "content": "Why does python have a specific module for arrays? I know that arrays can only hold one datatype and Python has a module for array's but why does python have a specific module for array's because if we want we can create a list with the same datatype. So what it the actual advantage of having a array module in python? This is a array: I can do the same exact thing with a list: What the advantage with the python module array?", "abstract": ""}, "answers": [{"id": 67505224, "score": 1, "vote": 0, "content": "I think this explains it well. https://learnpython.com/blog/python-array-vs-list/ Some key reasons to use arrays instead of lists: Some key reasons to use lists instead of arrays: Though lists and arrays might have similar features, they are used for different cases.", "abstract": ""}, {"id": 67505418, "score": 1, "vote": 0, "content": "Lists in Python refer to linked lists, where one member stores also stores where the next member of the list should be. Basically, member1 stores where member2 is in the memory and member2 stores where member3 is and so on. While arrays are a big chunk of continuous memory. It is of the same datatype as jumping from the first member to other requires knowledge of the exact gap between them in memory which is only possible when the datatype is the same or of the same size. Having arrays with different datatypes will be massively inefficient. It's easier to add or remove elements/members from a List but it is faster to parse an array. It's a tradeoff. Python is mainly used for data science, which means elements are frequently added and removed, so arrays are a second choice hidden in a module. Btw, nobody uses array module, just use numpy.", "abstract": ""}, {"id": 67505341, "score": 0, "vote": 0, "content": "List is better , But  if you're storing a large number of data, you can use array.\nBecause arrays will store your data more compactly and efficiently", "abstract": ""}, {"id": 67505303, "score": 0, "vote": 0, "content": "For most cases use cases a List will do. The concept of array in Python may be confusing for those coming from other Programming language backgrounds. That array module is wrapper over C arrays,  and can only be used for specific types, whereas lists can be used for any object. If you're not into numerical computation, and ain't using scientific packages such as scipy and numpy, I see no reason to use the array Module", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/67367080/python-array-as-an-argument-for-a-function", "keywords": [], "tags": ["python", "arrays", "function", "input", "arguments"], "question": {"id": 67367080, "title": "Python: array as an argument for a function", "content": "I wanted to know how to work with an array as a functional argument in Python. I will show a short example: I obviously get the error that 2 positional arguments are needed but 4 were given when I try to run it, can anybody tell me how to do this accept just using (coeff_arr[i]) in the argument of the function?\nCheers", "abstract": ""}, "answers": [{"id": 67367252, "score": 1, "vote": 0, "content": "Your question is missing the code you use to call the function, but from the error I infer that you are calling it as polynom(x, coefficient1, coefficient2, coefficient3). Instead you need to either pass the coefficients as a list: Or use the unpacking operator * to define the function as follows, which will take all positional arguments after x and put them into coeff_arr as a list: (The unpacking operator can also be used in a function call, which will do the opposite of taking a list and passing its elements as positional arguments: is equivalent to )", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66960561/computation-on-large-array-in-python", "keywords": [], "tags": ["python", "arrays", "numpy", "sympy"], "question": {"id": 66960561, "title": "Computation on large array in python", "content": "i have a question concerning computation of large array in python( >=3.6.8 ) on Ubuntu SO.\nI have a large array A, about 20 000 000 (or more) of points (each point is a 3d coordinate x,y,z).\nI would like to know which of these points are close to a given plane. I use sympy python library for representing point, plane and to compute distance.\nI have another array T of planes (as sympy object), tipically an array of 7 or 10 elements.\nFor example, for each point p of my A array, and for each t plane, i do something like: Obviously, if i loop this check for all points and for all plane, i achieve the result after several hours. I done this loop also using processes splitting my array of points in chunks, but also in this way, computation requires a lot of time (hours).\nI read numpy has where method, but i don't know how to set condition like: where:\nt is a sympy plane;\nPoint3D is sympy class for casting generic x,y,z point into sympy point;\nB is array of A indexes which satisfy condition. where condition as above reported causes exception :\"Nonzero coordinates cannot be removed\".\nIs there some fast approach to compute the loop into 10 or 15 minutes (max)?\nThank you in advance.\nBye.", "abstract": ""}, "answers": [{"id": 66967148, "score": 2, "vote": 0, "content": "SymPy is a symbolic library. The idea is that you would use it to symbolically derive a formula that you then compute using more efficient numerical libraries e.g.: You can see the code used to make the lambdified function like this: You can now use this function with numpy arrays for the x, y and z values: This will handle large arrays of inputs more efficiently e.g. 20 million points can be processed in 1 second:", "abstract": ""}, {"id": 66962250, "score": 2, "vote": 0, "content": "Using map  seems to be very fast. Here a code test example with One Million points in 4 seconds . in this case map needs a function and two iterables ,\nso we need iterable points (one million) and iterable planes (one million , all the same in this case). output for One Million Point Plane distance computations : I think  20M distance computations needs 4.15*20 ->  83 seconds ~\nTry it and let me know. Here an extended example to abtain a new list with the points that are at a distance less than a value , ** processing 1M points in less than 5 seconds ** output: So less than 5 seconds for 1M points .  Probably  100 seconds for 20M Points", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/57390634/python-array-is-being-modified-and-i-dont-understand-why", "keywords": [], "tags": ["python", "arrays", "numpy"], "question": {"id": 57390634, "title": "Python: Array is being modified and I don&#39;t understand why", "content": "New to python but with some experience with c# and trying to create a basic script for calculating the standard deviation of a set of randomly generated integers. The two histograms generated in the code below are different, though they should be the same to my knowledge as I never modified the variable 'incomes' between generating the two histograms.  The two histograms generated by the code are different when they should be the same (not a scaling error).", "abstract": ""}, "answers": [{"id": 57390703, "score": 2, "vote": 0, "content": "incomestore and incomes refer to the same array. You have to make a copy But it is better, to use the vector abilities of numpy:", "abstract": ""}]}]