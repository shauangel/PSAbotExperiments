[{"link": "https://stackoverflow.com/questions/69456014/get-name-of-current-module-in-go", "keywords": [], "tags": ["go", "reflection", "go-modules"], "question": {"id": 69456014, "title": "Get Name of Current Module in Go", "content": "I am attempting to create named loggers automatically for HTTP handlers that I'm writing, where I am passed a function (pointer). I'm using the code mentioned in this question to get the name of a function: I'm using this in my main function to try it out like so: I see output like this: This is okay but I'd like an output such as long.HandlerA, long.nested.path.HandlerB, etc. If I could get the Go module name (github.com/naftulikay/golang-webapp/experiments/functionname), I can then use strings.Replace to remove the module name to arrive at long/nested/path.HandlerB, then strings.Replace to replace / with . to finally get to my desired value, which is long.nested.path.HandlerB. The first question is: can I do better than runtime.FuncForPC(reflect.ValueOf(fn).Pointer()) for getting the qualified path to a function? If the answer is no, is there a way to get the current Go module name using runtime or reflect so that I can transform the output of runtime.FuncForPC into what I need? Once again, I'm getting values like: And I'd like to get values like: EDIT: It appears that Go does not have a runtime representation of modules, and that's okay, if I can do it at compile time that would be fine too. I've seen the codegen documentation and I'm having a hard time figuring out how to write my own custom codegen that can be used from go generate.", "abstract": ""}, "answers": [{"id": 69463885, "score": 5, "vote": 0, "content": "The module info is included in the executable binary, and can be acquired using the debug.ReadBuildInfo() function (the only requirement is that the executable must be built using module support, but this is the default in the current version, and likely the only in future versions). BuildInfo.Path is the current module's path. Let's say you have the following go.mod file: Example reading the build info: This will output (try it on the Go Playground): See related: Golang - How to display modules version from inside of code", "abstract": ""}, {"id": 69456998, "score": 3, "vote": 0, "content": "If your goal is to just have the name of the module available in your program, and if you are okay with setting this value at link time, then you may use the -ldflags build option. You can get the name of the module with go list -m from within the module directory. You can place everything in a Makefile or in a shell script: With main.go looking like: With the mentioned \"golang.org/x/mod/modfile\" package, an example might look like: However embedding the entire go.mod file in your use case seems overkill. Of course you could also open the file at runtime, but that means you have to deploy go.mod along with your executable. Setting the module name with -ldflags is more straightforward IMO.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/602846/how-can-i-access-the-current-executing-module-or-class-name-in-python", "keywords": [], "tags": ["python", "module"], "question": {"id": 602846, "title": "How can I access the current executing module or class name in Python?", "content": "I would like to be able to dynamically retrieve the current executing module or class name from within an imported module.  Here is some code: foo.py: bar.py: This obviously does not work as __name__ is the name of the module that contains the function.  What I would like to be access inside the foo module is the name of the current executing module that is using foo.  So in the case above it would be bar but if any other module imported foo I would like foo to dynamically have access to the name of that module. Edit: The inspect module looks quite promising but it is not exactly what I was looking for.  What I was hoping for was some sort of global or environment-level variable that I could access that would contain the name of the current executing module.  Not that I am unwilling to traverse the stack to find that information - I just thought that Python may have exposed that data already. Edit: Here is how I am trying to use this.  I have two different Django applications that both need to log errors to file.  Lets say that they are called \"AppOne\" and \"AppTwo\".  I also have a place to which I would like to log these files: \"/home/hare/app_logs\".  In each application at any given point I would like to be able to import my logger module and call the log function which writes the log string to file.  However what I would like to do is create a directory under app_logs that is the name of the current application (\"AppOne\" or \"AppTwo\") so that each application's log files will go in their respective logging directories. In order to do this I thought that the best way would be for the logger module to have access to some sort of global variable that denotes the current application's name as it is responsible for knowing the location of the parent logging directory and creating the application's logging directory if it does not yet exist.", "abstract": ""}, "answers": [{"id": 41233151, "score": 22, "vote": 0, "content": "To obtain a reference to the \"_main_\" module when in another: To then obtain the module's file path, which includes its name: If within the \"__main__\" module, simply use: __file__ To obtain just the file name from the file path: To separate the file name from its extension: To obtain the name of a class instance: To obtain the name of a class:", "abstract": ""}, {"id": 603460, "score": 74, "vote": 0, "content": "From the comment -- not the question. I am simply curious to see if what I am trying to do is possible. The answer to \"is it possible\" is always \"yes\".  Always.  Unless your question involves time travel, anti-gravity or perpetual motion. Since the answer is always \"yes\", your question is ill-formed.  The real question is \"what's a good way to have my logging module know the name of the client?\" or something like that. The answer is \"Accept it as a parameter.\"  Don't mess around with inspecting or looking for mysterious globals or other tricks. Just follow the design pattern of logging.getLogger() and use explicitly-named loggers.  A common idiom is the following That handles almost all log naming perfectly.", "abstract": ""}, {"id": 55227175, "score": 0, "vote": 0, "content": "To get the current file module, containing folder, here is what worked for me:", "abstract": ""}, {"id": 47097725, "score": 5, "vote": 0, "content": "If you want only the name of the file:", "abstract": ""}, {"id": 602881, "score": 11, "vote": 0, "content": "I think what you want to use is the inspect module, to inspect the python runtime stack.  Check out this tutorial.  I think it provides an almost exact example of what you want to do.", "abstract": ""}, {"id": 41554105, "score": 7, "vote": 0, "content": "Using __file__ alone gives you a relative path for the main module and an absolute path for imported modules. Being aware this we can get the module file constantly either way with a little help from our os.path tools. For filename only use __file__.split(os.path.sep)[-1]. For complete path use os.path.abspath(__file__). Demo: Results: If you want to strip the '.py' off the end, you can do that easily. (But don't forget that you may run a '.pyc' instead.)", "abstract": ""}, {"id": 7810592, "score": 63, "vote": 0, "content": "This should work for referencing the current module:", "abstract": ""}, {"id": 603503, "score": 19, "vote": 0, "content": "__file__ is the path of current module the call is made.", "abstract": ""}, {"id": 602967, "score": 23, "vote": 0, "content": "The \"currently executing module\" clearly is foo, as that's what contains the function currently running - I think a better description as to what you want is the module of foo's immediate caller (which may itself be foo if you're calling a f() from a function in foo called by a function in bar.  How far you want to go up depends on what you want this for. In any case, assuming you want the immediate caller, you can obtain this by walking up the call stack.  This can be accomplished by calling sys._getframe, with the aprropriate number of levels to walk. [Edit]:  Actually, using the inspect module as suggested above is probably a cleaner way of obtaining the stack frame.  The equivalent code is: (sys._getframe is documented as being for internal use - the inspect module is a more reliable API)", "abstract": ""}, {"id": 602968, "score": 2, "vote": 0, "content": "It's been a while since I've done python, but I believe that you can get access to the globals and locals of a caller through its traceback.", "abstract": ""}, {"id": 602859, "score": 3, "vote": 0, "content": "I don't believe that's possible since that's out of foo's scope.  foo will only be aware of its internal scope since it may be being called by countless other modules and applications.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16657904/getting-the-current-module-name", "keywords": [], "tags": ["drupal", "drupal-7"], "question": {"id": 16657904, "title": "Getting the current module name", "content": "Is there a way to get the name of the module you are working within? I have a large set of modules (about 35) with some common functionality. Long story short is that I would like to be able to get the module name without hard-coding it in a string. Hopefully this isn't necessary, but here's an idea of what I'm trying for: Essentially, I can replace 'MYMODULE' with the module name and be done with it, but I'm wondering if there is a way to get that value programmatically. I'm using Drupal 7. This does not apply to Drupal 8.", "abstract": ""}, "answers": [{"id": 70610810, "score": 0, "vote": 0, "content": "As correctly said in comments only works inside an actual .module file. Answering to question: inside your MYMODULE.module from everywhere in Drupal >8 Not sure this will work on  Drupal 7 as well", "abstract": ""}, {"id": 57605803, "score": 8, "vote": 0, "content": "Although OP was asking regarding D7, here's the solution for Drupal 8 (D8) as well: Of course, you can chain these calls if necessary:", "abstract": ""}, {"id": 16658132, "score": 24, "vote": 0, "content": "If your module file is sites/default/modules/MYMODULE/MYMODULE.module then module name is MYMODULE. You can get it programmatically inside MYMODULE.module file using following command:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/69231603/how-to-find-a-module-name-and-package-name-in-java", "keywords": [], "tags": ["java"], "question": {"id": 69231603, "title": "How to find a module name and package name in Java", "content": "Currently i am running into this issue What I understand is that I need to add --add-opens module/package=target-module(,target-module)* Knowing the full path to the field name, where can I search for the package name / module name so that I can pass to the -add-opens flag? Right now I can only guess --add-opens something/sun.reflect.annotation=ALL-UNNAMED", "abstract": ""}, "answers": [{"id": 69232787, "score": 2, "vote": 0, "content": "To get a Module by a Class, you can use the getModule() To get the name -> Use this.getClass().getCanonicalName() to get the full class name. Resources: Way to use getModule Oracle documentation about getModule getCanonicalName() Method How to use getCanonicalName method", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/67996841/how-do-you-print-or-capture-the-current-module-name", "keywords": [], "tags": ["d"], "question": {"id": 67996841, "title": "How do you print or capture the current module name?", "content": "I want to print the module name of my main source file in that source file. I tried this: However, it prints: The module name is: std.traits", "abstract": ""}, "answers": [{"id": 68076371, "score": 2, "vote": 0, "content": "Using __MODULE__ is the way to go. It's a special token, like __FILE__ and __LINE__, which means it'll get expanded at the call site. See the specs for some example.", "abstract": ""}, {"id": 68000485, "score": 3, "vote": 0, "content": "The moduleName template description is: Get the module name (including package) for the given symbol. So moduleName!moduleName should give std.traits. Just replace the template argument with any other symbol to get it's module name. For example writeln(moduleName!main). Another way is using writeln(__MODULE__).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/67646597/access-current-module-name-in-built-vue3-vite-application", "keywords": [], "tags": ["typescript", "vue.js", "vuejs3", "rollupjs", "vite"], "question": {"id": 67646597, "title": "Access current module name in built vue3/vite application", "content": "In my vue3/vite/typescript application, I use import.meta.url and extract the file name to get the name of the current module: File 'myModule.ts': File 'test.ts': This works great, as long as I run the development server (which actually imports the modules), but fails if I use the built version. The reason is, that the built version is created with rollup.js which creates a single file and doesn't really import anything anymore. But how could I possibly get the name of the module in this context? Can I somehow keep import.meta work or is there another way to achieve this (other than duplicating the file name in the url property)?", "abstract": ""}, "answers": [{"id": 67648204, "score": 0, "vote": 0, "content": "Use getCurrentInstance this has most of the things the Options API this had \n\nimport {\n  getCurrentInstance\n} from 'vue'\n\nexport default {\n  setup() {\n    const instance = getCurrentInstance();\n  }\n}\n\n\n And do some digging in this object to find the name of your component!", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66606409/get-linux-kernel-module-name-from-current-module", "keywords": [], "tags": ["c", "linux-kernel", "kernel-module"], "question": {"id": 66606409, "title": "Get Linux Kernel module name from current module", "content": "I'm writing some kernel modules, but for debug output I'd like to (automatically) print out which kernel module is producing the output. Is there a function or variable I can use to get the name of the module that's executing?", "abstract": ""}, "answers": [{"id": 66606973, "score": 1, "vote": 0, "content": "Inside the code of the kernel module, THIS_MODULE points to the structure representing this module. You may use name field of this structure for extract the current module name: If your code could be compiled (depending on configuration) either as a module or as a part of the kernel, then in the latter case THIS_MODULE will be NULL, so you cannot access its fields. For such code you could use module_name macro instead: Within the kernel core code (not a module) the macro is expanded to the string \"kernel\".", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/63501526/how-can-i-get-current-module-name-nwidart-laravel-modules", "keywords": [], "tags": ["laravel"], "question": {"id": 63501526, "title": "How can i get current module name [nwidart/laravel-modules]", "content": "How can i get current module name, or current namespace. of laravel\nI use this library [nwidart/laravel-modules]. I trid this code but not solve problem", "abstract": ""}, "answers": [{"id": 63502138, "score": 0, "vote": 0, "content": "Add this to your modules __construct controller :", "abstract": ""}, {"id": 63501901, "score": 1, "vote": 0, "content": "To get module entity: $module = Module::find('blog'); To get module name: $module->getName(); This is documented pretty well by package author here:\nhttps://nwidart.com/laravel-modules/v1/advanced-tools/module-methods", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46267150/how-to-get-module-name-by-class-in-java-9", "keywords": [], "tags": ["java", "java-9", "java-module"], "question": {"id": 46267150, "title": "How to get module name by class in Java 9?", "content": "How to get module name by class in Java 9? For example, let's consider the following situation. There are two named modules - ModuleA and ModuleB. ModuleA knows nothing about ModuleB. ModuleB requires ModuleA. ModuleA contains class: ModuleB contains class: How to do it?", "abstract": ""}, "answers": [{"id": 46267256, "score": 11, "vote": 0, "content": "To get a Module by a Class in Java9, you can use the getModule() and further getName on the Module class to fetch the name of the module An observable point to note (not in your case as you're using named modules) is that the getModule returns the module that this class or interface is a member of. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/42891533/obtain-just-the-current-modules-name-in-python", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 42891533, "title": "Obtain just the current module&#39;s name in Python", "content": "How can you just obtain the current module's name in Python.  Results in output of the form: I just want to print MODULE_NAME", "abstract": ""}, "answers": [{"id": 42891626, "score": 11, "vote": 0, "content": "Use __file__ which gives full path of the module file (if saved to disk) and transform it using os.path functions:", "abstract": ""}]}]