[{"link": "https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists", "keywords": [], "tags": ["python", "list", "multidimensional-array", "flatten"], "question": {"id": 952914, "title": "How do I make a flat list out of a list of lists?", "content": "I have a list of lists like [[1, 2, 3], [4, 5, 6], [7], [8, 9]]. How can I flatten it to get [1, 2, 3, 4, 5, 6, 7, 8, 9]? If your list of lists comes from a nested list comprehension, the problem can be solved more simply/directly by fixing the comprehension; please see python list comprehensions; compressing a list of lists?. The most popular solutions here generally only flatten one \"level\" of the nested list. See Flatten an irregular (arbitrarily nested) list of lists for solutions that completely flatten a deeply nested structure (recursively, in general).", "abstract": ""}, "answers": [{"id": 75709744, "score": -1, "vote": 0, "content": "I like to add a high performant generator solution which can fatten nested lists (or any kind of iterable) of any depth not (only 2D-lists): Depending on your needs a generators have huge advantages over lists. E.g. If you want add filter() functions afterwards. The resulting list should be instanced only at the end after you have constructed the full generator incl. the filtering by this you avoid multiple iterations over the items. Remark: Compaired to the other proposed generator solution this is an iterative and not a recursive solution which avoids RecursionErrors in case of deep nested iterables.", "abstract": ""}, {"id": 74879769, "score": -6, "vote": 0, "content": "You can simply use pandas to do this:", "abstract": ""}, {"id": 74069856, "score": 4, "vote": 0, "content": "If you have a numpy array a: produces: np.flatten also accepts other parameters: More details about parameters are available here.", "abstract": ""}, {"id": 73576067, "score": -5, "vote": 0, "content": "I created a little function which can basically flatten anything.\nYou can get it with pip: pip install flatten-everything You can even protect objects from getting flattened:", "abstract": ""}, {"id": 73304966, "score": -1, "vote": 0, "content": "Simplest Way to do in python without any library This function will work for even multidimensional list also using recursion we can achieve any combination of list inside list, we can flatten it without using any library.", "abstract": ""}, {"id": 73304338, "score": 1, "vote": 0, "content": "For a list containing multiple list here a recursive solution that work for me and that i hope is correct: Output:", "abstract": ""}, {"id": 952952, "score": 7023, "vote": 0, "content": "Given a list of lists l, which means: is faster than the shortcuts posted so far. (l is the list to flatten.) Here is the corresponding function: As evidence, you can use the timeit module in the standard library: Explanation: the shortcuts based on + (including the implied use in sum) are, of necessity, O(L**2) when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., I * (L**2)/2. The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.", "abstract": ""}, {"id": 73106867, "score": 3, "vote": 0, "content": "If you want to unnest everything and keep a distinct list of elements, you could use this as well.", "abstract": ""}, {"id": 953097, "score": 2224, "vote": 0, "content": "You can use itertools.chain(): Or you can use itertools.chain.from_iterable() which doesn't require unpacking the list with the * operator: This approach is arguably more readable than [item for sublist in l for item in sublist] and appears to be faster too:", "abstract": ""}, {"id": 70287313, "score": 31, "vote": 0, "content": "According your list [[1, 2, 3], [4, 5, 6], [7], [8, 9]] which is 1 list level, we can simply use sum(list,[]) without using any libraries To extend the advantage of this method when there is a tuple or number existing inside. Simply adding a mapping function for each element by map to the list In here, there is a clear explanation of the drawback in terms of memory for this approach. In short, it recursively creates list objects, which should be avoided :(", "abstract": ""}, {"id": 40857703, "score": 189, "vote": 0, "content": "Here is a general approach that applies to numbers, strings, nested lists and mixed containers.  This can flatten both simple and complicated containers (see also Demo). Code Notes: Demo Reference", "abstract": ""}, {"id": 952946, "score": 1309, "vote": 0, "content": "Note from the author: This is very inefficient. But fun, because monoids are awesome. sum sums the elements of the iterable xss, and uses the second argument as the initial value [] for the sum. (The default initial value is 0, which is not a list.) Because you are summing nested lists, you actually get [1,3]+[2,4] as a result of sum([[1,3],[2,4]],[]), which is equal to [1,3,2,4]. Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.", "abstract": ""}, {"id": 952943, "score": 324, "vote": 0, "content": "Using functools.reduce, which adds an accumulated list xs to the next list ys: Output: A faster way using operator.concat: Output:", "abstract": ""}, {"id": 40813764, "score": 118, "vote": 0, "content": "To flatten a data-structure that is deeply nested, use iteration_utilities.deepflatten1: It's a generator so you need to cast the result to a list or explicitly iterate over it. To flatten only one level and if each of the items is itself iterable you can also use iteration_utilities.flatten which itself is just a thin wrapper around itertools.chain.from_iterable: Just to add some timings (based on Nico Schl\u00f6mer's answer that didn't include the function presented in this answer):  It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better. The results show that if the iterable contains only a few inner iterables then sum will be fastest, however for long iterables only the itertools.chain.from_iterable, iteration_utilities.deepflatten or the nested comprehension have reasonable performance with itertools.chain.from_iterable being the fastest (as already noticed by Nico Schl\u00f6mer). 1 Disclaimer: I'm the author of that library", "abstract": ""}, {"id": 71468284, "score": 3, "vote": 0, "content": "Not a one-liner, but seeing all the answers here, I guess this long list missed some pattern matching, so here it is :) The two methods are probably not efficient, but anyway, it's easy to read (to me at least; perhaps I'm spoiled by functional programming): The second version considers lists of lists of lists... whatever the nesting:", "abstract": ""}, {"id": 70669715, "score": 0, "vote": 0, "content": "If I want to add something to the great previous answers, here is my recursive flatten function which can flatten not only nested lists, but also any given container or any generally any object which can throw out items. This does also work for any depth of nesting and it is a lazy iterator which yields the items as requested: This way, you can exclude types you don't want to be flattened, like str or what else. The idea is if an object can pass the iter() it's ready to yield items. So the iterable can have even generator expressions as an item. Someone could argue: Why did you write this that generic when the OP didn't ask for it? OK, you're right. I just felt like this might help someone (like it did for myself). Test cases: Output:", "abstract": ""}, {"id": 63316751, "score": 12, "vote": 0, "content": "There are several answers with the same recursive appending scheme as below, but none makes use of try, which makes the solution more robust and Pythonic. Usage: this is a generator, and you typically want to enclose it in an iterable builder like list() or tuple() or use it in a for loop. Advantages of this solution are: N.B.: Since all iterables are flattened, strings are decomposed into sequences of single characters. If you don't like/want such behavior, you can use the following version which filters out from flattening iterables like strings and bytes:", "abstract": ""}, {"id": 59913424, "score": 15, "vote": 0, "content": "You can use the list extend method. It shows to be the fastest: Performance: Output: ", "abstract": ""}, {"id": 50367409, "score": 4, "vote": 0, "content": "This may not be the most efficient way, but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python\u00a03.5) and recursion. The output is This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable flist and then rolls back it to the parent. Whenever flist is returned, it is extended to the parent's flist in the list comprehension. Therefore, at the root, a flat list is returned. The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl flist, like below. The output is again Although I am not sure at this time about the efficiency.", "abstract": ""}, {"id": 72250465, "score": 0, "vote": 0, "content": "I would suggest using generators with yield statement and yield from.\nHere's an example:", "abstract": ""}, {"id": 72064062, "score": -2, "vote": 0, "content": "", "abstract": ""}, {"id": 71718885, "score": -1, "vote": 0, "content": "Considering the list has just integers:", "abstract": ""}, {"id": 48569389, "score": 31, "vote": 0, "content": "matplotlib.cbook.flatten() will work for nested lists even if they nest more deeply than the example. Result: This is 18x faster than underscore._.flatten:", "abstract": ""}, {"id": 44917489, "score": 51, "vote": 0, "content": "The following seems simplest to me:", "abstract": ""}, {"id": 70285413, "score": 2, "vote": 0, "content": "A non-recursive function to flatten lists of lists of any depth:", "abstract": ""}, {"id": 45323085, "score": 853, "vote": 0, "content": "I tested most suggested solutions with perfplot (a pet project of mine, essentially a wrapper around timeit), and found to be the fastest solution, both when many small lists and few long lists are concatenated. (operator.iadd is equally fast.) A simpler and also acceptable variant is If the number of sublists is large, this performs a little worse than the above suggestion.   Code to reproduce the plot:", "abstract": ""}, {"id": 69485553, "score": 5, "vote": 0, "content": "I wanted a solution which can deal with multiple nesting ([[1], [[[2]], [3]]], [1, 2, 3] for example), but would also not be recursive (I had a big level of recursion and I got a recursion error. This is what I came up with: and tests:", "abstract": ""}, {"id": 40275594, "score": 9, "vote": 0, "content": "If you are willing to give up a tiny amount of speed for a cleaner look, then you could use numpy.concatenate().tolist() or numpy.concatenate().ravel().tolist(): You can find out more here in the documentation, numpy.concatenate and numpy.ravel.", "abstract": ""}, {"id": 38421470, "score": 23, "vote": 0, "content": "One can also use NumPy's flat: It only works when sublists have identical dimensions.", "abstract": ""}, {"id": 64718802, "score": -3, "vote": 0, "content": "", "abstract": ""}, {"id": 40938883, "score": 46, "vote": 0, "content": "Consider installing the more_itertools package. It ships with an implementation for flatten (source, from the itertools recipes): Note: as mentioned in the docs, flatten requires a list of lists.  See below on flattening more irregular inputs. As of version 2.4, you can flatten more complicated, nested iterables with more_itertools.collapse (source, contributed by  abarnet).", "abstract": ""}, {"id": 952997, "score": 38, "vote": 0, "content": "The reason your function didn't work is because the extend extends an array in-place and doesn't return it. You can still return x from lambda, using something like this: Note: extend is more efficient than + on lists.", "abstract": ""}, {"id": 48170454, "score": 2, "vote": 0, "content": "Another unusual approach that works for hetero- and homogeneous lists of integers:", "abstract": ""}, {"id": 48569551, "score": 10, "vote": 0, "content": "Note: Below applies to Python 3.3+ because it uses yield_from.  six is also a third-party package, though it is stable.  Alternately, you could use sys.version. In the case of obj = [[1, 2,], [3, 4], [5, 6]], all of the solutions here are good, including list comprehension and itertools.chain.from_iterable. However, consider this slightly more complex case: There are several problems here: You can remedy this as follows: Here, you check that the sub-element (1) is iterable with Iterable, an ABC from itertools, but also want to ensure that (2) the element is not \"string-like.\"", "abstract": ""}, {"id": 45571781, "score": 6, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70745344/finding-the-most-common-list-in-list-of-lists", "keywords": [], "tags": ["python", "list", "list-comprehension", "nested-lists", "mode"], "question": {"id": 70745344, "title": "Finding the most common list in list of lists", "content": "I have a list of lists and I wish to find the most common list in every list and if there are multiple modes, than all of them. It sounds a bit complex so I will provide the example. The list of lists that I have is: And the output that I want to have is: Any help is much appreciated, thank you in advance for your time!", "abstract": ""}, "answers": [{"id": 70746143, "score": 0, "vote": 0, "content": "It will work with Counter and similar solutions, but then convert each inner list to a tuple, so it is hashable. Then get the most frequent result (with Counter you can use most_common), and convert that result back to a list:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/716477/join-list-of-lists-in-python", "keywords": [], "tags": ["python"], "question": {"id": 716477, "title": "join list of lists in python", "content": "Is the a short syntax for joining a list of lists into a single list( or iterator) in python? For example I have a list as follows and I want to iterate over a,b and c.   The best I can come up with is as follows.", "abstract": ""}, "answers": [{"id": 716482, "score": 671, "vote": 0, "content": "This gives", "abstract": ""}, {"id": 3323387, "score": 47, "vote": 0, "content": "shortest!", "abstract": ""}, {"id": 716479, "score": 33, "vote": 0, "content": "This is known as flattening, and there are a LOT of implementations out there. How about this, although it will only work for 1 level deep nesting: From those links, apparently the most complete-fast-elegant-etc implementation is the following:", "abstract": ""}, {"id": 9761214, "score": 29, "vote": 0, "content": "If you need a list, not a generator, use list():", "abstract": ""}, {"id": 21034265, "score": 26, "vote": 0, "content": "A performance comparison: Producing: This is with Python 2.7.1 on Windows XP 32-bit, but @temoto in the comments above got from_iterable to be faster than map+extend, so it's quite platform and input dependent. Stay away from sum(big_list, [])", "abstract": ""}, {"id": 9050521, "score": 2, "vote": 0, "content": "For one-level flatten, if you care about speed, this is faster than any of the previous answers under all conditions I tried.  (That is, if you need the result as a list.  If you only need to iterate through it on the fly then the chain example is probably better.)  It works by pre-allocating a list of the final size and copying the parts in by slice (which is a lower-level block copy than any of the iterator methods): Sorted times list with comments:", "abstract": ""}, {"id": 716811, "score": 16, "vote": 0, "content": "This works recursively for infinitely nested elements: Result:", "abstract": ""}, {"id": 11749067, "score": 1, "vote": 0, "content": "I had a similar problem when I had to create a dictionary that contained the elements of an array and their count. The answer is relevant because, I flatten a list of lists, get the elements I need and then do a group and count. I used Python's map function to produce a tuple of element and it's count and groupby over the array. Note that the groupby takes the array element itself as the keyfunc. As a relatively new Python coder, I find it to me more easier to comprehend, while being Pythonic as well.  Before I discuss the code, here is a sample of data I had to flatten first: It is a query result from Mongo. The code below flattens a collection of such lists. First, I would extract all the \"entities\" collection, and then for each entities collection, iterate over the dictionary and extract the name attribute. ", "abstract": ""}, {"id": 4495982, "score": 7, "vote": 0, "content": "Late to the party but ...  I'm new to python and come from a lisp background. This is what I came up with (check out the var names for lulz): Seems to work. Test: returns:", "abstract": ""}, {"id": 1992070, "score": 2, "vote": 0, "content": "Or a recursive operation:", "abstract": ""}, {"id": 716761, "score": 258, "vote": 0, "content": "If you're only going one level deep, a nested comprehension will also work: On one line, that becomes:", "abstract": ""}, {"id": 716491, "score": 3, "vote": 0, "content": "There's always reduce (being deprecated to functools): Unfortunately the plus operator for list concatenation can't be used as a function -- or fortunate, if you prefer lambdas to be ugly for improved visibility.", "abstract": ""}, {"id": 716489, "score": 328, "vote": 0, "content": "", "abstract": ""}, {"id": 716484, "score": 1, "vote": 0, "content": "Sadly, Python doesn't have a simple way to flatten lists.  Try this: Which will recursively flatten a list; you can then do", "abstract": ""}, {"id": 716481, "score": 5, "vote": 0, "content": "What you're describing is known as flattening a list, and with this new knowledge you'll be able to find many solutions to this on Google (there is no built-in flatten method). Here is one of them, from http://www.daniel-lemire.com/blog/archives/2006/05/10/flattening-lists-in-python/:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72491032/search-for-a-list-from-a-list-of-lists-and-return-the-results", "keywords": [], "tags": ["python", "list"], "question": {"id": 72491032, "title": "Search for a list from a list of lists and return the results", "content": "I have something like this and I would like to be able to search for a element of a list and return the entirety of the list (doesn't have to be that exact format but I would like to be able to see all the elements from the list) I've looked at other forums and when they search I only returns a true or false value, so I'm not sure if what I would like to do is even possible", "abstract": ""}, "answers": [{"id": 72492174, "score": 0, "vote": 0, "content": "In this kind of situation, I would create a function that will iterate the list and use the in operator to see if the value is in the list or not and finally return the index number of that value x or return False. Result:", "abstract": ""}, {"id": 72491357, "score": 0, "vote": 0, "content": "You can use numpy", "abstract": ""}, {"id": 72491211, "score": 2, "vote": 0, "content": "You can abuse the next function to get the first element of a iterable that matches a predicate like this: If no element exists this will throw a StopIteration exception that you can optionally catch. You can also use the in  operator to find if a element is in a list: Combining the two:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11487049/python-list-of-lists", "keywords": [], "tags": ["python"], "question": {"id": 11487049, "title": "Python: list of lists", "content": "Running the code returns so somehow the first argument of each tuple (list) is being updated each time in the list of lists, but the second argument list[0] is not. Can someone explain what's going on here and suggest a way to fix this? I'd like to output", "abstract": ""}, "answers": [{"id": 26110677, "score": 25, "vote": 0, "content": "I came here because I'm new with python and lazy so I was searching an example to create a list of 2 lists, after a while a realized the topic here could be wrong...\nThis is a code to create a list of lists: this is the output: The problem with your code seems to be you are creating a tuple with your list and you get the reference to the list instead of a copy. That I guess should fall under a tuple topic...", "abstract": ""}, {"id": 11487104, "score": 55, "vote": 0, "content": "Lists are a mutable type - in order to create a copy (rather than just passing the same list around), you need to do so explicitly: However, list is already the name of a Python built-in - it'd be better not to use that name for your variable. Here's a version that doesn't use list as a variable name, and makes a copy: Note that I demonstrated two different ways to make a copy of a list above: [:] and list(). The first, [:], is creating a slice (normally often used for getting just part of a list), which happens to contain the entire list, and thus is effectively a copy of the list. The second, list(), is using the actual list type constructor to create a new list which has contents equal to the first list. (I didn't use it in the first example because you were overwriting that name in your code - which is a good example of why you don't want to do that!)", "abstract": ""}, {"id": 51588531, "score": 2, "vote": 0, "content": "Time traveller here This should do the trick. And the output is this: This is done by list comprehension(which makes looping elements in a list via one line code possible). The logic behind this one-line code is the following: (1) for x in range(10) and for y in range(10) are employed for two independent loops inside a list (2) (a list, y) is the general term of the loop, which is why it is placed before two for's in (1) (3) the length of the list in (2) cannot exceed 3, and the list depends on x, so   is used (4) because z starts from zero but range(x-2,x+1) starts from -2 which isn't what we want, so a conditional statement if z >= 0 is placed at the end of the list in (2)", "abstract": ""}, {"id": 11487109, "score": 3, "vote": 0, "content": "When you run the code You are not (as I think you expect) adding a copy of list to the end of listoflists. What you are doing is adding a reference to list to the end of listoflists. Thus, every time you update list, it updates every reference to list, which in this case, is every item in listoflists What you could do instead is something like this:", "abstract": ""}, {"id": 11487147, "score": 3, "vote": 0, "content": "The list variable (which I would recommend to rename to something more sensible) is a reference to a list object, which can be changed. On the line You actually are only adding a reference to the object reference by the list variable. You've got multiple possibilities to create a copy of the list, so listoflists contains the values as you seem to expect: Use the copy library use the slice notation", "abstract": ""}, {"id": 11487116, "score": 2, "vote": 0, "content": "You're also not going to get the output you're hoping for as long as you append to listoflists only inside the if-clause. Try something like this instead:", "abstract": ""}, {"id": 11487098, "score": 13, "vote": 0, "content": "First, I strongly recommend that you rename your variable list to something else. list is the name of the built-in list constructor, and you're hiding its normal function. I will rename list to a in the following. Python names are references that are bound to objects. That means that unless you create more than one list, whenever you use a it's referring to the same actual list object as last time. So when you call you can later change a and it changes what the first element of that tuple points to. This does not happen with a[0] because the object (which is an integer) pointed to by a[0] doesn't change (although a[0] points to different objects over the run of your code). You can create a copy of the whole list a using the list constructor: Or, you can use the slice notation to make a copy:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/26514179/set-of-list-of-lists-in-python", "keywords": [], "tags": ["python", "list", "set"], "question": {"id": 26514179, "title": "set of list of lists in python", "content": "I am having a list of lists : and I want to convert into a set i.e. remove the repeating lists and creating a new list out of it which will only contain the unique lists. In above case the required answer will be  But when I do set(mat), it gives me error TypeError: unhashable type: 'list' Can you please solve my problem. Thanks in advance!", "abstract": ""}, "answers": [{"id": 72066378, "score": 0, "vote": 0, "content": "List as key for dictionary or set is not valid. Because key should remain constant when we want to access values in dictionary for example. Values can change but keys always remain constant. So in your case: We need to convert inner list to tuple. It can be done by Now tuple can be used as key for set/dictionary because tuple's key cannot be changed. Since we need final answer as list of list we need to convert all tuple keys of dictionary as list. We don't care about values so we only read keys from dictionary and convert it to list. Now mat would look something like this. In Python 3.8+ dictionary will preserve order for older version, OrderedDict can be used.", "abstract": ""}, {"id": 26514304, "score": 6, "vote": 0, "content": "@thefourtheye's answer clearly depicts the problem you were facing with non-hashable data types and the way to by pass it so that you can create a set and remove duplicates. This should suffice for most of thef problems but, re-reading your question In above case the required answer will be [[1,2,3],[4,5,6],[7,8,9]]. If the order is important, you need to use OrderedDict", "abstract": ""}, {"id": 26514235, "score": 56, "vote": 0, "content": "Since the lists are mutable, they cannot be hashed. The best bet is to convert them to a tuple and form a set, like this We iterate through the mat, one list at a time, convert that to a tuple (which is immutable, so sets are cool with them) and the generator is sent to the set function. If you want the result as list of lists, you can extend the same, by converting the result of set function call, to lists, like this", "abstract": ""}, {"id": 26514210, "score": 8, "vote": 0, "content": "Lists are mutable, therefore unhashable. Use tuples instead", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/18980396/building-a-list-inside-a-list-in-python", "keywords": [], "tags": ["python", "list"], "question": {"id": 18980396, "title": "Building a list inside a list in python", "content": "I have been trying to add some data in a python list. I am actually going to store the data as a list inside a list. Now, the data is not coming index-wise.  To explain that lets say I have a list of lists 'a'. Now I have data for a[2] before a[1]. And both a[1] and a[2] are lists themselves. Now, obviously I can't assign anything to a[2] before assigning a[1]. And I don't know how much lists would be there. I mean, this is supposed to be dynamic. Any solution to this, so that I can successfully build the list?", "abstract": ""}, "answers": [{"id": 63677003, "score": 0, "vote": 0, "content": "I am gonna make it as simple as it gets, No need for fancy modules, Just make an empty list in the start of the file, and then append that empty list whenever you need it like, Until the Function get_data give a certain output add empty lists within a list.", "abstract": ""}, {"id": 44340661, "score": 4, "vote": 0, "content": "I think this solution solves your problem. Create the secondary list(inside_list) local to the for loop Output:", "abstract": ""}, {"id": 41930123, "score": 0, "vote": 0, "content": "We can use the first item in the list as an index and then make use of it for adding the right value to it at runtime using the list.", "abstract": ""}, {"id": 22334297, "score": 7, "vote": 0, "content": "I had the same problem, to fill empty list with definite amount of lists.\nHere is my way out\nI made a \"board\" 6x6 filled with O, just for instant: Result:", "abstract": ""}, {"id": 18980458, "score": 10, "vote": 0, "content": "You could append empty lists until you have enough to access the index you have data for: However, you may want to use a dictionary instead, letting you implement a sparse object instead. A collections.defaultdict() object is especially useful here: data now has keys 2 and 5, each a list with one element. No entries for 0, 1, 3, or 4 exist yet.", "abstract": ""}, {"id": 18980449, "score": 2, "vote": 0, "content": "You can do it, there is no problem appending an element.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66517274/cross-product-between-list-of-lists-in-python", "keywords": [], "tags": ["python", "python-3.x", "list"], "question": {"id": 66517274, "title": "Cross product between list of lists in python", "content": "let's say i have 2 lists like below: What i would like to do is cross product between the list items in these two lists.In this example the result would be : How could this be done using python ? i have searched online for a bit but i can't find a solution and i've been stuck.Any help would be very welcome. Thanks in advance!!", "abstract": ""}, "answers": [{"id": 66518029, "score": 1, "vote": 0, "content": "From itertools, product will produce the required pairings but the output will be tuples of on-item lists.  You can use chain.from_iterable to combine those lists and map the result to lists efficiently:", "abstract": ""}, {"id": 66517587, "score": 1, "vote": 0, "content": "", "abstract": ""}, {"id": 66517325, "score": 3, "vote": 0, "content": "That is cartesian product, but as you have 2-level lists as input, you need a little trick to get the result flatten the result after product flatten the input list before product If you have 1-level list, it's just", "abstract": ""}, {"id": 66517319, "score": 7, "vote": 0, "content": "You can try itertools.product", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/58983220/why-doesnt-listlist", "keywords": [], "tags": ["python", "list"], "question": {"id": 58983220, "title": "Why doesn&#39;t [[]] == list(list())", "content": "I just randomly observed the following in Python and am curious to know the reason why this evaluates to False: Interestingly if you rearrange the syntax in the following ways, the first way evaluates as False, but the second as True: What is going on under the hood here?", "abstract": ""}, "answers": [{"id": 58983331, "score": 12, "vote": 0, "content": "From the the Python 2 documentation on the list constructor class list([iterable])  Return a list whose items are the same and in the same order as iterable\u2019s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For instance, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, returns a new empty list, []. When you pass a list to list() it returns a copy, not a nested list, whereas [[]] creates an empty nested list - or rather a list containing a single element which is itself an empty list. Note \u2002 - \u2002 This is notably absent from the corresponding Python 3 documentation, but it holds true for Python 3 regardless.", "abstract": ""}, {"id": 58983306, "score": 9, "vote": 0, "content": "list does not construct a list that contains its argument; it constructs a list whose elements are contained in its argument. list([]) does not return [[]]; it returns []. Thus, list(list()) == list([]) == [].", "abstract": ""}, {"id": 58983295, "score": 6, "vote": 0, "content": "list(...) constructor is not doing the same thing as the list literal [...]. The constructor takes any iterable and makes a list out of its items whereas a list literal defines a list with exactly the enumerated items Note that when called without any arguments, list() produces the same result as [].", "abstract": ""}, {"id": 58983284, "score": 3, "vote": 0, "content": "When you do list(list()) you are creating a list and convert it to a list on the fly. Therefore, you end up with a single empty list, not a nested list. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/48003739/why-list-is-listlist-is-false-in-python", "keywords": [], "tags": ["python", "python-3.x", "list", "identity"], "question": {"id": 48003739, "title": "Why &#39;list is list(list)&#39; is false in python?", "content": "It gives True, where as, gives False. What is the difference between these two? What python does in both statements?", "abstract": ""}, "answers": [{"id": 48003830, "score": 2, "vote": 0, "content": "list() creates a new list. The newly created list equal (==) to the original but not identical (is).", "abstract": ""}, {"id": 48003868, "score": 5, "vote": 0, "content": "== calls list.__eq__ for the two lists, which compares the contents. is compares the object references. is returning True means that both names point to the same object in memory. What the result tells you is that list always makes a shallow copy, even  if the input is another list. The reason is that list is a mutable type. You want to be able to modify one list without modifying the other, otherwise why bother calling the constructor at all? The same behavior does not happen with tuple, which is immutable. tuple(some_tuple) is some_tuple will be True.", "abstract": ""}]}]