[{"link": "https://stackoverflow.com/questions/64274278/found-2-elements-with-non-unique-id", "keywords": [], "tags": ["javascript", "html", "jquery", "bootstrap-4", "html5-video"], "question": {"id": 64274278, "title": "Found 2 elements with non-unique id", "content": "I am getting the following warnings when we use with the same id names in two different form tags. [DOM] Found 2 elements with non-unique id Here is my HTML snippet: How do I resolve \"Found 2 elements with non-unique id\" warnings?", "abstract": ""}, "answers": [{"id": 73077602, "score": 0, "vote": 0, "content": "if you are using react native web or expo pwa use nativeID in place of id", "abstract": ""}, {"id": 68166710, "score": 1, "vote": 0, "content": "You need to change de id for each input", "abstract": ""}, {"id": 64472117, "score": 0, "vote": 0, "content": "Just use new { id = \"\" } for one of the two fields:", "abstract": ""}, {"id": 64274451, "score": 7, "vote": 0, "content": "you need to change id=\"Job_Name\" to be unique e.g. id=\"Job_Name1\" id=\"Job_Name2\" etc. as ID must be unique in the DOM. It will create conflict when you want to select elements using document.getElementById('Job_Name') or using jQuery $('#Job_Name') as you wont be able to get the second  or other elements with same id. you will need to use index and querySelectorAll which will then defeat the purpose of using Id at first place.", "abstract": ""}, {"id": 64274419, "score": 1, "vote": 0, "content": "Duplicate input tag in two different forms You have to use  different id for  different elements", "abstract": ""}, {"id": 64274410, "score": 0, "vote": 0, "content": "Change the IDs on your inputs as they are what is causing your problem. As a general rule you don't want to have the same id's on any of your elements. id suggest using something along the lines of job_name1/job_name2", "abstract": ""}, {"id": 64274337, "score": 0, "vote": 0, "content": "id is an identifier that defines the identity of the element. It is designed to act like a key to the element and hence it needs to be unique. Check this answer..\nhttps://stackoverflow.com/a/2187788/8230086", "abstract": ""}, {"id": 64274319, "score": 0, "vote": 0, "content": "Becouse You mentioned the two input element with same id ('Job_Name') in same page\nYou cannot give the same id in same page to two different element", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/76132364/subsetting-table-in-r-when-ids-are-non-unique-and-values-match", "keywords": [], "tags": ["r", "group-by", "subset"], "question": {"id": 76132364, "title": "Subsetting Table in R when IDs are non-unique and Values match", "content": "I have a dataframe that contains IDs and a value. I want to subset this dataframe so that it only keeps rows that contain non-unique ID (more than 1 occurrence in the table), while the value for that ID is also the same. For Example: DF: I want the Subset to look like: I've tried to first create subsets of the table to eliminate non-unique IDs: However when I then try and subset this table again where the value is the same for the ID, I get stuck. Wondering if there's a better way to do this?", "abstract": ""}, "answers": [{"id": 76134766, "score": 0, "vote": 0, "content": "With table and subset -output", "abstract": ""}, {"id": 76132717, "score": 0, "vote": 0, "content": "If you want to use tidyr", "abstract": ""}, {"id": 76132507, "score": 0, "vote": 0, "content": "We can use subset + ave", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/9454645/does-the-id-attribute-of-an-html-element-have-to-be-unique-in-the-whole-page", "keywords": [], "tags": ["html", "css"], "question": {"id": 9454645, "title": "Does the id attribute of an HTML element have to be unique in the whole page?", "content": "I am using jQuery and I am just wondering, does ID have to be always unique in the whole page? Class, I know, can be repeated as many times as you like, what about ID?", "abstract": ""}, "answers": [{"id": 74092888, "score": 0, "vote": 0, "content": "ID must be unique - One reason for that is, that in the Browser-JavaScript-Context exists a methode: Document.getElementById() I think, this is reason enough to only use one ID per Document. Reference:\nhttps://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById", "abstract": ""}, {"id": 59232018, "score": 36, "vote": 0, "content": "Does an ID have to be unique in the whole page? Because the HTML Living Standard of March 15, 2022, clearly states: The class, id, and slot attributes may be specified on all HTML elements. \u2026\u2026.\nWhen specified on HTML elements, the id attribute value must be unique amongst all the IDs in the element\u2019s tree and must contain at least one character. The value must not contain any ASCII whitespace. and a page may have several DOM trees. It does, for example, when you\u2019ve attached (Element.attachShadow()) a shadow DOM tree to an element.  Does an ID have to be unique in the whole page? No. Does an ID have to be unique in a DOM tree? Yes.", "abstract": ""}, {"id": 71132769, "score": 0, "vote": 0, "content": "The reference with all browsers these days? Makes div possible in such terms of being used multiple times. There is no rule that it must be unique. When all browsers understand: When you add new style CSS codes you have the possibility to use the addition of styles. Since that even is not supposed to be unique it describes the opposite use, so make more styles but do not make more objects? And as you can; assign several div objects, so why didn't they tell you that class must be unique? That's because the class does not need unique value. And that makes the ID in legal terms obsolete if not being unique. \"When there is no rule when a rule is said. Then the rule is not fulfilled. It's not inherent to exist. By only in the illusion of all rules that it should have existed only to make life much harder.\" Just because some people say div must be unique, this might be right, but at least through their professional perspective to say it, they have to say it. Unless they didn't check the modern browsers, which from nearly the beginning were able to understand the code of several different div objects with the same style.", "abstract": ""}, {"id": 69585153, "score": 0, "vote": 0, "content": "I'm adding to this question, because I feel it has not been answered adequately in any of the above, As a point reference: I've implemented non-unique id's, and all works just fine (across all browsers). Importantly, when coding, I've not run into any css logic errors, which is where the rubber hits the road (IMO) on this question. Have also not run into any conflicts in js (as one can glean out id's in context with classes) So, why do id's have to be unique? Obvious answer (as stated and re-stated above) is 'cause the 'standards' say so. The missing part for me is why? i.e. what actually goes awry (or could theoretically go awry) if (heaven forbid) someone inadvertently used the same id twice?", "abstract": ""}, {"id": 9454716, "score": 74, "vote": 0, "content": "Yes, it must be unique. HTML4: https://www.w3.org/TR/html4/struct/global.html#h-7.5.2 Section 7.5.2: id = name [CS]\n      This attribute assigns a name to an element. This name must be unique in a document. HTML5: https://www.w3.org/TR/html5/dom.html#element-attrdef-global-id The id attribute specifies its element's unique identifier (ID). The\n  value must be unique amongst all the IDs in the element's home subtree\n  and must contain at least one character. The value must not contain\n  any space characters.", "abstract": ""}, {"id": 48980618, "score": 8, "vote": 0, "content": "Technically, by HTML5 standards ID must be unique on the page - https://developer.mozilla.org/en/DOM/element.id But I've worked on extremely modular websites, where this is completely ignored and it works. And it makes sense - the most surprising part. We call it \"componentization\" For example, you might have a component on your page, which is some kind of widget. It has stuff inside with their own unique IDs eg \"ok-button\" Once there are many of these widgets on the page, you technically have invalid HTML. But it makes perfect sense to componentize your widgets so that they each, internally, reference their own ok button eg if using jquery to search from it's own root it might be: $widgetRoot.find(\"#ok-button\") This works for us, though technically IDs shouldn't be used at all, once they're not unique. As cited above, even YouTube does it, so it's not so renegade.", "abstract": ""}, {"id": 48239510, "score": 5, "vote": 0, "content": "Jan 2018, here is Youtube HTML , you can see id=\"button\" id=\"info\" are duplicated. ", "abstract": ""}, {"id": 36775147, "score": 1, "vote": 0, "content": "There are great answers for the same question at https://softwareengineering.stackexchange.com/questions/127178/two-html-elements-with-same-id-attribute-how-bad-is-it-really. One tidbit not mentioned above is that if there are several identical ids one the same page (which happens, even though it violates the standard): If you have to work around this (that's sad), you can use $(\"*#foo\") which will convince jQuery to use getElementsByTagName and return a list of all matched elements.", "abstract": ""}, {"id": 9454784, "score": 2, "vote": 0, "content": "With Javascript, you can only reference to one element using ID. document.getElementById and jQuery's $ selector will return only the first element matching. So it doesn't make sense using the same ID on multiple elements.", "abstract": ""}, {"id": 9454722, "score": 6, "vote": 0, "content": "Browsers used to be lenient on this (many years ago when css was young) and allow the ID to be used more than once.  They have become more strict. However, yes ID's are to be unique and only used once. If you need to use css formatting more than once use CLASS.", "abstract": ""}, {"id": 9454706, "score": 5, "vote": 0, "content": "That's basically the whole point of an ID. :) IDs are specific, can only be used once per page. Classes can be used as pleased.", "abstract": ""}, {"id": 9454699, "score": 0, "vote": 0, "content": "IDs always have to be unique.  Everybody has a unique identification number (ex. Social Security number), and there are lots of people in a social class", "abstract": ""}, {"id": 9454669, "score": 12, "vote": 0, "content": "from mdn \nhttps://developer.mozilla.org/en/DOM/element.id so i guess it better be...", "abstract": ""}, {"id": 9454662, "score": 0, "vote": 0, "content": "Yes, IDs are unique. Class are not.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/58177734/understanding-python-id-uniqueness", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 58177734, "title": "understanding python id() uniqueness", "content": "Python documentation for id() function states the following: This is an integer which is guaranteed to be unique and constant for\n  this object during its lifetime. Two objects with non-overlapping \n  lifetimes may have the same id() value. CPython implementation detail: This is the address of the object in memory. Although, the snippet below shows that id's are repeated. Since I didn't explicitly del the objects, I presume they are all alive and unique (I do not know what non-overlapping means). How can the id values for different objects be the same? Is it so because the value 0 (object of class int) is a constant and the interpreter/C compiler optimizes? If I were to do a = c, then I understand c to have the same id as a since c would just be a reference to a (alias). I expected the objects a and c to have different id values otherwise, but, as shown above, they have the same values. What's happening? Or am I looking at this the wrong way? I would expect the id's for user-defined class' objects to ALWAYS be unique even if they have the exact same member values. Could someone explain this behavior? (I looked at the other questions that ask uses of id(), but they steer in other directions) EDIT (09/30/2019): TO extend what I already wrote, I ran python interpreters in separate terminals and checked the id's for 0 on all of them, they were exactly the same (for the same interpreter); multiple instances of different interpreters had the same id for 0. Python2 vs Python3 had different values, but the same Python2 interpreter had same id values. My question is because the id()'s documentation doesn't state any such optimizations, which seems misleading (I don't expect every quirk to be noted, but some note alongside the CPython note would be nice)... EDIT 2 (09/30/2019): The question is stemmed in understanding this behavior and knowing if there are any hooks to optimize user-define classes in a similar way (by modifying the __equals__ method to identify if two objects are same; perhaps the would point to the same address in memory i.e. same id? OR use some metaclass properties)", "abstract": ""}, "answers": [{"id": 58177777, "score": 6, "vote": 0, "content": "Ids are guaranteed to be unique for the lifetime of the object. If an object gets deleted, a new object can acquire the same id. CPython will delete items immediately when their refcount drops to zero. The garbage collector is only needed to break up reference cycles. CPython may also cache and re-use certain immutable objects like small integers and strings defined by literals that are valid identifiers. This is an implementation detail that you should not rely upon. It is generally considered improper to use is checks on such objects. There are certain exceptions to this rule, for example, using an is check on possibly-interned strings as an optimization before comparing them with the normal == operator is fine. The dict builtin uses this strategy for lookups to make them faster for identifiers. If the string happens to be interned, then the above can return true with a simple id comparison instead of a slower character-by-character comparison, but it still returns true if and only if a == b (because if a is b then a == b must also be true). However, a good implementation of .__eq__() would already do an is check internally, so at best you would only avoid the overhead of calling the .__eq__(). Thanks for the answer, would you elaborate around the uniqueness for user-defined objects, are they always unique? The id of any object (be it user-defined or not) is unique for the lifetime of the object. It's important to distinguish objects from variables. It's possible to have two or more variables refer to the same object. Caching optimizations mean that you are not always guaranteed to get a new object in cases where one might naiively think one should, but this does not in any way violate the uniqueness guarantee of IDs. Builtin types like int and str may have some caching optimizations, but they follow exactly the same rules: If they are live at the same time, and their IDs are the same, then they are the same object.  Caching is not unique to builtin types. You can implement caching for your own objects. Even user-defined classes can cache instances. For example, this class only makes one instance of itself. Note that each construction expression evaluates to an object with the same id as the other. But this id is unique to the object. Both expressions reference the same object, so of course they have the same id. The above class only keeps one instance, but you could also cache some other number. Perhaps recently used instances, or those configured in a way you expect to be common (as ints do), etc.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/20753364/why-is-the-id-of-a-python-class-not-unique-when-called-quickly", "keywords": [], "tags": ["python", "class", "python-3.x"], "question": {"id": 20753364, "title": "Why is the id of a Python class not unique when called quickly?", "content": "I'm doing some things in Python (3.3.3), and I came across something that is confusing me since to my understanding classes get a new id each time they are called. Lets say you have this in some .py file: The above returns the same id which is confusing me since I'm calling on it so it shouldn't be the same, right? Is this how Python works when the same class is called twice in a row or not? It gives a different id when I wait a few seconds but if I do it at the same like the example above it doesn't seem to work that way, which is confusing me. It returns the same thing, but why? I also notice it with ranges for example Is there any particular reason for Python doing this when the class is called quickly? I didn't even know Python did this, or is it possibly a bug? If it is not a bug can someone explain to me how to fix it or a method so it generates a different id each time the method/class is called? I'm pretty puzzled on how that is doing it because if I wait, it does change but not if I try to call the same class two or more times.", "abstract": ""}, "answers": [{"id": 20753425, "score": 52, "vote": 0, "content": "The id of an object is only guaranteed to be unique during that object's lifetime, not over the entire lifetime of a program. The two someClass objects you create only exist for the duration of the call to print - after that, they are available for garbage collection (and, in CPython, deallocated immediately). Since their lifetimes don't overlap, it is valid for them to share an id.  It is also unsuprising in this case, because of a combination of two CPython implementation details: first, it does garbage collection by reference counting (with some extra magic to avoid problems with circular references), and second, the id of an object is related to the value of the underlying pointer for the variable (ie, its memory location). So, the first object, which was the most recent object allocated, is immediately freed - it isn't too surprising that the next object allocated will end up in the same spot (although this potentially also depends on details of how the interpreter was compiled).  If you are relying on several objects having distinct ids, you might keep them around - say, in a list - so that their lifetimes overlap. Otherwise, you might implement a class-specific id that has different guarantees - eg:", "abstract": ""}, {"id": 20753390, "score": 3, "vote": 0, "content": "Try this, try calling the following: You'll see something different. Why? Cause the memory that was released by the first object in the \"foo\" loop was reused. On the other hand a is not reused since it's retained.", "abstract": ""}, {"id": 20766581, "score": 0, "vote": 0, "content": "A example where the memory location (and id) is not released is: Now the ids are all unique.", "abstract": ""}, {"id": 20753450, "score": 15, "vote": 0, "content": "If you read the documentation for id, it says: Return the \u201cidentity\u201d of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. And that's exactly what's happening: you have two objects with non-overlapping lifetimes, because the first one is already out of scope before the second one is ever created. But don't trust that this will always happen, either. Especially if you need to deal with other Python implementations, or with more complicated classes. All that the language says is that these two objects may have the same id() value, not that they will. And the fact that they do depends on two implementation details: The garbage collector has to clean up the first object before your code even starts to allocate the second object\u2014which is guaranteed to happen with CPython or any other ref-counting implementation (when there are no circular references), but pretty unlikely with a generational garbage collector as in Jython or IronPython. The allocator under the covers have to have a very strong preference for reusing recently-freed objects of the same type. This is true in CPython, which has multiple layers of fancy allocators on top of basic C malloc, but most of the other implementations leave a lot more to the underlying virtual machine. One last thing: The fact that the object.__repr__ happens to contain a substring that happens to be the same as the id as a hexadecimal number is just an implementation artifact of CPython that isn't guaranteed anywhere. According to the docs: If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). If this is not possible, a string of the form <...some useful description\u2026> should be returned. The fact that CPython's object happens to put hex(id(self)) (actually, I believe it's doing the equivalent of sprintf-ing its pointer through %p, but since CPython's id just returns the same pointer cast to a long that ends up being the same) isn't guaranteed anywhere. Even if it has been true since\u2026 before object even existed in the early 2.x days. You're safe to rely on it for this kind of simple \"what's going on here\" debugging at the interactive prompt, but don't try to use it beyond that.", "abstract": ""}, {"id": 20753451, "score": 4, "vote": 0, "content": "I sense a deeper problem here. You should not be relying on id to track unique instances over the lifetime of your program. You should simply see it as a non-guaranteed memory location indicator for the duration of each object instance. If you immediately create and release instances then you may very well create consecutive instances in the same memory location. Perhaps what you need to do is track a class static counter that assigns each new instance with a unique id, and increments the class static counter for the next instance.", "abstract": ""}, {"id": 20753379, "score": 3, "vote": 0, "content": "It's releasing the first instance since it wasn't retained, then since nothing has happened to the memory in the meantime, it instantiates a second time to the same location.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52096582/how-unique-is-pythons-id", "keywords": [], "tags": ["python", "python-3.x", "unit-testing", "memory"], "question": {"id": 52096582, "title": "How unique is Python&#39;s id()?", "content": "tl;dr\nDoes Python reuse ids? How likely it is that two objects with non overlapping lifetime will get the same id? Background:\nI've been working on a complex project, written purely in Python 3. I've been seeing some issues in testing and spent a lot of time searching for a root cause. After some analysis, my suspicion was that when the testing is being run as a whole (it's orchestrated and being run by a dedicated dispatcher) it's reusing some mocked methods instead of instatiating new objects with their original methods. To check if the interpreter is reusing I used id(). Problem:\nid() usually works and shows the object identifier and lets me tell when my call is creating a new instance and not reusing. But what happens when ids if two objects are the same? The documentation says: Return the \u201cidentity\u201d of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. The questions: When can the interpreter reuse id() values? Is it just when it randomly selects the same memory area? If it's just random, it seems extremely unlikely but it's still not guaranteed. Is there any other method to check what object I am actually referencing? I encountered a situation where I had the object, it had a mocked method. The object was no longer used, garbage collector destroyed it. After that I create a new object of the same class, it got a new id() but the method got the same id as when it was mocked and it actually was just a mock. Is there a way to force Python to destroy the given object instance? From the reading I did it appears that no and that it is up to a garbage collector when it sees no references to the object but I thought it's worth asking anyway.", "abstract": ""}, "answers": [{"id": 52181584, "score": 32, "vote": 0, "content": "Yes, CPython re-uses id() values. Do not count on these being unique in a Python program. This is clearly documented: Return the \u201cidentity\u201d of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. Bold emphasis mine. The id is unique only as long as an object is alive. Objects that have no references left to them are removed from memory, allowing the id() value to be re-used for another object, hence the non-overlapping lifetimes wording. Note that this applies to CPython only, the standard implementation provided by python.org. There are other Python implementations, such as IronPython, Jython and PyPy, that make their own choices about how to implement id(), because they each can make distinct choices on how to handle memory and object lifetimes. To address your specific questions: In CPython, id() is the memory address. New objects will be slotted into the next available memory space, so if a specific memory address has enough space to hold the next new object, the memory address will be reused. You can see this in the interpreter when creating new objects that are the same size: The 1234 literal creates a new integer object, for which id() produces a numeric value. As there are no further references to the int value, it is removed from memory again. But executing the same expression again with a different integer literal, and chances are you'll see the same id() value (a garbage collection run breaking cyclic references could free up more memory, so you could also not see the same id() again. So it's not random, but in CPython it is a function of the memory allocation algorithms. If you need to check specific objects, keep your own reference to it. That can be a weakref weak reference if all you need to assure is that the object is still 'alive'. For example, recording an object reference first, then later checking it: The weak reference won't keep the object alive, but if it is alive then the object_ref() will return it (it'll return None otherwise). You could use such a mechanism to generate really unique identifiers, see below. All you have to do to 'destroy' an object is to remove all references to it. Variables (local and global) are references. So are attributes on other objects, and entries in containers such as lists, tuples, dictionaries, sets, etc. The moment all references to an object are gone, the reference count on the object drops to 0 and it is deleted, there and then. Garbage collection only is needed to break cyclic references, objects that reference one another only, with no further references to the cycle. Because such a cycle will never reach a reference count of 0 without help, the garbage collector periodically checks for such cycles and breaks one of the references to help clear those objects from memory. So you can cause any object to be deleted from memory (freed), by removing all references to it. How you achieve that depends on how the object is referenced. You can ask the interpreter to tell you what objects are referencing a given object with the gc.get_referrers() function, but take into account that doesn't give you variable names. It gives you objects, such as the dictionary object that is the __dict__ attribute of a module that references the object as a global, etc. For code fully under your control, at most use gc.get_referrers() as a tool to remind yourself what places the object is referenced from as you write the code to remove those. If you must have unique identifiers for the lifetime of the Python application, you'd have to implement your own facility. If your objects are hashable and support weak references, then you could just use a WeakKeyDictionary instance to associate arbitrary objects with UUIDs: This still produces integers, but as they are UUIDs they are not quite guaranteed to be unique, but the likelihood you'll ever encounter the same ID during your lifetime are smaller than being hit by a meteorite. See How unique is UUID? This then gives you unique ids even for objects with non-overlapping lifetimes:", "abstract": ""}, {"id": 52096694, "score": 3, "vote": 0, "content": "It can reuse the id value as soon as the object which had it is no longer in any scope. It is in fact likely to reuse it if you create a similar object immediately after destroying the first.  If you're holding a reference (as opposed to a weak reference), the id is not reused because the object is still alive. If you're just holding the id value, you're probably doing something wrong.  No, but you could delete your reference and request the garbage collector to run. It's possible for the garbage collection to fail to collect that object even if there are no really live references. ", "abstract": ""}, {"id": 52096647, "score": 3, "vote": 0, "content": "The id is unique among currently existing objects. If an object is removed by the garbage collector, a future object can have the same id (and most probably will). You have to use your own unique value (eg. some uuid) to be sure that you are refering to a specific object. You can't do the garbage collection manually either.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/49864807/how-to-properly-correct-this-found-elements-with-non-unique-id-errors", "keywords": [], "tags": ["php", "laravel"], "question": {"id": 49864807, "title": "How to properly correct this found elements with non-unique id errors?", "content": "I have this form for a user to introduce some data to register in a congress.  First he needs to introduce some buyer information, then if there is some paid ticket type also some billing information. Then if the congress table has the column \"collect_data_from_all_participants\" as 1 the usre also needs to introduce information for each selected ticket type. This information for each ticket type is the name and surname of each participant so I have the name of the field \"Name\" as \"name\" and the field \"Surname\" with the name \"surname\". T he issue is then in the console it appears : Do you know what is the best approach to correct the issue?", "abstract": ""}, "answers": [{"id": 49864918, "score": 3, "vote": 0, "content": "The id on elements must be unique.  You have several elements using the same id (name, surname).  You can either remove the id or change the id's so they are unique.  If you have related code (CSS, JS, etc) that refers to the id's, you'll need to update that as well. It's common to use a class instead of an id for elements that need to be targeted by other code.  This reduces the amount of work to create or maintain unique id's.", "abstract": ""}, {"id": 49864847, "score": 5, "vote": 0, "content": "Your problem is that all id attributes must be unique for a single document. From MDN: The id global attribute defines a unique identifier (ID) which must be unique in the whole document. Its purpose is to identify the element when linking (using a fragment identifier), scripting, or styling (with CSS). You are looping over <input> elements with id name and surname which causes multiple elements with the same id. If you remove the ids from these input elements, your warnings will go away.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/3405351/jquery-basic-selector-usage-and-non-unique-element-id", "keywords": [], "tags": ["jquery", "jquery-selectors"], "question": {"id": 3405351, "title": "JQuery basic selector usage and non unique element ID", "content": "I'am maintaining a GUI built using JQuery. In one part of the GUI,\nmultiple tabs can be opened to edit data. When a new tab is opened, it is created by cloning the first tab content div and\nupdating the input fields in the div. The new tab is given a unique ID based on the tab index, but all\nother ID's within the cloned tab div are the same as the original tab div. Now, that seems to cause problems since ID's are not unique any\nmore. When selecting an input field the following works on Firefox 3.6.8: This selects the tab div with ID tabs-2 and then selects the input\nfield within that div with the ID scriptName and sets its value. Now\nthis does not work on Chrome or Firefox 3.0.19. The DOM hierachy looks something like this One solution would be to make all ID's wihtin the cloned tab content\ndiv unique, but that seems like a brute force aproach. It must be\npossible to address the content within a div in a more independent way\nwithout require a unique ID. The cloning of the whole div when generating a new tab is of course a\ncrude hack, a more elegant solution would be to reuse the same div but\nchange the content depending on the selected tab, but that is how it\nis built right now and unfortunately it was developed and tested using a later\nfirefox browser where this selector worked. Pre-post EDIT I found a lot of related questions with answers that gave some hints on how to solve this, when I inserted my offline-edited question, but I post this question anyway since good suggestions for how to solve this are always welcome. EDIT I'am trying the class approach right now, I do have one problem though, some input fields uses labels with for attribute, the for attribute must point to a unique id. But that can be solved by omitting the for attribute and make the input field a nested element instead.", "abstract": ""}, "answers": [{"id": 37588495, "score": 0, "vote": 0, "content": "I have a AngularJS app where I ran into the same problem when ng-repeating elements. Heres how I solved it. Your tabs, the parent element, have unique ID's right? So just go down the children of that tab. Snipit from my div-windows to get children for resizable parent and alsoResize (or manualy resize as in my case) the children. Hint: I just left the IDs out of the children. $scope.panes[] is my window array, I just grab the ID and each out the children: Another solution would be to built the whole tab as a string and innerHTML it to the page. This way you can do someting like this with the ids: (again my div-window example)", "abstract": ""}, {"id": 3405477, "score": 0, "vote": 0, "content": "I don't know will it helps in your case but you can try .find() jQuery method. Try something like this expression:", "abstract": ""}, {"id": 3405409, "score": 2, "vote": 0, "content": "just a suggestion, can you make id of the input as class? So that you don't have a problem when cloning. and your code would be something like, $('#tabs-2 .scriptName').val( data.name );", "abstract": ""}, {"id": 3405405, "score": 1, "vote": 0, "content": "ID's are unique identifiers.  The moment you introduce a duplicate id, you have an invalid document on your hands. The best way to get around this is to refrain from using id's on anything that is going to be cloned.  Instead, use a \"unique\" class name to identify the element.  Then, when it is cloned, you can walk down the DOM to each copy of the class.  jQuery has very good DOM traversal methods for this. http://api.jquery.com/category/traversing/ Additionally: .children(), .parent(), .parents(), and .siblings() are particularly useful.  I'd stay away from .find() unless it cannot be helped.  .find() can be slow if you are searching through many, many nodes in the DOM.  Since you're building an interface, this might be the case.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/18136071/jquery-find-next-dom-element-by-id-where-id-is-not-unique", "keywords": [], "tags": ["jquery", "html", "knockout.js"], "question": {"id": 18136071, "title": "JQuery find next DOM element by id where Id is not UNIQUE", "content": "This is doing my head in, I can't seem to find the dom element I need to find I have tried next/closest/find and just can't seem to the div.  The code is very self explanatory. The line $(this).parent().siblings(\"div\").find(\"#accounts\").slideToggle(500); will not get me the div called accounts.", "abstract": ""}, "answers": [{"id": 18136307, "score": 0, "vote": 0, "content": "There is wrong here: Here you are trying to find \"accounts\" DOM under the $(this).parent().siblings(\"div\"), actually it can't find it. So You can do it like this: $(this).parent().siblings(\"div#accounts\").slideToggle(500); or if you know the ID, you can directly code as: $(\"#accounts\").slideToggle(500); It is more effective.", "abstract": ""}, {"id": 18136195, "score": 1, "vote": 0, "content": "ID's must be unique or else you will get broken/undefined behavior when querying the DOM. Change toggle and accounts to classes instead.  Siblings() will return you a list of all siblings of the parent of toggle. Note that accounts is one of those siblings. When you call find('.accounts'), jQuery is looking for descendants of those siblings, so it will never find accounts. Instead, just use accounts as the filter in your siblings() call: Working Demo", "abstract": ""}, {"id": 18136228, "score": 0, "vote": 0, "content": "Try this: $('#accounts', $(this).parent().siblings(\"div\"))", "abstract": ""}, {"id": 18136220, "score": 1, "vote": 0, "content": "While this could work you really should change your html to avoid duplicated ids as that's not valid and causes troubles when using id selectors as you already noticed", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/15878441/java-sql-sqlexception-column-id-is-not-unique", "keywords": [], "tags": ["java", "sqlite", "sqlexception"], "question": {"id": 15878441, "title": "java.sql.SQLException: column id is not unique", "content": "I have a program written in Java which parses a set of files and places information about them inside a database using sqlite. The code seems to work fine for a while until one day I get this Exception: As it turned out, two of the files were somehow interfering with each other in my code. I have constructed a smaller program which still gives the same problem. My current maven dependency information. So am I doing something wrong and why does this work for most strings but not all? Is the uniqueness calculated in a non straightforward manner?", "abstract": ""}, "answers": [{"id": 15891955, "score": 0, "vote": 0, "content": "It seems like the issue was related to using the wrong datatype, it should have been TEXT instead of STRING. From sqlite documentation: Note that a declared type of \"FLOATING POINT\" would give INTEGER affinity, not REAL affinity, due to the \"INT\" at the end of \"POINT\". And the declared type of \"STRING\" has an affinity of NUMERIC, not TEXT. So the string \"111111111E311\" will be considered an OK number but is too large and what's put in the entry is NaN. The string \"111111111E211\" is slightly smaller and can be stored as it is.", "abstract": ""}, {"id": 15878508, "score": 2, "vote": 0, "content": "since you have applied UNIQUE constraint on id column, it will give error if you try to insert any existing value in column id", "abstract": ""}]}]