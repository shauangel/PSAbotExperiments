[{"link": "https://stackoverflow.com/questions/647769/why-cant-pythons-raw-string-literals-end-with-a-single-backslash", "keywords": [], "tags": ["python", "string", "literals", "rawstring"], "question": {"id": 647769, "title": "Why can&#39;t Python&#39;s raw string literals end with a single backslash?", "content": "Technically, any odd number of backslashes, as described in the documentation. It seems like the parser could just treat backslashes in raw strings as regular characters (isn't that what raw strings are all about?), but I'm probably missing something obvious.", "abstract": ""}, "answers": [{"id": 75557735, "score": 0, "vote": 0, "content": "Given the confusion around the arbitrary-seeming restriction against an odd number of backslashes at the end of a Python raw-string, it's fair to say that this is a design mistake or legacy issue originating in a desire to have a simpler parser. While workarounds (such as r'C:\\some\\path' '\\\\' yielding 'C:\\\\some\\\\path\\\\' (in Python notation) or C:\\some\\path\\ (verbatim)) are simple, it's counterintuitive to be needing them. For comparison, let's have a look at C++ and Perl. In C++, we can straightforwardly use raw string literal syntax to get the following output: If we want to use the closing delimiter (above: )) within the string literal, we can even extend the syntax in an ad-hoc way to R\"delimiterString(quotedMaterial)delimiterString\". For example, R\"asdf(some random delimiters: ( } [ ] { ) < > just for fun)asdf\" produces the string some random delimiters: ( } [ ] { ) < > just for fun in the output. (Ain't that a good use of \"asdf\"!) In Perl, this code will output the following: This is a test.\\This is another test. Replacing the first line by would lead to an error message: Can't find string terminator \"}\" anywhere before EOF at main.pl line 1. However, Perl treating a pre-delimiter \\ as an escape character doesn't prevent the user from having an odd number of backslashes at the end of the resulting string; eg to place 3 backslashes \\\\\\ into the end of $str, simply end the code with 6 backslashes: my $str = q{This is a test.\\\\\\\\\\\\};. Importantly, while we need to double the backslashes in the input, there is no Python-like inconsistent-seeming syntactic restriction. Another way of looking at things is that these 3 languages use different ways to address the parsing issue of interaction between escape characters and closing delimiters: \u00b9 The custom delimiterString itself cannot be more than 16 characters long, but that's hardly a limitation. \u00b2 If you need the delimiter itself, just escape it with \\. However, to be fair in a comparison to Python, we need to acknowledge that (1) C++ didn't have such string literals until C++11 and is famously hard to parse and (2) Perl is even harder to parse.", "abstract": ""}, {"id": 73234067, "score": 1, "vote": 0, "content": "The naive idea of a raw string is If I put an r in front of a pair of quotes,\nI can put whatever I want between the quotes\nand it will mean itself. Unfortunately, this does not work, because if the whatever\nhappens to contain a quote, the raw string would end at that point. It is simply impossible that I can put \"whatever I want\"\nbetween fixed delimiters, because some of it could look like\nthe terminating delimiter -- no matter what that delimiter is. One possible approach to this problem would be to say If I put an r in front of a pair of quotes,\nI can put whatever I want between the quotes\nas long as it does not contain a quote\nand it will mean itself. This restriction sounds harsh, until one recognizes that\nPython's large offering of quotes can accommodate most situations\nwith this rule. The following are all valid Python quotes: With this many possibilities for the delimiter, almost anything\ncan be made to work.\nAbout the only exception would be if the string\nliteral is supposed to contain a complete list of all allowed\nPython quotes. Python, however, takes a different route using\nan extended version of the above rule.\nIt effectively states If I put an r in front of a pair of quotes,\nI can put whatever I want between the quotes\nas long as it does not contain a quote\nand it will mean itself.\nIf I insist on including a quote, even that is allowed,\nbut I have to put a backslash before it. So the Python approach is, in a sense, even more liberal\nthan variant 1 above -- but it has the side effect of\n\"mis\"interpreting the closing quote as part of the string\nif the last intended character of the string is a backslash. Variant 2 is not helpful: After writing this, I go with several of the other posters\nthat variant 1 would have been easier to understand and to accept\nand therefore more pythonic. That's life!", "abstract": ""}, {"id": 5830053, "score": 29, "vote": 0, "content": "In order for you to end a raw string with a slash I suggest you can use this trick: It uses the implicit concatenation of string literals in Python and concatenates one string delimited with double quotes with another that is delimited by single quotes. Ugly, but works.", "abstract": ""}, {"id": 19654184, "score": 175, "vote": 0, "content": "The whole misconception about python's raw strings is that most of people think that backslash (within a raw string) is just a regular character as all others. It is NOT. The key to understand is this python's tutorial sequence: When an 'r' or 'R' prefix is present, a character following a\n  backslash is included in the string without change, and all\n  backslashes are left in the string So any character following a backslash is part of raw string. Once parser enters a raw string (non Unicode one) and encounters a backslash it knows there are 2 characters (a backslash and a char following it). This way: r'abc\\d' comprises a, b, c, \\, d r'abc\\'d' comprises a, b, c, \\, ', d r'abc\\'' comprises a, b, c, \\, ' and: r'abc\\' comprises a, b, c, \\, ' but there is no terminating quote now. Last case shows that according to documentation now a parser cannot find closing quote as the last quote you see above is part of the string i.e. backslash cannot be last here as it will 'devour' string closing char.", "abstract": ""}, {"id": 52739136, "score": -2, "vote": 0, "content": "I encountered this problem and found a partial solution which is good for some cases. Despite python not being able to end a string with a single backslash, it can be serialized and saved in a text file with a single backslash at the end. Therefore if what you need is saving a text with a single backslash on you computer, it is possible: BTW it is not working with json if you dump it using python's json library.  Finally, I work with Spyder, and I noticed that if I open the variable in spider's text editor by double clicking on its name in the variable explorer, it is presented with a single backslash and can be copied to the clipboard that way (it's not very helpful for most needs but maybe for some..). ", "abstract": ""}, {"id": 48031528, "score": 0, "vote": 0, "content": "Despite its role, even a raw string cannot end in a single\n  backslash, because the backslash escapes the following quote\n  character\u2014you still must escape the surrounding quote character to\n  embed it in the string.  That is, r\"...\\\" is not a valid string\n  literal\u2014a raw string cannot end in an odd number of backslashes.\n  If you need to end a raw string with a single backslash, you can use\n  two and slice off the second.", "abstract": ""}, {"id": 7986539, "score": 17, "vote": 0, "content": "Another trick is to use chr(92) as it evaluates to \"\\\".  I recently had to clean a string of backslashes and the following did the trick: I realize that this does not take care of the \"why\" but the thread attracts many people looking for a solution to an immediate problem.", "abstract": ""}, {"id": 648671, "score": 0, "vote": 0, "content": "some tips : 1) if you need to manipulate backslash for path then standard python module os.path is your friend. for example :  os.path.normpath('c:/folder1/') 2) if you want to build strings with backslash in it BUT without backslash at the END of your string then raw string is your friend (use 'r' prefix before your literal string). for example :  3) if you need to prefix a string in a variable X with a backslash then you can do this : 4) if you need to create a string with a backslash at the end then combine tip 2 and 3 : now lilypond_statement contains \"\\DisplayLilyMusic \\upper\" long live python ! :) n3on", "abstract": ""}, {"id": 648168, "score": 0, "vote": 0, "content": "Comming from C it pretty clear to me that a single \\ works as escape character allowing you to put special characters such as newlines, tabs and quotes into strings. That does indeed disallow \\ as last character since it will escape the \" and make the parser choke. But as pointed out earlier \\ is legal.", "abstract": ""}, {"id": 648135, "score": 9, "vote": 0, "content": "Since \\\" is allowed inside the raw string.  Then it can't be used to identify the end of the string literal.  Why not stop parsing the string literal when you encounter the first \"? If that was the case, then \\\" wouldn't be allowed inside the string literal.  But it is.", "abstract": ""}, {"id": 647877, "score": 2, "vote": 0, "content": "Another user who has since deleted their answer (not sure if they'd like to be credited) suggested that the Python language designers may be able to simplify the parser design by using the same parsing rules and expanding escaped characters to raw form as an afterthought (if the literal was marked as raw). I thought it was an interesting idea and am including it as community wiki for posterity.", "abstract": ""}, {"id": 647797, "score": 32, "vote": 0, "content": "That's the way it is! I see it as one of those small defects in python! I don't think there's a good reason for it, but it's definitely not parsing; it's really easy to parse raw strings with \\ as a last character. The catch is, if you allow \\ to be the last character in a raw string then you won't be able to put \" inside a raw string. It seems python went with allowing \" instead of allowing \\ as the last character. However, this shouldn't cause any trouble. If you're worried about not being able to easily write windows folder pathes such as c:\\mypath\\ then worry not, for, you can represent them as r\"C:\\mypath\", and, if you need to append a subdirectory name, don't do it with string concatenation, for it's not the right way to do it anyway! use os.path.join", "abstract": ""}, {"id": 647774, "score": 4, "vote": 0, "content": "The reason for why r'\\' is syntactical incorrect is that although the string expression is raw the used quotes (single or double) always have to be escape since they would mark the end of the quote otherwise. So if you want to express a single quote inside single quoted string, there is no other way than using \\'. Same applies for double quotes. But you could use:", "abstract": ""}, {"id": 647787, "score": 160, "vote": 0, "content": "The reason is explained in the part of that section which I highlighted in bold: String quotes can be escaped with a\n  backslash, but the backslash remains\n  in the string; for example, r\"\\\"\" is a\n  valid string literal consisting of two\n  characters: a backslash and a double\n  quote; r\"\\\" is not a valid string\n  literal (even a raw string cannot end\n  in an odd number of backslashes).\n  Specifically, a raw string cannot end\n  in a single backslash (since the\n  backslash would escape the following\n  quote character). Note also that a\n  single backslash followed by a newline\n  is interpreted as those two characters\n  as part of the string, not as a line\n  continuation. So raw strings are not 100% raw, there is still some rudimentary backslash-processing.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71459877/force-odd-number-of-backslashes-in-dictionary", "keywords": [], "tags": ["python", "string", "dictionary", "backslash"], "question": {"id": 71459877, "title": "Force odd number of backslashes in dictionary", "content": "I am specifically looking to print this in the terminal {'Name': '[{\\\\\\\"test\\\\\\\\\":\\\\\\\"somedata\\\\\\\"}]'} So far I can get 2 slashes or 4 slashes but I am not sure how to three slashes. I tried doing replace('\"','\\\\\\\"') I tried doing replace('\"','\\\\\\\\\"') I tried doing replace('\"',r'\\\"') I tried doing replace('\"',r'\\\"') I googled as much as I could and came to the conclusion that raw strings can't have an odd number of backslashes https://note.nkmk.me/en/python-raw-string-escape/#:~:text=source%3A%20raw_string_escape.py-,Raw%20strings%20cannot%20end%20with%20an%20odd%20number%20of%20backslashes,the%20end%20of%20the%20string. but I am not sure if there is a work around for this? https://stackoverflow.com/a/22792332 Odd or even number of backslashes and escaped character edit: I tried using unicode as @TDG mention but it still came out as 3 slashes", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/60042170/r-prefix-in-python", "keywords": [], "tags": ["python", "string"], "question": {"id": 60042170, "title": "r prefix in python", "content": "When an 'r' or 'R' prefix is present, a character following a backslash is included in the string without change, and all backslashes are left in the string. For example, the string literal r\"\\n\" consists of two characters: a backslash and a lowercase 'n'. String quotes can be escaped with a backslash, but the backslash remains in the string; for example, r\"\\\"\" is a valid string literal consisting of two characters: a backslash and a double quote; r\"\\\" is not a valid string literal (even a raw string cannot end in an odd number of backslashes). Specifically, a raw string cannot end in a single backslash (since the backslash would escape the following quote character). Note also that a single backslash followed by a newline is interpreted as those two characters as part of the string, not as a line continuation. Source: Python string literals This confused me because the r prefix only seems to work on the n as given in the example. The code I was confused about: Doesn't having the r prefix at the beginning of the regex mean that the backslashes do not escape the letter w, giving it a special meaning (i.e.  alphanumeric character)?\nthe result is :['one']", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/58254234/how-does-python-interpret-backslash-in-string", "keywords": [], "tags": ["python"], "question": {"id": 58254234, "title": "How does Python interpret backslash in string?", "content": "Although I noticed the pattern but how does the backslash work in string theoretically?  output: '@#2_#]&*^%$\\\\]' output: '@#2_#]&*^%$\\\\]' output: '@#2_#]&*^%$\\\\\\\\]'", "abstract": ""}, "answers": [{"id": 58254632, "score": 1, "vote": 0, "content": "From your follow-up comment: What puzzled me is in my example, it doesn't escape. Single backslash produces double backslashes. Double backslashes produce Double backslashes. Triple backslashes produce quadruple backslashes..... To be clear: your first output is a string with one backslash in it. Python displays two backslashes in its representation of the string. When you input the string with a single backslash, Python does not treat the sequence \\] in the input as any special escape sequence, and therefore the \\ is turned into an actual backslash in the actual string, and the ] into a closing square bracket. Quoting from the documentation linked by Klaus D.: Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., the backslash is left in the result. (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken.) When you input the string with a double backslash, the sequence \\\\ is an escape sequence for a single backslash, and then the ] is just a ]. Either way, when Python displays the string back to you, it uses \\\\ for the single actual backslash, because it does not look ahead to determine that a single backslash would work - the backslash always gets escaped. To go into a little more detail: Python doesn't care about how you specified the string in the first place - it has a specific \"normalized\" form that depends only on what the string actually contains. We can see this by playing around with the different ways to quote a string: The normalized form will use double quotes if that avoids escape sequences for single quotes: But it will switch back to single quotes if the string contains both types of quote: (Exercise: how many characters are actually in this string, and what are they? How many backslashes does the string contain?)  It contains two characters - a single-quote and a double-quote - and no backslashes.", "abstract": ""}, {"id": 58254514, "score": 0, "vote": 0, "content": "For the first pattern\n'@#2_#]&*^%$\\]'\n\\ is not escaped so in the output one more \\ is added to escape it. \nFor the second pattern\n'@#2_#]&*^%$\\\\]'\n\\ is already escaped in the pattern so no new \\ in the output.\nFor the third pattern\n'@#2_#]&*^%$\\\\\\]' first \\ is escaping the second \\ and third\n\\ is being escaped by adding one more \\ in the output. So four \\.\nHope it helps.", "abstract": ""}, {"id": 58254265, "score": 2, "vote": 0, "content": "The backslash \\ character is used to escape characters that otherwise have a special meaning, such as newline, backslash itself, or the quote character. String literals may optionally be prefixed with a letter `r' or 'R'; such strings are called raw strings and use different rules for backslash escape sequences. Unless an 'r' or 'R' prefix is present, escape sequences in strings are interpreted according to rules similar to those used by Standard C. In strict compatibility with Standard C, up to three octal digits are accepted, but an unlimited number of hex digits is taken to be part of the hex escape (and then the lower 8 bits of the resulting hex number are used in 8-bit implementations). Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., the backslash is left in the string. (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken.) When an 'r' or 'R' prefix is present, backslashes are still used to quote the following character, but all backslashes are left in the string. For example, the string literal r\"\\n\" consists of two characters: a backslash and a lowercase `n'. String quotes can be escaped with a backslash, but the backslash remains in the string; for example, r\"\\\"\" is a valid string literal consisting of two characters: a backslash and a double quote; r\"\\\" is not a value string literal (even a raw string cannot end in an odd number of backslashes). Specifically, a raw string cannot end in a single backslash (since the backslash would escape the following quote character). Note also that a single backslash followed by a newline is interpreted as those two characters as part of the string, not as a line continuation.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/30157185/python-raw-string-literals", "keywords": [], "tags": ["python", "rawstring"], "question": {"id": 30157185, "title": "Python - Raw String Literals", "content": "I don't understand how raw string literals work. I know that when using r it ignores all specials, like when doing \\n it treats it as \\n and not as a new line. but then I tried to do this: and it said SyntaxError: EOL while scanning string literal and not '\\' why? did I understanded it correctly?\nand also what is the explanation for this :", "abstract": ""}, "answers": [{"id": 30157205, "score": 6, "vote": 0, "content": "In a raw literal the backslash will escape the quote character that is defining the string. String quotes can be escaped with a backslash, but the backslash\n  remains in the string; for example, r\"\\\"\" is a valid string literal\n  consisting of two characters: a backslash and a double quote; r\"\\\" is\n  not a valid string literal (even a raw string cannot end in an odd\n  number of backslashes). Specifically, a raw string cannot end in a\n  single backslash (since the backslash would escape the following quote\n  character). Note also that a single backslash followed by a newline is\n  interpreted as those two characters as part of the string, not as a\n  line continuation. From the docs", "abstract": ""}, {"id": 30157301, "score": 7, "vote": 0, "content": "The only way to put in a single quote into a string started with a single quote is to escape it. Thus, both raw and regular string literals will allow escaping of quote characters when you have an unescaped backslash followed by a quote character. Because of the requirement that there must be a way to express single (or double) quotes inside string literals that begin with single (or double) quotes, the string literal '\\' is not legal, whether you use a raw or regular string literal. To get any arbitrary string with an odd number of literal backslashes, I believe the best way is to use regular string literals. This is because trying to use r'\\\\' will work, but it will give you a string with two backslashes instead of one: This answer is only meant to complement the other one.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/42598040/python-regex-for-matching-odd-number-of-consecutive-backslashes", "keywords": [], "tags": ["python", "regex"], "question": {"id": 42598040, "title": "Python regex for matching odd number of consecutive backslashes", "content": "I want to find all odd number of continuous backslashes. I tried the following expression: However, it matches a single backslash if present.", "abstract": ""}, "answers": [{"id": 42598925, "score": 0, "vote": 0, "content": "If you're looking for speed, this benchmarks the best:\n\\\\(?<!\\\\\\\\)(?:\\\\\\\\)*(?!\\\\)", "abstract": ""}, {"id": 42598142, "score": 3, "vote": 0, "content": "You can try this too: Explanation", "abstract": ""}, {"id": 42598070, "score": 1, "vote": 0, "content": "You may use See the regex demo. Details: Note that in Python it is a good idea to use raw string literal when using literal backslashes in a regex pattern (to reduce the number of escapes and make the pattern look tidier, and avoid any issues related to misinterpreted backslashes.)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/30283082/why-does-the-single-backslash-raw-string-in-python-cause-a-syntax-error", "keywords": [], "tags": ["python", "string", "syntax-error"], "question": {"id": 30283082, "title": "Why does the single backslash raw string in Python cause a syntax error?", "content": "Also see the Why can't I end a raw string with a backslash? and Why can't Python's raw string literals end with a single backslash? questions and related answers. In my Python 2 program I use a lot of literal strings with embedded backslashes. I could use another backslash to escape each of these backslashes (eg: \"red\\\\blue\") or use Python raw strings (eg: r\"red\\blue\"). I have standardised on the raw string method which works well in all cases except one.  If I want to represent a double backslash, I can use r\"\\\\\", but if I try to enter a single backslash literal r\"\\\" Python complains with a syntax error. The obvious workaround is to use \"\\\\\" in this case, but why is the single raw string backslash an error? Is this a bug in Python? Is there a way to code a single backslash as a raw string? Example: I would rather be consistent using raw strings through-out the whole program, and using this \"\\\\\" in several places seems like a kludge. Using r\"\\\\\"[0] is not any better. I have also considered using a constant BACKSLASH where BACKSLASH = r\"\\\\\"[0] at the start of the program. Another kludge. UPDATE:\nThis error also happens when there is an odd number of backslashes at the end of a raw string. The default string scanner that is used interprets the backslash as an escape character, so that the last backslash will escape the ending quote character. It was intended that \" and ' can be embedded in the string, however the resulting string will still have the backslashes inside as a plain character. There are several questions related to this issue but none of the answers explains why the single backslash raw string is an error or how to code a single backslash as a raw string: python replace single backslash with double backslash can't print '\\' (single backslash) in Python Python regex to replace double backslash with single backslash Convering double backslash to single backslash in Python 3 Why can't I end a raw string with a backslash? Why can't Python's raw string literals end with a single backslash?", "abstract": ""}, "answers": [{"id": 30283104, "score": 1, "vote": 0, "content": "The problem here is simple, the system assumes that the single backslash is for escaping, you are escaping your quote, otherwise you have to escape the escape char. This would happen in any environment that lets a character disable another characters function.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11168076/why-cant-i-end-a-raw-string-with-a-backslash", "keywords": [], "tags": ["python", "string", "rawstring"], "question": {"id": 11168076, "title": "Why can&#39;t I end a raw string with a backslash?", "content": "I am confused here, even though raw strings convert every \\ to \\\\ but when this \\ appears in the end it raises error. Update: This is now covered in Python FAQs as well: Why can\u2019t raw strings (r-strings) end with a backslash?", "abstract": ""}, "answers": [{"id": 30283185, "score": 3, "vote": 0, "content": "Quote from https://docs.python.org/3.4/reference/lexical_analysis.html#literals: Even in a raw literal, quotes can be escaped with a backslash, but the\n  backslash remains in the result; for example, r\"\\\"\" is a valid string\n  literal consisting of two characters: a backslash and a double quote;\n  r\"\\\" is not a valid string literal (even a raw string cannot end in an\n  odd number of backslashes). Specifically, a raw literal cannot end in\n  a single backslash (since the backslash would escape the following\n  quote character). Note also that a single backslash followed by a\n  newline is interpreted as those two characters as part of the literal,\n  not as a line continuation. So in raw string, backslash are not treated specially, except when preceding \" or '. Therefore, r'\\' or r\"\\\" is not a valid string cause right quote is escaped thus making the string literal invalid. In such case, there's no difference whether r exists, i.e. r'\\' is equivalent to '\\' and r\"\\\" is equivalent to \"\\\".", "abstract": ""}, {"id": 11170170, "score": 9, "vote": 0, "content": "Raw strings can't end in single backslashes because of how the parser works (there is no actual escaping going on, though). The workaround is to add the backslash as a non-raw string literal afterwards: Not pretty, but it works. You can add plus to make it clearer what is happening, but it's not necessary:", "abstract": ""}, {"id": 11169639, "score": 5, "vote": 0, "content": "Python strings are processed in two steps: First the tokenizer looks for the closing quote. It recognizes backslashes when it does this, but doesn't interpret them - it just looks for a sequence of string elements followed by the closing quote mark, where \"string elements\" are either (a character that's not a backslash, closing quote or a newline - except newlines are allowed in triple-quotes), or (a backslash, followed by any single character). Then the contents of the string are interpreted (backslash escapes are processed) depending on what kind of string it is. The r flag before a string literal only affects this step.", "abstract": ""}, {"id": 11168081, "score": 10, "vote": 0, "content": "You still need \\ to escape ' or \" in raw strings, since otherwise the python interpreter doesn't know where the string stops. In your example, you're escaping the closing '. Otherwise: Look at the syntax highlighting to see what I mean.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/23938753/how-to-print-an-odd-number-of-backslashes-in-python", "keywords": [], "tags": ["python", "escaping"], "question": {"id": 23938753, "title": "How to Print An Odd Number of Backslashes in Python", "content": "I need to print a string as part of a list that has 3 backslashes in it in Python. However, this is not appearing to be as simple as I expected. Any string that has an odd number of backslashes will do this because Python is escaping the quote. So I tried escaping myself: which is 6 backslashes. Not what I wanted. This has stumped a few of us around the water cooler.", "abstract": ""}, "answers": [{"id": 23938808, "score": 5, "vote": 0, "content": "'\\\\\\\\\\\\' is a string contain 3 backslashes. You can see that there are 3 characters in the string by applying list to it: '\\\\'*3 would also work: Or since  you could avoid the need to escape the backslash by using \\x5c:", "abstract": ""}, {"id": 23938782, "score": 2, "vote": 0, "content": "would work I think (r indicates a literal string) (as pointed out in the comments you cant end with a backslash in raw strings ...(so I added a space)) If you didnt want the space you could ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/23360807/trailing-slash-in-a-raw-string", "keywords": [], "tags": ["python", "syntax"], "question": {"id": 23360807, "title": "Trailing slash in a raw string", "content": "Just a quick silly question. How do I write a trailing slash in a raw string literal?", "abstract": ""}, "answers": [{"id": 23361028, "score": 2, "vote": 0, "content": "Raw string literals are parsed in exactly the same way as ordinary string literals; it\u2019s just the conversion from string literal to string object that\u2019s different. This means that all string literals must end with an even number of backslashes; otherwise, the unpaired backslash at the end escapes the closing quote character, leaving an unterminated string.", "abstract": ""}, {"id": 23360906, "score": 7, "vote": 0, "content": "You can't. A raw string literal can't end with an odd number of backslashes (langref; last paragraph of that section). You can, howerver, write a raw string literal without the backslash, and write the final backslash as an ordinary string literal: Adjacent string literals are implicitly concatenated by the parser.", "abstract": ""}]}]