[{"link": "https://stackoverflow.com/questions/38599015/print-object-instance-name-in-python", "keywords": [], "tags": ["python", "object"], "question": {"id": 38599015, "title": "print object/instance name in python", "content": "I was wondering if there is a way to print the object name in python as a string.  For example I want to be able to say ENEMY1 has 2 hp left or ENEMY2 has 4 hp left.  Is there a way of doing that?\\", "abstract": ""}, "answers": [{"id": 49331805, "score": 1, "vote": 0, "content": "I have posted a complete solution here: https://stackoverflow.com/a/49331683/7386061 It works without parameters. For example you could just do:", "abstract": ""}, {"id": 38599196, "score": 6, "vote": 0, "content": "A much better design principle is not to rely on the specific name of the object as shown below: This can lead to a whole wealth of issues with assignment binding, referencing, and most importantly does not allow you to name your objects per user or program choice. Instead add an instance variable to your class called self._name (9.6 Classes - Private Variables) or self.name if you want to allow access outside the scope of the class (in this example, you can name it anything). Not only is this more Object-Oriented design, but now you can implement methods like __hash__ to be able to create a hash based on a name for example to use an object as a key (there are many more reasons why this design choice is better!). Sample output:", "abstract": ""}, {"id": 38599084, "score": 3, "vote": 0, "content": "You'd have to first give them names. E.g.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1538342/how-can-i-get-the-name-of-an-object", "keywords": [], "tags": ["python", "introspection"], "question": {"id": 1538342, "title": "How can I get the name of an object?", "content": "Suppose I have code like: How can I get the name of each object in Python? That is to say: what could I write instead of name in this code, so that the loop will show handling object x and then handling object y and handling object z? In my actual code, I have a dict of functions that I will call later after looking them up with user input: How can I create fun_dict automatically, without writing the names of the functions twice? I would like to be able to write something like to avoid duplicating the names.", "abstract": ""}, "answers": [{"id": 76746346, "score": -2, "vote": 0, "content": "Instead of only passing in val, it could potentially pass in array of name and val. Ex.", "abstract": ""}, {"id": 1538380, "score": 58, "vote": 0, "content": "Objects do not necessarily have names in Python, so you can't get the name. When you create a variable, like the x, y, z above then those names just act as \"pointers\" or \"references\" to the objects. The object itself does not know what name(s) you are using for it, and you can not easily (if at all) get the names of all references to that object. However, it's not unusual for objects to have a __name__ attribute. Functions do have a __name__ (unless they are lambdas), so we can build fun_dict by doing e.g.", "abstract": ""}, {"id": 54349277, "score": 0, "vote": 0, "content": "Python has names which are mapped to objects in a hashmap called a namespace. At any instant in time, a name always refers to exactly one object, but a single object can be referred to by any arbitrary number of names. Given a name, it is very efficient for the hashmap to look up the single object which that name refers to. However given an object, which as mentioned can be referred to by multiple names, there is no efficient way to look up the names which refer to it. What you have to do is iterate through all the names in the namespace and check each one individually and see if it maps to your given object. This can easily be done with a list comprehension: This will evaluate to a list of strings containing the names of all local \"variables\" which are currently mapped to the object  myobj. Of course locals() can be substituted with any dict that you want to search for names that point to a given object. Obviously this search can be slow for very large namespaces because they must be traversed in their entirety.", "abstract": ""}, {"id": 71715076, "score": -1, "vote": 0, "content": "Hi there is one way to get the variable name that stores an instance of a class\nis to use locals() function, it returns a dictionary that contains the variable name as a string and its value", "abstract": ""}, {"id": 68743685, "score": 1, "vote": 0, "content": "I know This is late answer. Ex:. Performance note: don't use it in large modules.", "abstract": ""}, {"id": 64053336, "score": 0, "vote": 0, "content": "Based on what it looks like you're trying to do you could use this approach. In your case, your functions would all live in the module foo. Then you could: Or more succinctly:", "abstract": ""}, {"id": 16139159, "score": 11, "vote": 0, "content": "This one-liner works, for all types of objects, as long as they are in globals() dict, which they should be: or, equivalently:", "abstract": ""}, {"id": 39240374, "score": 0, "vote": 0, "content": "Here is my answer, I am also using globals().items() I added except_word because I want to filter off some word used in for loop. \nIf you didn't add it, the keyword in for loop may confuse this function, sometimes the keyword like \"each_item\" in the following case may show in the function's result, depends on what you have done to your loop. eg. eg. Hope this can help.", "abstract": ""}, {"id": 30019808, "score": 0, "vote": 0, "content": "You define a class and add the Unicode private function insert the class like Of course you have to add extra variable self.name which is the name of the object.", "abstract": ""}, {"id": 30019630, "score": 11, "vote": 0, "content": "As others have mentioned, this is a really tricky question. Solutions to this are not \"one size fits all\", not even remotely. The difficulty (or ease) is really going to depend on your situation. I have come to this problem on several occasions, but most recently while creating a debugging function. I wanted the function to take some unknown objects as arguments and print their declared names and contents. Getting the contents is easy of course, but the declared name is another story. What follows is some of what I have come up with. Determining the name of a function is really easy as it has the __name__ attribute containing the function's declared name. Just as an example, if you create the function def test_function(): pass, then copy_function = test_function, then name_of_function(copy_function), it will return test_function. Check whether the object has a __name__ attribute and return it if so (declared functions only). Note that you may remove this test as the name will still be in globals(). Compare the value of arg with the values of items in globals() and return the name of the first match. Note that I am filtering out names starting with '_'. The result will consist of the name of the first matching object otherwise None. The result will consist of a list (for multiple matches), a string (for a single match), otherwise None. Of course you should adjust this behavior as needed.", "abstract": ""}, {"id": 21339843, "score": 8, "vote": 0, "content": "If you are looking to get the names of functions or lambdas or other function-like objects that are defined in the interpreter, you can use dill.source.getname from dill.  It pretty much looks for the __name__ method, but in certain cases it knows other magic for how to find the name... or a name for the object.  I don't want to get into an argument about finding the one true name for a python object, whatever that means.", "abstract": ""}, {"id": 23258737, "score": 0, "vote": 0, "content": "I ran into this page while wondering the same question. As others have noted, it's simple enough to just grab the __name__ attribute from a function in order to determine the name of the function. It's marginally trickier with objects that don't have a sane way to determine __name__, i.e. base/primitive objects like basestring instances, ints, longs, etc. Long story short, you could probably use the inspect module to make an educated guess about which one it is, but you would have to probably know what frame you're working in/traverse down the stack to find the right one. But I'd hate to imagine how much fun this would be trying to deal with eval/exec'ed code. whats_my_name_again.py:", "abstract": ""}, {"id": 1538399, "score": 17, "vote": 0, "content": "That's not really possible, as there could be multiple variables that have the same value, or a value might have no variable, or a value might have the same value as a variable only by chance. If you really want to do that, you can use However, it would be better if you would iterate over names in the first place: \u00a0", "abstract": ""}, {"id": 1539517, "score": 2, "vote": 0, "content": "Use a reverse dict. The reverse dict will map each function reference to the exact name you gave it in fun_dict, which may or may not be the name you used when you defined the function.  And, this technique generalizes to other objects, including integers. For extra fun and insanity, you can store the forward and reverse values in the same dict.  I wouldn't do that if you were mapping strings to strings, but if you are doing something like function references and strings, it's not too crazy.", "abstract": ""}, {"id": 1539174, "score": 1, "vote": 0, "content": "And the reason I want to have the name of the function is because I want to create fun_dict without writing the names of the functions twice, since that seems like a good way to create bugs. For this purpose you have a wonderful getattr function, that allows you to get an object by known name. So you could do for example: funcs.py: main.py:", "abstract": ""}, {"id": 1539123, "score": 1, "vote": 0, "content": "Here's another way to think about it.  Suppose there were a name() function that returned the name of its argument.  Given the following code: What should name(e[2]) return, and why?", "abstract": ""}, {"id": 1539112, "score": 0, "vote": 0, "content": "Generally when you are wanting to do something like this, you create a class to hold all of these functions and name them with some clear prefix cmd_ or the like.  You then take the string from the command, and try to get that attribute from the class with the cmd_ prefixed to it.  Now you only need to add a new function/method to the class, and it's available to your callers.  And you can use the doc strings for automatically creating the help text. As described in other answers, you may be able to do the same approach with globals() and regular functions in your module to more closely match what you asked for. Something like this:", "abstract": ""}, {"id": 1538772, "score": 1, "vote": 0, "content": "Note that while, as noted, objects in general do not and cannot know what variables are bound to them, functions defined with def do have names in the __name__ attribute (the name used in def).  Also if the functions are defined in the same module (as in your example) then globals() will contain a superset of the dictionary you want. ", "abstract": ""}, {"id": 1538466, "score": 0, "vote": 0, "content": "Variable names can be found in the globals() and locals() dicts. But they won't give you what you're looking for above. \"bla\" will contain the value of each item of my_list, not the variable.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/34439/finding-what-methods-a-python-object-has", "keywords": [], "tags": ["python", "introspection"], "question": {"id": 34439, "title": "Finding what methods a Python object has", "content": "Given a Python object of any kind, is there an easy way to get the list of all methods that this object has? Or if this is not possible, is there at least an easy way to check if it has a particular method, other than checking if an error occurs when the method is called?", "abstract": ""}, "answers": [{"id": 34467, "score": 362, "vote": 0, "content": "You can use the built in dir() function to get a list of all the attributes a module has.  Try this at the command line to see how it works. Also, you can use the hasattr(module_name, \"attr_name\") function to find out if a module has a specific attribute. See the Python introspection for more information.", "abstract": ""}, {"id": 34452, "score": 745, "vote": 0, "content": "For many objects, you can use this code, replacing 'object' with the object you're interested in: I discovered it at diveintopython.net (now archived), that should provide some further details! If you get an AttributeError, you can use this instead: getattr() is intolerant of pandas style Python 3.6 abstract virtual sub-classes.  This code does the same as above and ignores exceptions.", "abstract": ""}, {"id": 20100900, "score": 153, "vote": 0, "content": "The simplest method is to use dir(objectname). It will display all the methods available for that object.", "abstract": ""}, {"id": 65186594, "score": 24, "vote": 0, "content": "Suppose we have a Python obj. Then to see all the methods it has, including those surrounded by __ (magic methods): To exclude magic builtins one would do:", "abstract": ""}, {"id": 50050651, "score": 28, "vote": 0, "content": "The simplest way to get a list of methods of any object is to use the help() command. It will list out all the available/important methods associated with that object. For example:", "abstract": ""}, {"id": 68474764, "score": 0, "vote": 0, "content": "Most of the time, I want to see the user-defined methods and I don't want to see the built-in attributes that start with '__', if you want that you can use the following code: For example, for this class: Above code will print: ['print_name']", "abstract": ""}, {"id": 67662964, "score": -1, "vote": 0, "content": "Here's a nice one liner (but will get attributes as well):", "abstract": ""}, {"id": 63620684, "score": 3, "vote": 0, "content": "I have done the following function (get_object_functions), which receives an object (object_) as its argument, and returns a list (functions) containing all of the methods (including static and class methods) defined in the object's class: Well, it just checks if the string representation of the type of a class' attribute equals \"<class 'function'>\" or \"<class 'method'>\" and then includes that attribute in the functions list if that's True. For a cleaner version of the code: https://github.com/revliscano/utilities/blob/master/get_object_functions/object_functions_getter.py", "abstract": ""}, {"id": 63481052, "score": -1, "vote": 0, "content": "You can make use of dir() which is pre-defined in Python. You can also pass an object to dir() as If the object is an object of a pre-defined class such as int, str, etc. it displays the methods in it (you may know those methods as built in functions). If that object is created for a user-defined class, it displays all the methods given in that class.", "abstract": ""}, {"id": 47317075, "score": 16, "vote": 0, "content": "Open a Bash shell (Ctrl + Alt + T on Ubuntu). Start a Python\u00a03 shell in it. Create an object to observe the methods of. Just add a dot after it and press Tab twice and you'll see something like this:", "abstract": ""}, {"id": 37464502, "score": 41, "vote": 0, "content": "I believe that you want something like this: a list of attributes from an object The built-in function dir() can do this job. Taken from help(dir) output on your Python shell: dir(...) If called without an argument, return the names in the current scope. Else, return an alphabetized list of names comprising (some of) the attributes of the given object, and of attributes reachable from it. If the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns: For example:", "abstract": ""}, {"id": 27380776, "score": 11, "vote": 0, "content": "The problem with all methods indicated here is that you can't be sure that a method doesn't exist. In Python you can intercept the dot calling through __getattr__ and __getattribute__, making it possible to create method \"at runtime\" Example: If you execute it, you can call non-existing methods in the object dictionary... And it's why you use the Easier to ask for forgiveness than permission paradigms in Python.", "abstract": ""}, {"id": 15640132, "score": 2, "vote": 0, "content": "...is there at least an easy way to check if it has a particular method other than simply checking if an error occurs when the method is called While \"Easier to ask for forgiveness than permission\" is certainly the Pythonic way, you may be looking for:", "abstract": ""}, {"id": 34481, "score": 28, "vote": 0, "content": "On top of the more direct answers, I'd be remiss if I didn't mention IPython. Hit Tab to see the available methods, with autocompletion. And once you've found a method, try: to see the pydocs, method signature, etc. Ahh... REPL.", "abstract": ""}, {"id": 58987382, "score": 4, "vote": 0, "content": "This should work :)", "abstract": ""}, {"id": 61189861, "score": 0, "vote": 0, "content": "If you are, for instance, using shell plus you can use this instead: that way, with the '??' just after your object, it'll show you all the attributes/methods the class has.", "abstract": ""}, {"id": 49194581, "score": 0, "vote": 0, "content": "In order to search for a specific method in a whole module", "abstract": ""}, {"id": 48284803, "score": 2, "vote": 0, "content": "Take a list as an object list(filter(lambda x:callable(getattr(obj,x)),obj.__dir__())) You get:", "abstract": ""}, {"id": 28220562, "score": 21, "vote": 0, "content": "If you specifically want methods, you should use inspect.ismethod. For method names: For the methods themselves: Sometimes inspect.isroutine can be useful too (for built-ins, C extensions, Cython without the \"binding\" compiler directive).", "abstract": ""}, {"id": 32608298, "score": 5, "vote": 0, "content": "There is no reliable way to list all object's methods. dir(object) is usually useful, but in some cases it may not list all methods. According to dir() documentation: \"With an argument, attempt to return a list of valid attributes for that object.\" Checking that method exists can be done by callable(getattr(object, method)) as already mentioned there.", "abstract": ""}, {"id": 29851741, "score": 2, "vote": 0, "content": "One can create a getAttrs function that will return an object's callable property names That'd return", "abstract": ""}, {"id": 34472, "score": 35, "vote": 0, "content": "To check if it has a particular method:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72365443/finding-the-caller-object-given-its-name-only", "keywords": [], "tags": ["python-3.x", "code-inspection"], "question": {"id": 72365443, "title": "finding the caller object given its name only", "content": "I want to find the caller callable from within the called object, without explcitely forwarding the caller to the called as an object. My current code looks something like this: and yields The method autolog gets the locals() and the caller method fn, and parses them using the signature of the caller. This works nice and provides the desired output, but requires passing the caller as an object - something I'd like to avoid as I'm refractoring to include this feature and have about 1000 places to modify. What I'd like to achieve is: pass locals() only; get the name of the caller within autolog_nameless, using inspect.stack()[1][3] or rather inspect.currentframe().f_back.f_code.co_name (latter has much less overhead), and using this - an possibly the information in locals() - find the caller object to inspect it for its signature. The method autolog_nameless gets cls, actually the class as part of locals() (or would get self if the caller was a simple method), but I can't really do anything with it. I'd think all the information required is given, but I just can't find a solution. Any help is greatly appreciated.", "abstract": ""}, "answers": [{"id": 72365882, "score": 0, "vote": 0, "content": "As it turns out it's quite simple: listing the methods of the class object found in locals() and searching by name should do the trick. Code, without error checking: and fn is the caller object to check the signature. Note, locals()['cls'] works here as in the example we have a classmethod, but this is just the object that the called method belongs to.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71790856/python-how-to-print-the-variable-name-of-an-object", "keywords": [], "tags": ["python"], "question": {"id": 71790856, "title": "Python - How to print the variable name of an Object", "content": "Thanks for reading. Preface, I don't mean how to make a print(objectA) make python output something other than the <__main__.A object at 0x00000273BC36A5C0> via the redefining the __str__ attribute. I will use the following example to try to explain what I'm doing. I would like the \"the points name\" to be replaced with whatever the variable name assigned to a specific object. So if I instantiated pointA=Point(1,0), I would like to be able to print\npointA has the points: (1,0) I can't seem to find anything like this online, just people having issues that are solved by redefining __str__. I tried to solve this issue by adding a .name attribute, but that made this very unwieldy (especially since I want to make other object classes that inherit Point()). I'm not entirely sure if this is possible from what I know about variable and object names in python, but after wrestling with it for a couple of days I'd figured I'd reach out for ideas.", "abstract": ""}, "answers": [{"id": 71791073, "score": 1, "vote": 0, "content": "Note that an object may be referred to as multiple names.\nIt is also possible that there is no object name referring to the object. Below is one approach that achieves your goal. It uses globals(), the dictionary that stores mappings from names to objects inside the global environment. Essentially, the __str__ method searches the object in the global listings (so it can be very slow if there are many objects) and keeps the name if matches.\nYou could possibly use locals instead to narrow the search scope. In the example, C is referring to the same object as A. So print(C) tells both A and C are the names.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/57648952/how-to-get-the-name-of-a-created-object-not-the-class-itself-in-python-3-x", "keywords": [], "tags": ["python"], "question": {"id": 57648952, "title": "How to get the name of a created object (not the class itself) in Python 3.X", "content": "I've always wondered if when you define a variable, you can somehow get the name you defined it with, and manipulate it as a string. I am trying to make some code more efficient in doing this. I looked this up and didn't seem to hit the spot with what I found. I found some code that can retrieve the name of the class itself, but not the name of the created object. I thought I would get a result looking like this:  It being literally the name of the object, not the class. Is there a way of doing this? If there is, I would really appreciate it.  PS: if this question turns out to be a duplicate, sorry, would love it if ya'll point me to the answer :) and not delete this.", "abstract": ""}, "answers": [{"id": 57649418, "score": 1, "vote": 0, "content": "Actually there is a way to get names of the variables and attributes.\nYou can get the list of all the names without namespace, and their values as a dictionary using the vars function. It printed all the predefined variables without a namespace. (built-in functions such as len and print have __ builtins __ namespace.). But if you defined a variable: Then you can find the a you defined. This also works for object. You'll get all the names of the object's namespace by calling vars with the object as an argument. Using the vars function and dictionary handling you can achieve getting the object's variable name by the variable values, but there can be another value with identical values causing conflicts. Summary:\nUsing the vars built-in function and dictionary handling you can get the variable name of a value, but it has a chance to fail, when the values are not unique in the namespace.", "abstract": ""}, {"id": 57648972, "score": 1, "vote": 0, "content": "What you think of as a \"variable\" is in Python nothing more than a reference to an object.\nSee naming and binding in the Python documentation. There is no 1:1 relation between objects and references. There can be more than one reference to an object. The CPython implementation even uses reference counting; an object will be de-allocated when there its reference count drops to 0. The closest thing that an object has to a name is its \"identity\", which you can get by calling the id() function on the object. This is an integer which is unique during the lifetime of the object. There is no universal way to get the the name of a reference/variable as a string.  If the name refers to an object that is subject to garbage collection, there is a roundabout way to get it (with thanks to Iain Shelvington for pointing it out in the comments): This will print out ['test']. Note that this does not apply to atomic objects like integers, strings and floats. It will only work for objects where gc.is_tracked(name) returns True.", "abstract": ""}, {"id": 57648979, "score": 1, "vote": 0, "content": "This isn't possible in Python. In theory the language could store down the first assignment name in some form, but it doesn't. Python also doesn't have anything like C#'s nameof() that could approximate this. The main issue here is that the name is just a pointer to the object, you could have multiple names for the same thing (or none at the level you are working at - what would be the name of a value in a list, for example?), so which one would you expect to get? Generally, if you want to do something like this, you want to use a data structure like a dictionary instead, that way you have access to the keys. The best you could do is something where you forgo the manual assignment and construct the object using code that gives the object that name and assigns the variable dynamically. This would still have the issue that the name wouldn't match other references, and would be fragile code. Using a dictionary would be easier in that case. You could also use __setattr__() to do something like this if you were assigning to a class attribute rather than a top-level variable. However, again, I'd argue a dictionary is the better option. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/53347379/how-to-use-input-as-a-name-for-object-in-python", "keywords": [], "tags": ["python", "python-3.x", "class", "object", "input"], "question": {"id": 53347379, "title": "How to use input() as a name for object in Python?", "content": "I'm new to python and I've been trying new things.\nI made this class: and then I typed this code to create objects of the class.\nThe problem is taht I wish to use the input() function to enter the name of the object. Here is the code I wrote (which does not work). You can see that my problem is in these lines: An object with the name (StudentName) is always created and I can get the information by using StudentName.stu_info(). Do you have any ideas on how I can use the value of StudentName as a name of an object? thank you in advance", "abstract": ""}, "answers": [{"id": 53347529, "score": 0, "vote": 0, "content": "But don't do that. Instead use a dictionary:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/36289941/how-to-get-the-name-of-an-object-from-a-class-in-python", "keywords": [], "tags": ["python", "class", "object"], "question": {"id": 36289941, "title": "How to get the name of an object from a class in Python?", "content": "I know this is a weird idea. The idea would be something like this: Then create a new object And finally get this output: That is not the idea behind this, but is an easy example of what I'm trying to...  PS: I'm not trying to get the class name, just the object name (if possible)\nPS2: I know I can get the name with test.__name__ but I'm trying to get the name inside the class, not outside.", "abstract": ""}, "answers": [{"id": 36290928, "score": 1, "vote": 0, "content": "First: you don't want to do this, there is no reason to do this, and if you think you need to do this, you're wrong.  Second: you can't do it in the __init__ method because the name reference test referring to the new AnyClass instance object hasn't been added to the memory space (\"bound\") yet. However, you could do it like this. This will return the first variable encountered in the locals() dictionary that is assigned to the test object. There is no guarantee for the order in which those variables will be returned.  To explain a bit further about why it won't work in the __init__ method, when you do this:  A new instance of AnyClassis constructed according to the instructions of the class definition (including the definitions of any parent or metaclass). This construction happens in phases, the last phase of which is executing the __init__ method. Prior to __init__, other methods that will be executed, if they exist, are __new__, and also the the __new__, __init__, and __call__ methods of the metaclass (if one exists). So at the point in time the code in the body of the __init__ method is being executed, the object is still being constructed. Therefore there is, as of yet, nothing in the locals() dictionary assigned to the name 'test'. There is only a member called 'self'. And, obviously, if you reverse-lookup the self object in the locals() dictionary looking for a registered name, the name you will get is the name 'self'. Which... isn't useful. ", "abstract": ""}, {"id": 36290142, "score": 3, "vote": 0, "content": "Consider this: Both a and b reference the exact same object. When you do a . operation on an object, you're looking up an attribute on that object.  An object can be referenced in many different locations; it makes no sense for it to store all those reference names, especially when those names are only bound within certain contexts.  For example Both a and b refer to the same dict object, but you can't use a to reference the dict anywhere else besides in the generator function. Within a specific context, you can test the bound names and see if they refer to a specific object.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/17200117/how-to-get-the-object-name-from-within-the-class", "keywords": [], "tags": ["python", "class", "object"], "question": {"id": 17200117, "title": "How to get the object name from within the class?", "content": "I've got a simple class from which I create two objects. I now want to print the name of the object from within the class. So something like this: I need this to print: Unfortunately this just prints <myModule.Example instance at 0xb67e77cc> Does anybody know how I can do this?", "abstract": ""}, "answers": [{"id": 17200177, "score": 4, "vote": 0, "content": "The object does not have a \"name\". A variable which refers to the object is not a \"name\" of the object. The object cannot know about any of the variables which refer to it, not least because variables are not a first-class subject of the language. If you wish to alter the way that object prints, override either __repr__ or __unicode__. If this is for debugging purposes, use a debugger. That's what it's for.", "abstract": ""}, {"id": 17200188, "score": 5, "vote": 0, "content": "object1 is just an identifier(or variable) pointing to an instance object, objects don't have names. a,b,c are simply references that allow us to access a same object, when an object has 0 references it is automatically garbage collected. A quick hack will be to pass the name when creating the instance:", "abstract": ""}, {"id": 17200322, "score": 1, "vote": 0, "content": "The common way to do this is something along these lines: Prints: However, there is no guarantee that this object remains bound to the original name: Prints object1, as expected, twice. If you want to see things under the hood -- use a debugger. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/17196474/getting-object-name-and-function-name", "keywords": [], "tags": ["python"], "question": {"id": 17196474, "title": "getting object name and function name", "content": "It is actually 2 questions. \n1) Is there a generic way to get the class name of an instance, so if I have a class I would like a built in way that gives me a string 'someClass' 2) Similar with functions. If I have  it would print 'someFunction' The reason why I am looking for this is, that I have a bit of a jungle of classes and subclasses and for debugging I would like to print where I am, so to all methods I would just want to add something along the lines So I am looking for a generic command that know the class and the function where it is, so that I can copy and paste the line in all the methods without having to write a separate line for each of them", "abstract": ""}, "answers": [{"id": 17196512, "score": 7, "vote": 0, "content": "use the __name__ attribute: Class: Function: A quick hack for classes will be:", "abstract": ""}, {"id": 17196943, "score": 3, "vote": 0, "content": "the function part has already been answered at this SO post. The code would be: For the class part, use: A.__name__ or A().__class__.__name (for an instance)", "abstract": ""}]}]