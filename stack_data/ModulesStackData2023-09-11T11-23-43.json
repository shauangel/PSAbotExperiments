[{"link": "https://stackoverflow.com/questions/65907075/add-all-functions-from-a-module-as-methods-of-an-object-without-code-duplication", "keywords": [], "tags": ["python"], "question": {"id": 65907075, "title": "Add all functions from a module as methods of an object without code duplication?", "content": "How would you add all functions from some module as methods of a specified object? If you have module modulename you can import all it's methods with I want to add them as methods of some obj instead cause they all accept that object as the first paramater and I find x.y(z) to be more fun than y(x,z) because of habit.", "abstract": ""}, "answers": [{"id": 65907273, "score": 1, "vote": 0, "content": "Try this:", "abstract": ""}, {"id": 65907173, "score": 0, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/4200221/forcing-immutability-on-an-object", "keywords": [], "tags": ["python"], "question": {"id": 4200221, "title": "Forcing immutability on an object", "content": "Before I start, I'm already aware that object immutability in Python is often a bad idea, however, I believe that in my case it would be appropriate. Let's say I'm working with a coordinate system in my code, such that each coordinate uses a struct of X, Y, Z. I've already overloaded subtraction, addition, etc. methods to do what I want. My current problem is the assignment operator, which I've read cannot be overloaded. Problem is when I have the following, I do not want A to point to the same point as B, I want the two to be independent, in case I need to overwrite a coordinate of one but not the other later: I'm aware that I can use deepcopy, but that seems like a hack, especially since I could have a list of points that I might need to take a slice of (in which case it would again have a slice of point references, not points). I've also considered using tuples, but my points have member methods I need, and a very large portion of my code already uses the structs. My idea was to modify Point to be immutable, since it's really only 3 floats of data, and from doing some research _new _() seems like the right function to overwrite for this. I'm not sure how to achieve this though, would it be something like this or am I way off? EDIT:\nMy bad, I realized after reading katrielalex's post that I can't modify a parameter of immutable object once it has been defined, in which case it's not a problem that both A and B point to the same data since a reassignment would require creation of a new point. I'd say that katrielalex's and vonPetrushev's posts achieve what I want, I think I'll go with vonPetrushev's solution since I don't need to rewrite all my current code to use tuples (the extra set of parentheses and not being able to reference coordinates as point.x)", "abstract": ""}, "answers": [{"id": 4200333, "score": 0, "vote": 0, "content": "try this: So, you can construct a Point object, but not change its attributes.", "abstract": ""}, {"id": 4200375, "score": 4, "vote": 0, "content": "In conjunction with katrielalex's suggestion, making the Point a named tuple would be good as well. Here I've just replaced the tuple parent with namedtuple('Point', 'x y z') - and that's enough for it to work. Then you can have: (Thanks to katrielalex for suggesting to extend the namedtuple rather than copying the code produced.)", "abstract": ""}, {"id": 4200275, "score": 1, "vote": 0, "content": "You can make Point a subclass of tuple -- remember, the built-in types (at least in recent Pythons) are just more classes. This will give you the desired immutability. However, I'm slightly confused about your suggested use case: in case I need to overwrite a coordinate of one but not the other later: That doesn't make sense if Points are immutable...", "abstract": ""}]}]