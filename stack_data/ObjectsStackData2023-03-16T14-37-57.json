[{"link": "https://stackoverflow.com/questions/72666230/wrapping-derived-class-method-from-base-class", "keywords": [], "tags": ["python", "oop", "metaclass", "python-class", "python-datamodel"], "question": {"id": 72666230, "title": "Wrapping derived class method from base class", "content": "Imagine I have a base and a derived class like so: I wish to wrap calls foo calls made by instances of B. Modifying any part of B is not allowed (I don\u2019t own B). What I have as of now: This works as expected, however I am concerned about this being inefficient memory-wise. o.foo is a <bound method A.__init__.<locals>.capture.<locals>.wrapper of <__main__.B object at 0x10523ffd0>>. It would seem that I would have to pay the cost of 2 closures for each instance I create. Is there a better way to do this? Perhaps a metaclass based approach?", "abstract": ""}, "answers": [{"id": 75367389, "score": 0, "vote": 0, "content": "Following @jsbueno answer Using types.MethodType(attr, self) is better than using since partial doesn't have a descriptor so the returned attribute is not bound to the class instance. just need to fix the return wrapper to", "abstract": ""}, {"id": 72666537, "score": 2, "vote": 0, "content": "Unless you are planning to have several thousands instances of these live at the same time, the resource usage of doing so should not concern you - it is rather small compared with other resources a running Python app will use. Just for comparison: asyncio coroutines and tasks are the kind of object which one can create thousands of in a process, and it is just \"ok\", will have a similar overhead. But since you have control of the base class for B there are several ways to do it, without resorting to \"monkey patching\" - which would be modifying B in place after it was created. That is often the only alternative when one has to modify a class for which they don't control the code. Wrapping the method either automatically, when it is retrieved from a B instance, in a lazy way, can spare even this - and sure can be more elegant than wrapping at the base class __init__: If you know beforehand the methods you have to wrap, and is sure they are implemented in subclasses of classes which you control, this can be made by crafting a specialized __getattribute__ method: this way, the method is wrapped only when it is about to get used. As for wrapping foo when B is created, that could give use even less resources - and while it could be done in a metaclass, from Python 3.6 on, the __init_subclass__  special method can handle it, with no need for a custom metaclass. However, this approach can be tricky if the code might further subclass B in a class C(B):  which will again override  foo: the wrapper could be called multiple times if the methods use super() calls to foo in the base classes. Avoiding the code in the wrapper to run more than once would require some complicated state handling (but it can be done with no surprises).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/75300287/how-to-add-method-to-base-class", "keywords": [], "tags": ["python", "class", "parent-child"], "question": {"id": 75300287, "title": "How to add method to base class?", "content": "I want to add __add__ and __radd__ to the python base class set. The code can be as simple as What is the pythonic implementation of this and how can I extend the base class without creating my own MySet class that takes set as a parent class? Can I just use set.__add__ = some_function_I_defined?", "abstract": ""}, "answers": [{"id": 75302708, "score": 0, "vote": 0, "content": "@chepner correctly answered my question without realizing it. I was trying to reimplement already existing functionality since I was not familiar with python sets. The act of joining two sets, 'taking their union' is implemented with the python __or__ and __ior__ methods. The operation I needed specifically was | and |=. In principle we should be able to set operations as chepner suggested with set.__add__ = set.__or__, but as chepner points out this results in an error: Thank you all.", "abstract": ""}, {"id": 75300706, "score": 1, "vote": 0, "content": "What you should do imho is subclass the built-in set class.\nIn Python (contrary to e.g. Ruby or JavaScript) monkey-patching a built-in is not allowed. So e.g. trying to add a non-existent method: is not going to work, you'd get AttributeError: 'list' object has no attribute 'my_new_method_added_in_runtime' You cannot also modify the existing methods of objects instantiated using those built-ins: will result in AttributeError: 'list' object attribute 'sort' is read-only And will result in:\nTypeError: can't set attributes of built-in/extension type 'list' All of the above is true for set as well an so on. You could try to look for some libraries to achieve that e.g. https://pypi.org/project/forbiddenfruit/0.1.0/, but it's strongly discouraged.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72608453/python-base-class-initializes-other-classes-depending-on-argument", "keywords": [], "tags": ["python", "class", "oop", "inheritance"], "question": {"id": 72608453, "title": "Python base class initializes other classes depending on argument", "content": "I have two classes that take the same parameters and do the same job, using different methods. Then I have a base class that acts as a high-level user API.\nDepending on the user provided \"method\" argument, the BaseClass initializes either of the two and returns the result. Currently I do it like below Therefore the user only initializes the class Square with optional method argument to determine the method of computation.\nWhat is the most proper way to do this, perhaps using some form of inheritance?", "abstract": ""}, "answers": [{"id": 72608619, "score": 0, "vote": 0, "content": "Just use a factory function:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/805066/how-do-i-call-a-parent-classs-method-from-a-child-class-in-python", "keywords": [], "tags": ["python", "class", "oop", "object", "inheritance"], "question": {"id": 805066, "title": "How do I call a parent class&#39;s method from a child class in Python?", "content": "When creating a simple object hierarchy in Python, I'd like to be able to invoke methods of the parent class from a derived class.  In Perl and Java, there is a keyword for this (super).  In Perl, I might do this: In Python, it appears that I have to name the parent class explicitly from the child.\nIn the example above, I'd have to do something like Foo::frotz().   This doesn't seem right since this behavior makes it hard to make deep hierarchies.  If children need to know what class defined an inherited method, then all sorts of information pain is created.   Is this an actual limitation in python, a gap in my understanding or both?", "abstract": ""}, "answers": [{"id": 70714134, "score": 1, "vote": 0, "content": "If you want to call the method of any class, you can simply call Class.method on any instance of the class. If your inheritance is relatively clean, this will work on instances of a child class too:", "abstract": ""}, {"id": 805081, "score": 978, "vote": 0, "content": "Use the super() function: For Python < 3, you must explicitly opt in to using new-style classes and use:", "abstract": ""}, {"id": 53067078, "score": 4, "vote": 0, "content": "In this example cafec_param is a base class (parent class) and abc is a child class. abc calls the AWC method in the base class. Output", "abstract": ""}, {"id": 55391551, "score": 2, "vote": 0, "content": "", "abstract": ""}, {"id": 38587017, "score": 88, "vote": 0, "content": "Python 3 has a different and simpler syntax for calling parent method. If Foo class inherits from Bar, then from Bar.__init__ can be invoked from Foo via super().__init__():", "abstract": ""}, {"id": 52116743, "score": -1, "vote": 0, "content": "", "abstract": ""}, {"id": 45037536, "score": 74, "vote": 0, "content": "Many answers have explained how to call a method from the parent which has been overridden in the child. However  \"how do you call a parent class's method from child class?\" could also just mean: \"how do you call inherited methods?\"  You can call methods inherited from a parent class just as if they were methods of the child class, as long as they haven't been overwritten. e.g. in python 3: yes, this may be fairly obvious, but I feel that without pointing this out people may leave this thread with the impression you have to jump through ridiculous hoops just to access inherited methods in python. Especially as this question rates highly in searches for \"how to access a parent class's method in Python\", and the OP is written from the perspective of someone new to python. I found:\nhttps://docs.python.org/3/tutorial/classes.html#inheritance\nto be useful in understanding how you access inherited methods.", "abstract": ""}, {"id": 41783372, "score": 3, "vote": 0, "content": "In Python 2, I didn't have a lot luck with super().  I used the answer from \njimifiki on this SO thread how to refer to a parent method in python?.\nThen, I added my own little twist to it, which I think is an improvement in usability (Especially if you have long class names). Define the base class in one module: Then import the class into another modules as parent:", "abstract": ""}, {"id": 805082, "score": 162, "vote": 0, "content": "Python also has super as well:  super(type[, object-or-type]) Return a proxy object that delegates method calls to a parent or sibling class of type.\n  This is useful for accessing inherited methods that have been overridden in a class. \n  The search order is same as that used by getattr() except that the type itself is skipped. Example: ", "abstract": ""}, {"id": 34183634, "score": 9, "vote": 0, "content": "If you don't know how many arguments you might get, and want to pass them all through to the child as well: (From: Python - Cleanest way to override __init__ where an optional kwarg must be used after the super() call?)", "abstract": ""}, {"id": 27402103, "score": 5, "vote": 0, "content": "There is a super() in python also. Example for how a super class method is called from a sub class method This example is similar to the one explained above.However there is one difference that super doesn't have any arguments passed to it.This above code is executable in python 3.4 version. ", "abstract": ""}, {"id": 805091, "score": 90, "vote": 0, "content": "will be just fine, whether the immediate parent class defined frotz itself or inherited it.  super is only needed for proper support of multiple inheritance (and then it only works if every class uses it properly).  In general, AnyClass.whatever is going to look up whatever in AnyClass's ancestors if AnyClass doesn't define/override it, and this holds true for \"child class calling parent's method\" as for any other occurrence!", "abstract": ""}, {"id": 16057968, "score": 31, "vote": 0, "content": "Here is an example of using super():", "abstract": ""}, {"id": 8689564, "score": 9, "vote": 0, "content": "I would recommend using CLASS.__bases__\nsomething like this", "abstract": ""}, {"id": 6407157, "score": -26, "vote": 0, "content": "This is a more abstract method:", "abstract": ""}, {"id": 805085, "score": 14, "vote": 0, "content": "There's a super() in Python too. It's a bit wonky, because of Python's old- and new-style classes, but is quite commonly used e.g. in constructors:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/4747397/calling-base-class-method-in-python", "keywords": [], "tags": ["python", "class"], "question": {"id": 4747397, "title": "Calling base class method in Python", "content": "I have two classes A and B and A is base class of B. I read that all methods in Python are virtual.  So how do I call a method of the base because when I try to call it, the method of the derived class is called as expected?", "abstract": ""}, "answers": [{"id": 70353765, "score": 0, "vote": 0, "content": "Simple answer:", "abstract": ""}, {"id": 4747439, "score": 40, "vote": 0, "content": "Two ways: \n>>> A.print_it(x)\n'A'\n>>> super(B, x).print_it()\n'A'\n", "abstract": ""}, {"id": 4747427, "score": 56, "vote": 0, "content": "Using super:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70110533/type-hint-of-base-class-method-based-on-subclass", "keywords": [], "tags": ["python", "inheritance", "subclass", "type-hinting"], "question": {"id": 70110533, "title": "Type hint of Base class method based on Subclass", "content": "When creating a base class with a request method that will be exactly the same for all subclasses. There does not seem to be an easy way of having separate type-hints based on which subclass made the request. The example below is how I currently am solving this issue, but it seems as if there is a better way. Is there a better way of doing this, either by specifying Response type on the subclass or by just overriding the method signature and no the functionality? Something like (I know this does not work): I would assume that using something like Generic[T] and TypeVar() could be a way to go?", "abstract": ""}, "answers": [{"id": 70110872, "score": 0, "vote": 0, "content": "Perhaps typing.overload is what you seek. Now your FooRequest and BarRequest no longer need to supply their implementation of (or type hints for) make_request. If on the other hand your only goal is to type hint the IDE, you could: This would make the IDE accept but reject", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/67237473/calling-super-method-vs-baseclass-methodself", "keywords": [], "tags": ["python", "python-3.x", "class", "oop", "inheritance"], "question": {"id": 67237473, "title": "Calling super().method() vs. BaseClass.method(self)", "content": "There are two main ways for a derived class to call a base class's methods. Base.method(self): or super().method(): Suppose I now do this: As far as I know, both Base.method(self) and super().method() do the same thing. Both will call Base.method with a reference to obj. In particular, super() doesn't do the legwork to instantiate an object of type Base. Instead, it creates a new object of type super and grafts the instance attributes from obj onto it, then it dynamically looks up the right attribute from Base when you try to get it from the super object. The super() method has the advantage of minimizing the work you need to do when you change the base for a derived class. On the other hand, Base.method uses less magic and may be simpler and clearer when a class inherits from multiple base classes. Most of the discussions I've seen recommend calling super(), but is this an established standard among Python coders? Or are both of these methods widely used in practice? For example, answers to this stackoverflow question go both ways, but generally use the super() method. On the other hand, the Python textbook I am teaching from this semester only shows the Base.method approach.", "abstract": ""}, "answers": [{"id": 67237936, "score": 2, "vote": 0, "content": "Using super() implies the idea that whatever follows should be delegated to the base class, no matter what it is. It's about the semantics of the statement. Referring explicitly to Base on the other hand conveys the idea that Base was chosen explicitly for some reason (perhaps unknown to the reader), which might have its applications too. Apart from that however there is a very practical reason for using super(), namely cooperative multiple inheritance. Suppose you've designed the following class hierarchy: Now you can use both Foo and Bar and everything works as expected. However these two classes won't work together in a multiple inheritance schema: That last call to test skips over Bar's implementation since Foo didn't specify that it wants to delegate to the next class in method resolution order but instead explicitly specified Base. Using super() resolves this issue:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1269217/calling-a-base-classs-classmethod-in-python", "keywords": [], "tags": ["python", "class", "overriding", "class-method"], "question": {"id": 1269217, "title": "Calling a base class&#39;s classmethod in Python", "content": "Consider the following code: From Derived.do, how do I call Base.do?  I would normally use super or even the base class name directly if this is a normal object method, but apparently I can't find a way to call the classmethod in the base class.  In the above example, Base.do(a) prints Base class instead of Derived class.", "abstract": ""}, "answers": [{"id": 64331165, "score": 2, "vote": 0, "content": "Building on the answer from @David Z using: Which can be further simplified to: I often use classmethods to provide alternative ways to construct my objects. In the example below I use the super functions as above for the class method load that alters the way that the objects are created: Output:", "abstract": ""}, {"id": 1269224, "score": 142, "vote": 0, "content": "If you're using a new-style class (i.e. derives from object in Python 2, or always in Python 3), you can do it with super() like this: This is how you would invoke the code in the base class's version of the method (i.e. print cls, a), from the derived class, with cls being set to the derived class.", "abstract": ""}, {"id": 5682347, "score": 17, "vote": 0, "content": "this has been a while, but I think I may have found an answer. When you decorate a method to become a classmethod the original unbound method is stored in a property named 'im_func':", "abstract": ""}, {"id": 1269233, "score": -4, "vote": 0, "content": "This works for me:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55721635/can-i-call-base-class-method-in-my-setup-function", "keywords": [], "tags": ["python"], "question": {"id": 55721635, "title": "can I call base class method in my setup function", "content": "I am writing python script for the first time\nHere is a basic question Can I call base class method directly in this way in my setUp function?\nAlso if I am inheriting more than one base class , and super.setup() executes which both ? if so which one first ?", "abstract": ""}, "answers": [{"id": 55721921, "score": 0, "vote": 0, "content": "Yes, doing super().setUp() is the right way of calling the parent method class. Now, regarding the multiple inheritance and the method calling. Python will actually call only the method of one class. When you do multiple inheritance, Python will create a 'Multiple-Resolution Order', that is the order in which python check the parent class for the method. Once it found the method in a parent it will  stop looking for the method (this normally happens, because the inheritance hierarchy may be big). In your example, you resolution order would be: You can check it by running TestLolSupv.mro(). If you want to have control of the order the objects are being called, I would suggest using delegation instead. And also, if you are using inheritance to have access to parent class method, delegation would be better. Normally, inheritance is worth when the parent class calls a child class method, because this means you are building an abstraction. Here is some info about multiple inheritance in python.", "abstract": ""}, {"id": 55721900, "score": 1, "vote": 0, "content": "super.setup() will search for setup method in all parent classes, starting from left to right, till it finds it and executes the first found method. for example will print the answer as \"A\". if the parent classes have inherited from other classes, then they will be searched in that order. example now for E the setup in A will be executed, and for F setup in B will be executed.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55695067/how-to-protect-function-from-base-class-in-python", "keywords": [], "tags": ["python", "python-3.x", "overriding", "subclassing"], "question": {"id": 55695067, "title": "How to protect function from base class in Python?", "content": "I am currently learning the Template Method pattern in python. I am wondering if there is any way to protect some of the functions from the base class so that the subclass cannot overwrite? As below, the _primitive_operation_3 from the subclass overwrites the same function from the base class. And if methods from base class cannot be prevented being overwritten, how can I put something in place to give an automatic alert/warning indicating that a particular method from the base class has been overwritten?", "abstract": ""}, "answers": [{"id": 55695110, "score": 1, "vote": 0, "content": "You can't prevent subclasses from using the same names, no. You can protect names against accidental shadowing, however, by giving the name a double underscore prefix: The Python compiler will replace all references to that name, within methods of a class, to add the classname as a prefix. Here, that's AbstractClass, so the actual name becomes _AbstractClass__primitive_operation_3, but you because the compiler rewrites all references, you transparently keep using __primitive_operation_3 in your code. Any __primitive_operation_3 names on a subclass would get renamed with a different prefix, simply because they are defined on a class with a different name. This feature is explicitly aimed at base classes that want to allow subclasses to use a wide range of names in their definitions. See the Reserved classes of identifiers section in the lexical analysis reference documentation: __* Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between \u201cprivate\u201d attributes of base and derived classes. and the Identifiers section of the expressions documentation: Private name mangling: When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a private name of that class. Private names are transformed to a longer form before code is generated for them. The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name. For example, the identifier __spam occurring in a class named Ham will be transformed to _Ham__spam. This transformation is independent of the syntactical context in which the identifier is used. If the transformed name is extremely long (longer than 255 characters), implementation defined truncation may happen. If the class name consists only of underscores, no transformation is done. Subclasses can still override the name, but have to explicitly include the same prefix. Note that you can't use this mechanism to avoid special methods (with leading and trailing __ double underscores, e.g. __init__ or __len__) from being overridden in a subclass. Clear project documentation is paramount if subclasses of your base class can't override specific methods without taking care to call the base implementation. At best you can detect if a subclass is overriding a method by checking for missing side effects (which is how the standard library has protected Thread.__init__ overriding or you can check if self.methodname.__func__ is ClassObject.methodname is true still before calling the method.", "abstract": ""}]}]