[{"link": "https://stackoverflow.com/questions/76683114/using-elvis-ternary-operator-as-an-argument-to-a-function", "keywords": [], "tags": ["conditional-operator", "elvis-operator"], "question": {"id": 76683114, "title": "Using elvis/ternary operator as an argument to a function", "content": "Let's say I have this block of code in Groovy: Is there anything wrong with using Elvis operator as an argument to a function like I did above? I tested it and it works as expected, however, I've never seen Elvis operator to be passed to a function like that. Thanks in advance!", "abstract": ""}, "answers": [{"id": 76683151, "score": 1, "vote": 0, "content": "I've never seen Elvis operator to be passed to a function Contrary to what your intuition is telling you, you're not seeing it here either.  The operator isn't passed to the function.  The result of the expression is. This expression evaluates to a result: The result of this expression is a String value.  That String value is passed to the function.  It doesn't matter to the function how that String value was produced before it was passed to the function.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator", "keywords": [], "tags": ["python", "operators", "conditional-operator"], "question": {"id": 394809, "title": "Does Python have a ternary conditional operator?", "content": "Is there a ternary conditional operator in Python?", "abstract": ""}, "answers": [{"id": 76409092, "score": 1, "vote": 0, "content": "Yes, Python has a ternary conditional operator, also known as the conditional expression or the ternary operator. The syntax of the ternary operator in Python is: Here's an example to illustrate its usage: In this example, the condition x % 2 == 0 checks if x is divisible by 2. If the condition is True, the value \"Even\" is assigned to the variable result. Otherwise, the value \"Odd\" is assigned. The output will be: It is a good idea to use parenthesis, in order to increase readability, when working with medium complexity operations: Instead of: The ternary operator is a concise way to write simple conditional expressions in a single line. It can be particularly useful when assigning values or constructing expressions based on conditions. However, for more complex conditions or longer expressions, if possible it's generally better to use if-else statements for improved readability.", "abstract": ""}, {"id": 75437410, "score": 0, "vote": 0, "content": "I have data coming from a device as a string and leaving it as a rebuild string. Conditional expression need to be limited by (). This allow to have multiple conditions to build the string in one line. If not it seems like whatever after the \"else\" will be accounted.", "abstract": ""}, {"id": 30052371, "score": 181, "vote": 0, "content": "An operator for a conditional expression in Python was added in 2006 as part of Python Enhancement Proposal 308. Its form differs from common ?: operator and it looks like this: which is equivalent to: Here is an example: Another syntax which can be used (compatible with versions before 2.5): where operands are lazily evaluated. Another way is by indexing a tuple (which isn't consistent with the conditional operator of most other languages): or explicitly constructed dictionary: Another (less reliable), but simpler method is to use and and or operators: however this won't work if x would be False. A possible workaround is to make x and y lists or tuples as in the following: or: If you're working with dictionaries, instead of using a ternary conditional, you can take advantage of get(key, default), for example: Source: ?: in Python at Wikipedia", "abstract": ""}, {"id": 10314837, "score": 85, "vote": 0, "content": "For Python 2.5 and newer there is a specific syntax: In older Pythons, a ternary operator is not implemented but it's possible to simulate it. Though there is a potential problem, which is if cond evaluates to True and on_true evaluates to False then on_false is returned instead of on_true. If you want this behaviour the method is OK, otherwise use this: which can be wrapped by: and used this way: It is compatible with all Python versions.", "abstract": ""}, {"id": 394814, "score": 8983, "vote": 0, "content": "Yes, it was added in version 2.5. The expression syntax is: First condition is evaluated, then exactly one of either a or b is evaluated and returned based on the Boolean value of condition. If condition evaluates to True, then a is evaluated and returned but b is ignored, or else when b is evaluated and returned but a is ignored. This allows short-circuiting because when condition is true only a is evaluated and b is not evaluated at all, but when condition is false only b is evaluated and a is not evaluated at all. For example: Note that conditionals are an expression, not a statement. This means you can't use statements such as pass, or assignments with = (or \"augmented\" assignments like +=), within a conditional expression: (In 3.8 and above, the := \"walrus\" operator allows simple assignment of values as an expression, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.) Similarly, because it is an expression, the else part is mandatory: You can, however, use conditional expressions to assign a variable like so: Or for example to return a value: Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will do the same thing with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to do something different depending on the condition, then use a normal if statement instead. Keep in mind that it's frowned upon by some Pythonistas for several reasons: If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, x = 4 if b > 8 else 9 is read aloud as x will be 4 if b is greater than 8 otherwise 9. Official documentation:", "abstract": ""}, {"id": 54609267, "score": 37, "vote": 0, "content": "One of the alternatives to Python's conditional expression is the following: which has the following nice extension: The shortest alternative remains which works because issubclass(bool, int). Careful, though: the alternative to is not but This works fine as long as no and yes are to be called with exactly the same parameters. If they are not, like in or in then a similar alternative either does not exist (1) or is hardly viable (2). (In rare cases, depending on the context, something like could make sense.) Thanks to Radek Roj\u00edk for his comment", "abstract": ""}, {"id": 71819081, "score": 12, "vote": 0, "content": "The syntax for the ternary operator in Python is: [on_true] if [expression] else [on_false] Using that syntax, here is how we would rewrite the code above using Python\u2019s ternary operator: It's still pretty clear, but much shorter. Note that the expression could be any type of expression, including a function call, that returns a value that evaluates to True or False.", "abstract": ""}, {"id": 33765206, "score": 54, "vote": 0, "content": "Yes. From the grammar file: The part of interest is: So, a ternary conditional operation is of the form: expression3 will be lazily evaluated (that is, evaluated only if expression2 is false in a boolean context). And because of the recursive definition, you can chain them indefinitely (though it may considered bad style.) Note that every if must be followed with an else. People learning list comprehensions and generator expressions may find this to be a difficult lesson to learn - the following will not work, as Python expects a third expression for an else: which raises a SyntaxError: invalid syntax.\nSo the above is either an incomplete piece of logic (perhaps the user expects a no-op in the false condition) or what may be intended is to use expression2 as a filter - notes that the following is legal Python: expression2 works as a filter for the list comprehension, and is not a ternary conditional operator. You may find it somewhat painful to write the following: expression1 will have to be evaluated twice with the above usage. It can limit redundancy if it is simply a local variable. However, a common and performant Pythonic idiom for this use-case is to use or's shortcutting behavior: which is equivalent in semantics. Note that some style-guides may limit this usage on the grounds of clarity - it does pack a lot of meaning into very little syntax.", "abstract": ""}, {"id": 14321907, "score": 59, "vote": 0, "content": "You might often find but this leads to a problem when on_true == 0 Where you would expect this result for a normal ternary operator:", "abstract": ""}, {"id": 71150434, "score": 3, "vote": 0, "content": "Yes, it has, but it's different from C-syntax-like programming languages (which is condition ? value_if_true : value_if_false In Python, it goes like this: value_if_true if condition else value_if_false Example: even_or_odd = \"even\" if x % 2 == 0 else \"odd\"", "abstract": ""}, {"id": 70941294, "score": 3, "vote": 0, "content": "The if else-if version can be written as:", "abstract": ""}, {"id": 70523744, "score": 7, "vote": 0, "content": "Pythonic way of doing the things: But there always exists a different way of doing a ternary condition too:", "abstract": ""}, {"id": 71007804, "score": 4, "vote": 0, "content": "There are multiple ways. The simplest one is to use the condition inside the \"print\" method. You can use Which is equivalent to: In this way, more than two statements are also possible to print. For example: can be written as:", "abstract": ""}, {"id": 65422380, "score": 30, "vote": 0, "content": "Vinko Vrsalovic's answer is good enough. There is only one more thing: Note that conditionals are an expression, not a statement. This means you can't use assignment statements or pass or other statements within a conditional expression After the walrus operator was introduced in Python 3.8, something changed. gives a = 3 and b is not defined, gives a is not defined and b = 5, and gives c = 5, a is not defined and b = 5. Even if this may be ugly, assignments can be done inside conditional expressions after Python 3.8. Anyway, it is still better to use normal if statement instead in this case.", "abstract": ""}, {"id": 61896436, "score": 12, "vote": 0, "content": "Other answers correctly talk about the Python ternary operator. I would like to complement by mentioning a scenario for which the ternary operator is often used, but for which there is a better idiom. This is the scenario of using a default value. Suppose we want to use option_value with a default value if it is not set: or, if option_value is never set to a falsy value (0, \"\", etc.), simply However, in this case an ever better solution is simply to write", "abstract": ""}, {"id": 60876846, "score": 0, "vote": 0, "content": "I find the default Python syntax val = a if cond else b cumbersome, so sometimes I do this: Of course, it has the downside of always evaluating both sides (a and b), but the syntax is way clearer to me.", "abstract": ""}, {"id": 58409100, "score": 34, "vote": 0, "content": "As already answered, yes, there is a ternary operator in Python: In many cases <expression 1> is also used as Boolean evaluated <condition>. Then you can use short-circuit evaluation. One big pro of short-circuit evaluation is the possibility of chaining more than two expressions: When working with functions it is more different in detail: PS: Of course, a short-circuit evaluation is not a ternary operator, but often the ternary is used in cases where the short circuit would be enough. It has a better readability and can be chained.", "abstract": ""}, {"id": 60630600, "score": 10, "vote": 0, "content": "Python has a ternary form for assignments; however there may be even a shorter form that people should be aware of. It's very common to need to assign to a variable one value or another depending on a condition. ^ This is the long form for doing such assignments. Below is the ternary form. But this isn't the most succinct way - see the last example. With Python, you can simply use or for alternative assignments. The above works since li1 is None and the interpreter treats that as False in logic expressions. The interpreter then moves on and evaluates the second expression, which is not None and it's not an empty list - so it gets assigned to a. This also works with empty lists. For instance, if you want to assign a whichever list has items. Knowing this, you can simply such assignments whenever you encounter them. This also works with strings and other iterables. You could assign a whichever string isn't empty. I always liked the C ternary syntax, but Python takes it a step further! I understand that some may say this isn't a good stylistic choice, because it relies on mechanics that aren't immediately apparent to all developers. I personally disagree with that viewpoint. Python is a syntax-rich language with lots of idiomatic tricks that aren't immediately apparent to the dabbler. But the more you learn and understand the mechanics of the underlying system, the more you appreciate it.", "abstract": ""}, {"id": 49653070, "score": 28, "vote": 0, "content": "The ternary conditional operator simply allows testing a condition in a single line replacing the multiline if-else making the code compact. [on_true] if [expression] else [on_false] Above approach can be written as:", "abstract": ""}, {"id": 53922638, "score": 16, "vote": 0, "content": "Many programming languages derived from C usually have the following syntax of the ternary conditional operator: At first, the Python's benevolent dictator for life (I mean Guido van Rossum, of course) rejected it (as non-Pythonic style), since it's quite hard to understand for people not used to C language. Also, the colon sign : already has many uses in Python. After PEP 308 was approved, Python finally received its own shortcut conditional expression (what we use now): So, firstly it evaluates the condition. If it returns True, expression1 will be evaluated to give the result, otherwise expression2 will be evaluated. Due to lazy evaluation mechanics \u2013 only one expression will be executed. Here are some examples (conditions will be evaluated from left to right): Ternary operators can be chained in series: The following one is the same as previous one:", "abstract": ""}, {"id": 52919467, "score": 15, "vote": 0, "content": "Yes, Python have a ternary operator, here is the syntax and an example code to demonstrate the same :)", "abstract": ""}, {"id": 39067220, "score": 105, "vote": 0, "content": "Here I just try to show some important differences in the ternary operator between a couple of programming languages.", "abstract": ""}, {"id": 45779600, "score": 27, "vote": 0, "content": "You can do this: Example: This would print \"odd\" if the number is odd or \"even\" if the number is even. The result: If condition is true, exp_1 is executed, else exp_2 is executed. Note: 0, None, False, emptylist, and emptyString evaluates as False. And any data other than 0 evaluates to True. If the condition [condition] becomes \"True\", then expression_1 will be evaluated, but not expression_2. If we \"and\" something with 0 (zero), the result will always to be false. So in the below statement, The expression exp won't be evaluated at all since \"and\" with 0 will always evaluate to zero and there is no need to evaluate the expression. This is how the compiler itself works, in all languages. In the expression exp won't be evaluated at all since \"or\" with 1 will always be 1. So it won't bother to evaluate the expression exp since the result will be 1 anyway (compiler optimization methods). But in case of The second expression exp2 won't be evaluated since True and exp1 would be True when exp1 isn't false. Similarly in The expression exp1 won't be evaluated since False is equivalent to writing 0 and doing \"and\" with 0 would be 0 itself, but after exp1 since \"or\" is used, it will evaluate the expression exp2 after \"or\". Note:- This kind of branching using \"or\" and \"and\" can only be used when the expression_1 doesn't have a Truth value of False (or 0 or None or emptylist [ ] or emptystring ' '.) since if expression_1 becomes False, then the expression_2 will be evaluated because of the presence \"or\" between exp_1 and exp_2. In case you still want to make it work for all the cases regardless of what exp_1 and exp_2 truth values are, do this:", "abstract": ""}, {"id": 37155553, "score": 27, "vote": 0, "content": "More a tip than an answer (I don't need to repeat the obvious for the hundredth time), but I sometimes use it as a one-liner shortcut in such constructs: , becomes: Some (many :) may frown upon it as unpythonic (even, Ruby-ish :), but I personally find it more natural - i.e., how you'd express it normally, plus a bit more visually appealing in large blocks of code.", "abstract": ""}, {"id": 20093702, "score": 32, "vote": 0, "content": "Simulating the Python ternary operator. For example Output:", "abstract": ""}, {"id": 1855173, "score": 123, "vote": 0, "content": "Unfortunately, the solution doesn't have short-circuit behaviour; thus both falseValue and trueValue are evaluated regardless of the condition. This could be suboptimal or even buggy (i.e. both trueValue and falseValue could be methods and have side effects). One solution to this would be (execution delayed until the winner is known ;)), but it introduces inconsistency between callable and non-callable objects. In addition, it doesn't solve the case when using properties. And so the story goes - choosing between three mentioned solutions is a trade-off between having the short-circuit feature, using at least Python 2.5 (IMHO, not a problem anymore) and not being prone to \"trueValue-evaluates-to-false\" errors.", "abstract": ""}, {"id": 394887, "score": 434, "vote": 0, "content": "For versions prior to 2.5, there's the trick: It can give wrong results when on_true has a false Boolean value.1 Although it does have the benefit of evaluating expressions left to right, which is clearer in my opinion. 1. Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?", "abstract": ""}, {"id": 2919360, "score": 353, "vote": 0, "content": " <expression 1> if <condition> else <expression 2> ", "abstract": ""}, {"id": 56099511, "score": 1, "vote": 0, "content": "A neat way to chain multiple operators:", "abstract": ""}, {"id": 53653902, "score": 30, "vote": 0, "content": "Just memorize this pyramid if you have trouble remembering:", "abstract": ""}, {"id": 394815, "score": 206, "vote": 0, "content": "From the documentation: Conditional expressions (sometimes called a \u201cternary operator\u201d) have the lowest priority of all Python operations. The expression x if C else y first evaluates the condition, C (not x); if C is true, x is evaluated and its value is returned; otherwise, y is evaluated and its value is returned. See PEP 308 for more details about conditional expressions. New since version 2.5.", "abstract": ""}, {"id": 470376, "score": 992, "vote": 0, "content": "You can index into a tuple: test needs to return True or False.\nIt might be safer to always implement it as: or you can use the built-in bool() to assure a Boolean value:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/19979178/what-is-the-idiomatic-go-equivalent-of-cs-ternary-operator", "keywords": [], "tags": ["go", "ternary-operator", "conditional-operator"], "question": {"id": 19979178, "title": "What is the idiomatic Go equivalent of C&#39;s ternary operator?", "content": "In C/C++ (and many languages of that family), a common idiom to declare and initialize a variable depending on a condition uses the ternary conditional operator : Go doesn't have the conditional operator. What is the most idiomatic way to implement the same piece of code as above ? I came to the following solution, but it seems quite verbose Is there something better ?", "abstract": ""}, "answers": [{"id": 76062424, "score": 3, "vote": 0, "content": "With generics now being there, one can make this silly function... ...which then can be used this way... Possibly harnessing the power of generics in a wrong way D:", "abstract": ""}, {"id": 19979289, "score": 166, "vote": 0, "content": "No Go doesn't have a ternary operator. Using if/else syntax is the idiomatic way. There is no ternary testing operation in Go. You may use the following to achieve the same result: The reason ?: is absent from Go is that the language's designers had seen the operation used too often to create impenetrably complex expressions. The if-else form, although longer, is unquestionably clearer. A language needs only one conditional control flow construct. \u2014 Frequently Asked Questions (FAQ) - The Go Programming Language", "abstract": ""}, {"id": 74700614, "score": 1, "vote": 0, "content": "I was playing with a solution that doesn't use the three arguments function.\nDon't take me wrong, the three arguments solution works great but personally i like to name things explicitly. What i'd love is an explicit interface like that: I implemented this like that: Usage: Unfortunately i didn't find a way to get rid of the explicit type when calling the When function. The type is not automatically inferred by the return types of Then/Else \ud83e\udd37\u200d\u2642\ufe0f", "abstract": ""}, {"id": 72987077, "score": 5, "vote": 0, "content": "Now with the release of go1.18 generics, it's very easy to do it with a generic function like this, and it is reusable through your whole app be aware if you use it in this case it will crash.\nin this case, just use an if statement,\n(because you passing into the function a nil pointer VS an if statement is not calling that section if it is false) the solution call it with a function, so it will not be excuted if it's false but in this case, I think a regular if statement is cleaner (except if go adds arrow functions in the future)\nplayground give credit for this answer he already answered it", "abstract": ""}, {"id": 59375088, "score": 61, "vote": 0, "content": "Foreword: Without arguing that if else is the way to go, we can still play with and find pleasure in language-enabled constructs. Go 1.18 generics update: Go 1.18 adds generics support. It is now possible to create a generic If() function like this. Note: This is available in github.com/icza/gog, as gog.If() (disclosure: I'm the author). Which you can use like this: The pre-1.18 answer follows: The following If construct is available in my github.com/icza/gox library with lots of other methods, being the gox.If type. Go allows to attach methods to any user-defined types, including primitive types such as bool. We can create a custom type having bool as its underlying type, and then with a simple type conversion on the condition, we have access to its methods. Methods that receive and select from the operands. Something like this: How can we use it? For example a ternary doing max(): A ternary doing abs(): This looks cool, it's simple, elegant, and efficient (it's also eligible for inlining). One downside compared to a \"real\" ternary operator: it always evaluates all operands. To achieve deferred and only-if-needed evaluation, the only option is to use functions (either declared functions or methods, or function literals), which are only called when / if needed: Using it: Let's assume we have these functions to calculate a and b: Then: For example, the condition being current year > 2020: If we want to use function literals: Final note: if you would have functions with different signatures, you could not use them here. In that case you may use a function literal with matching signature to make them still applicable. For example if calca() and calcb() would have parameters too (besides the return value): This is how you could use them: Try these examples on the Go Playground.", "abstract": ""}, {"id": 71826835, "score": 2, "vote": 0, "content": "I have compiled some items and compared the speed. output", "abstract": ""}, {"id": 70056859, "score": 1, "vote": 0, "content": "One more suggestion for the idiomatic approach in Go of ternary operator: Go Playground", "abstract": ""}, {"id": 63802349, "score": 7, "vote": 0, "content": "As others have noted, golang does not have a ternary operator or any equivalent. This is a deliberate decision thought to improve readability. This recently lead me to a scenario where constructing a bit-mask in a very efficient manner became hard to read when written idiomatically, or very inefficient when encapsulated as a function, or both, as the code produces branches: producing: What I learned from this was to leverage a little more Go; using a named result in the function (result int) saves me a line declaring it in the function (and you can do the same with captures), but the compiler also recognizes this idiom (only assign a value IF) and replaces it - if possible - with a conditional instruction. producing a branch-free result: which go then freely inlines. produces https://go.godbolt.org/z/eKbK17", "abstract": ""}, {"id": 59941904, "score": 5, "vote": 0, "content": "One-liners, though shunned by the creators, have their place. This one solves the lazy evaluation problem by letting you, optionally, pass functions to be evaluated if necessary: Output The standalone solution here is also nice, but could be less clear for some uses.", "abstract": ""}, {"id": 45886594, "score": 22, "vote": 0, "content": "This will not outperform if/else and requires cast but works.  FYI: BenchmarkAbsTernary-8 100000000 18.8 ns/op BenchmarkAbsIfElse-8 2000000000 0.27 ns/op", "abstract": ""}, {"id": 34636594, "score": 86, "vote": 0, "content": "Suppose you have the following ternary expression (in C): The idiomatic approach in Go would be to simply use an if block: However, that might not fit your requirements. In my case, I needed an inline expression for a code generation template.  I used an immediately evaluated anonymous function: This ensures that both branches are not evaluated as well.", "abstract": ""}, {"id": 37199664, "score": 4, "vote": 0, "content": "eold's answer is interesting and creative, perhaps even clever. However, it would be recommended to instead do: Yes, they both compile down to essentially the same assembly, however this code is much more legible than calling an anonymous function just to return a value that could have been written to the variable in the first place. Basically, simple and clear code is better than creative code. Additionally, any code using a map literal is not a good idea, because maps are not lightweight at all in Go. Since Go 1.3, random iteration order for small maps is guaranteed, and to enforce this, it's gotten quite a bit less efficient memory-wise for small maps. As a result, making and removing numerous small maps is both space-consuming and time-consuming. I had a piece of code that used a small map (two or three keys, are likely, but common use case was only one entry) But the code was dog slow. We're talking at least 3 orders of magnitude slower than the same code rewritten to use a dual slice key[index]=>data[index] map. And likely was more. As some operations that were previously taking a couple of minutes to run, started completing in milliseconds.\\", "abstract": ""}, {"id": 35233755, "score": 6, "vote": 0, "content": "If all your branches make side-effects or are computationally expensive the following would a semantically-preserving refactoring: with normally no overhead (inlined) and, most importantly, without cluttering your namespace with a helper functions that are only used once (which hampers readability and maintenance). Live Example Note if you were to naively apply Gustavo's approach: you'd get a program with a different behavior; in case val <= 0 program would print a non-positive value while it should not! (Analogously, if you reversed the branches, you would introduce overhead by calling a slow function unnecessarily.)", "abstract": ""}, {"id": 31483763, "score": 65, "vote": 0, "content": "The map ternary is easy to read without parentheses:", "abstract": ""}, {"id": 19979829, "score": 456, "vote": 0, "content": "As pointed out (and hopefully unsurprisingly), using if+else is indeed the idiomatic way to do conditionals in Go. In addition to the full blown var+if+else block of code, though, this spelling is also used often: and if you have a block of code that is repetitive enough, such as the equivalent of int value = a <= b ? a : b, you can create a function to hold it: The compiler will inline such simple functions, so it's fast, more clear, and shorter.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/5995350/equivalent-of-abc", "keywords": [], "tags": ["python"], "question": {"id": 5995350, "title": "equivalent of `a?b:c`", "content": "How can I implement this logic more simply? The best I have right now is print(['M', 'F'][int(isfemale_bit)]).\nIs there a better alternative?", "abstract": ""}, "answers": [{"id": 5995387, "score": 60, "vote": 0, "content": "In Python 2.5, you can use ternary conditionals like this: There is more discussion here: Does Python have a ternary conditional operator?", "abstract": ""}, {"id": 5995413, "score": 9, "vote": 0, "content": "I guess you are looking for a solution similar o isfemale_bit?'F':'M' in C code\nSo you can use the and-or construction (see Dive Into Python) print isfemale_bit and 'F' or 'M'", "abstract": ""}, {"id": 5995393, "score": 15, "vote": 0, "content": "", "abstract": ""}, {"id": 5995386, "score": 17, "vote": 0, "content": "Ah the ternary operator:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/75119456/syntax-of-ternary-operators-in-c", "keywords": [], "tags": ["c", "variables", "conditional-operator"], "question": {"id": 75119456, "title": "Syntax Of Ternary Operators in C", "content": "I have an exam at uni from C and I was looking through the exams from the previous years and I stumbled over this problem:\nWhat is the value of d after executing the following sequence? There was another exercise like this, but in those parenthesis there were other expressions: I put the 2 codes in ChatGPT and it told me that they are called ternary operators. I understand that in the second example we are comparing a with b, a with c, b with c, then we are giving d a value based on the comparisons. But in the first example, there are no comparisons, only variables. Moreover, the test will be on paper, so I won't be able to run the code on a computer. How do I read the syntax of the first example, what does it mean? Am I still comparing the 3 variables, or is it something different? I ran the codes on CodeBlocks and on VS for both exercises, with the same values (a = 36, b = 20, c = 30), and they both gave me the same answer: and I don't understand how did I get that answer from the second exercise.", "abstract": ""}, "answers": [{"id": 75119763, "score": 0, "vote": 0, "content": "The first ternary statement: is equivalent to this series of if-else: The second one: is equivalent to this series of if-else: Some notes:", "abstract": ""}, {"id": 75119529, "score": 0, "vote": 0, "content": "This is the conditional operator; it selects its second or third operand based on its first operand, which is a condition. It is a ternary operator; it has three operands. (But so does the function call f(a, b), with operands f, a, and b.) Do not use ChatGPT for authoritative information. C 2018 6.5.15 4 specifies the conditional operator: The first operand is evaluated\u2026 The second operand is evaluated only if the first compares unequal to 0; the third operand is evaluated only if the first compares equal to 0; the result is the value of the second or third operand (whichever is evaluated), converted to the type described below. Thus, in c?(a? a: c):(b? c: b), c is evaluated, and the conditional operation proceeds: Evaluation of an object identifier (a, b, or c) simply produces its value. Since c is not zero, (a? a: c) is selected. Since a is not zero, a is selected. a is 36.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/160218/to-ternary-or-not-to-ternary", "keywords": [], "tags": ["conditional-operator"], "question": {"id": 160218, "title": "To ternary or not to ternary?", "content": "I'm personally an advocate of the ternary operator: () ? :  I do realize that it has its place, but I have come across many programmers that are completely against ever using it, and some that use it too often. What are your feelings on it?  What interesting code have you seen using it?", "abstract": ""}, "answers": [{"id": 160295, "score": 268, "vote": 0, "content": "Use it for simple expressions only: Don't chain or nest ternary operators as it hard to read and confusing: Moreover, when using ternary operator, consider formatting the code in a way that improves readability:", "abstract": ""}, {"id": 5970245, "score": 1, "vote": 0, "content": "Use it to: access object (array) properties: return statements: initialize variables: validate arguments: Code examples are in JavaScript.", "abstract": ""}, {"id": 5509999, "score": 0, "vote": 0, "content": "Making code smaller doesn't always mean it's easier to parse. It differs from language to language. In PHP for example, whitespace and line-breaks are encouraged since PHP's lexer first breaks the code up in bits starting with line-breaks and then whitespace. So I do not see a performance issue, unless less whitespace is used. Bad: Good: It doesn't seem like a big issue, but with lexing code in PHP, whitespace is essential. Plus, it also reads a bit better this way.", "abstract": ""}, {"id": 5275297, "score": 1, "vote": 0, "content": "I would say that the number of conditions in a logic expression make it harder to read. This is true of an if statement and this is true of a ternary operator. In a perfect world, there should be one summarizable reason for taking a branch as opposed to others. Chances are that it really is more of a \"business rule\" if your explanation is \"only when this cluster of states occur\". However, in the real world, we don't add intermediate steps to fold states into one expressible state simply to obey the ideal case. We have made inferences about multiple states and have to make a decision on how to handle them. I like ternaries because it's possible to do anything with an if statement. On the other hand: makes it clear that the goal is to find a value for a. Of course, in line with that, there probably shouldn't be more than reasonable side effects. I use an if for long or complex conditions after I've decided whether I have the time to rework conditions upstream so that I'm answering an easier question. But when I use an if, I still try to do parallel processing, just under a different condition. Also my goal is near-single-stream processing. So I often try not to do an else and an if is simply a step off the common path. When you do a lot of single-stream processing, it's much harder for bugs to hide in your code waiting for that one condition that will jump out and break things. As I said above, if you use a ternary to set one thing, or you have a small number of cases you want to test in order to set it to a value, then I just like the readability of a ternary. With one caveat--> NO COMPLEX true CLAUSES Of course that can be decomposed into: And it looks like a (compressed) truth table. Remember that there are more important factors for readability. One of them is block length and another is indentation level. Doing simple things in ternaries doesn't create an impetus to further and further levels of indentation.", "abstract": ""}, {"id": 2473019, "score": 1, "vote": 0, "content": "The ternary operator hands down. They aren't complex if you format properly. Take the leap year example from paxdiablo: This can be written more concise and be made much more readable with this formatting:", "abstract": ""}, {"id": 2389733, "score": 0, "vote": 0, "content": "I like the operator in some situations, but I think some people tend to overuse it and that it can make the code harder to read. I recently stumbled across this line in some open source code I am working to modify. Where Instead of I wonder if the ternary use adds extra overhead to the LINQ statement in this case.", "abstract": ""}, {"id": 1697086, "score": 0, "vote": 0, "content": "One reason no one seems to mention for using the ternary operator, at least in languages, like D, that support type inference is to allow type inference to work for amazingly complicated template types.", "abstract": ""}, {"id": 535490, "score": 0, "vote": 0, "content": "In small doses they can reduce the number of lines and make code more readable; particularly if the outcome is something like setting a char string to \"Yes\" or \"No\" based on the result of a calculation. Example: compared with: The only bug that can occur in simple tests like that is assigning an incorrect value, but since the conditional is usually simple it's less likely the programmer will get it wrong.  Having your program print the wrong output isn't the end of the world, and should be caught in all of code review, bench testing and production testing phases. I'll counter my own argument with now it's more difficult to use code coverage metrics to assist in knowing how good your test cases are.  In the first example you can test for coverage on both the assignment lines; if one is not covered then your tests are not exercising all possible code flows. In the second example the line will show as being executed regardless of the value of X, so you can't be certain you've tested the alternate path (YMMV depending on the ability of your coverage tools). This matters more with the increasing complexity of the tests.", "abstract": ""}, {"id": 535231, "score": 2, "vote": 0, "content": "As so many answers have said, it depends. I find that if the ternary comparison is not visible in a quick scan down the code, then it should not be used. As a side issue, I might also note that its very existence is actually a bit of an anomaly due to the fact that in C, comparison testing is a statement. In Icon, the if construct (like most of Icon) is actually an expression. So you can do things like: ... which I find much more readable than a ternary comparison operator. :-) There was a discussion recently about the possibility of adding the ?: operator to Icon, but several people correctly pointed out that there was absolutely no need because of the way if works. Which means that if you could do that in C (or any of the other languages that have the ternary operator), then you wouldn't, in fact, need the ternary operator at all.", "abstract": ""}, {"id": 535226, "score": 1, "vote": 0, "content": "No. They are hard to read. If/Else is much easier to read. This is my opinion. Your mileage may vary.", "abstract": ""}, {"id": 535195, "score": 3, "vote": 0, "content": "As others have pointed out they are nice for short simple conditions. I especially like them for defaults (kind of like the || and or usage in JavaScript and Python), e.g. Another common use is to initialize a reference in C++. Since references have to be declared and initialized in the same statement you can't use an if statement.", "abstract": ""}, {"id": 535142, "score": 11, "vote": 0, "content": "By the measure of cyclomatic complexity, the use of if statements or the ternary operator are equivalent. So by that measure, the answer is no, the complexity would be exactly the same as before. By other measures such as readability, maintainability, and DRY (don't repeat yourself), either choice may prove better than the other.", "abstract": ""}, {"id": 535122, "score": 4, "vote": 0, "content": "I like them. I don't know why, but I feel very cool when I use the ternary expression.", "abstract": ""}, {"id": 535113, "score": 0, "vote": 0, "content": "It depends :) They are useful when dealing with possibly null references (BTW: Java really needs a way to easily compare two possibly null strings). The problem begins, when you are nesting many ternary operators in one expression.", "abstract": ""}, {"id": 535103, "score": 2, "vote": 0, "content": "If you and your workmates understand what they do and they aren't created in massive groups I think they make the code less complex and easier to read because there is simply less code. The only time I think ternary operators make code harder to understand is when you have more than three or foyr in one line. Most people don't remember that they are right based precedence and when you have a stack of them it makes reading the code a nightmare.", "abstract": ""}, {"id": 535100, "score": 2, "vote": 0, "content": "For simple tasks, like assigning a different value depending on a condition, they're great. I wouldn't use them when there are longer expressions depending on the condition though.", "abstract": ""}, {"id": 535096, "score": 83, "vote": 0, "content": "I love them, especially in type-safe languages. I don't see how this: is any harder than this: I'd argue that ternary operators make everything less complex and more neat than the alternative.", "abstract": ""}, {"id": 422499, "score": 0, "vote": 0, "content": "If you are trying to reduce the amount of lines in your code or are refactoring code, then go for it. If you care about the next programmer that has to take that extra 0.1 millisecond to understand the expression, then go for it anyway.", "abstract": ""}, {"id": 422478, "score": 0, "vote": 0, "content": "The ternary operator is extremely useful for concisely producing comma separated lists. Here is a Java example: It produces: \"1, 2, 3\" Otherwise, special casing for the last comma becomes annoying.", "abstract": ""}, {"id": 168412, "score": 0, "vote": 0, "content": "If your ternary operator ends up taking the whole screen width, then I wouldn't use it. I keep it to just checking one simple condition and returning single values: We actually have some nasty code like this in production...not good:", "abstract": ""}, {"id": 160887, "score": 48, "vote": 0, "content": "Chained I'm fine with - nested, not so much. I tend to use them more in C simply because they're an if statement that has value, so it cuts down on unnecessary repetition or variables: rather than In assignments like this, I find it's less to refactor, and clearer. When I'm working in ruby on the other hand, I'm more likely to use if...else...end because it's an expression too. (Although, admittedly, for something this simple, I might just use the ternary operator anyway.)", "abstract": ""}, {"id": 160780, "score": 0, "vote": 0, "content": "I like it a lot. When I use it, I write it like an if-then-else: one line each for condition, true action, and false action. That way, I can nest them easily. Example: To me, this is reasonably easy to read. It also makes it easy to add subcases or change existing cases.", "abstract": ""}, {"id": 160744, "score": 3, "vote": 0, "content": "I typically use it in things like this:", "abstract": ""}, {"id": 160492, "score": 0, "vote": 0, "content": "Interesting anecdote: I have seen the optimizer weigh the ternary operator as less \"heavy\" for the purposes of inlining than the equivalent if. I noticed this with Microsoft compilers, but it could be more widespread. In particular functions like this would inline: But this wouldn't:", "abstract": ""}, {"id": 160468, "score": 2, "vote": 0, "content": "For simple if cases, I like to use it. Actually it's much easier to read/code for instance as parameters for functions or things like that. Also to avoid the new line I like to keep with all my if/else. Nesting it would be a big no-no in my book. So, resuming, for a single if/else I'll use the ternary operator. For other cases, a regular if/else if/else (or switch).", "abstract": ""}, {"id": 160460, "score": 41, "vote": 0, "content": "The ternary ?: operator is merely a functional equivalent of the procedural if construct.  So as long as you are not using nested ?: expressions, the arguments for/against the functional representation of any operation applies here.  But nesting ternary operations can result in code that is downright confusing (exercise for the reader: try writing a parser that will handle nested ternary conditionals and you will appreciate their complexity). But there are plenty of situations where conservative use of the ?: operator can result in code that is actually easier to read than otherwise. For example: Now compare that with this: As the code is more compact, there is less syntactic noise, and by using the ternary operator judiciously (that is only in relation with the reverseOrder property) the end result isn't particularly terse.", "abstract": ""}, {"id": 160424, "score": -1, "vote": 0, "content": "How would anyone win an obfuscated code contest without the ternary operator?! I'm personally for using it, when appropriate, but I don't think I'd ever nest it.  It's very useful, but it has a couple knocks against it in that it makes code harder to read and is in use in some other languages in other operations (like Groovy's null-check).", "abstract": ""}, {"id": 160415, "score": 2, "vote": 0, "content": "Only when: KISS.", "abstract": ""}, {"id": 160337, "score": 2, "vote": 0, "content": "I recently saw a variation on ternary operators (well, sort of) that make the standard \"() ? :\" variant seem to be a paragon of clarity: or, to give a more tangible example: Mind you, this is JavaScript, so things like that might not be possible in other languages (thankfully).", "abstract": ""}, {"id": 160293, "score": -2, "vote": 0, "content": "I'm a big fan of it ... when appropriate. Stuff like this is great, and, personally, I don't find it too hard to read/understand: I know that probably makes a lot of people cringe, though. One thing to keep in mind when using it in PHP is how it works with a function that returns a reference.", "abstract": ""}, {"id": 160280, "score": 4, "vote": 0, "content": "I almost never use the ternary operator, because whenever I do use it, it always makes me think a lot more than I have to later when I try to maintain it. I like to avoid verbosity, but when it makes the code a lot easier to pick up, I will go for the verbosity. Consider: Now, that is a bit verbose, but I find it a lot more readable than: Or: It just seems to compress too much information into too little space, without making it clear what's going on. Every time I saw the ternary operator used, I have always found an alternative that seemed much easier to read... then again, that is an extremely subjective opinion, so if you and your colleagues find ternary very readable, go for it.", "abstract": ""}, {"id": 160248, "score": 11, "vote": 0, "content": "I use the ternary operator wherever I can, unless it makes the code extremely hard to read, but then that's usually just an indication that my code could use a little refactoring. It always puzzles me how some people think the ternary operator is a \"hidden\" feature or is somewhat mysterious. It's one of the first things I learnt when I start programming in C, and I don't think it decreases readability at all. It's a natural part of the language.", "abstract": ""}, {"id": 160240, "score": 8, "vote": 0, "content": "I agree with jmulder: it shouldn't be used in place of a if, but it has its place for return expression or inside an expression: The former is just an example, and better internationalisation and localisation support of plural should be used!", "abstract": ""}, {"id": 160226, "score": 3, "vote": 0, "content": "Well, the syntax for it is horrid. I find functional ifs very useful, and they often makes code more readable. I would suggest making a macro to make it more readable, but I'm sure someone can come up with a horrible edge case (as there always is with C++).", "abstract": ""}, {"id": 3946860, "score": 6, "vote": 0, "content": "(Hack of the day) Then you can do if-then-else as expression:", "abstract": ""}, {"id": 2389942, "score": 0, "vote": 0, "content": "I agree with the sentiments of many of the posters here.  The ternary operator is perfectly valid as long as it is used correctly and does not introduce ambiguity (to be fair, you can say that about any operator/construct). I use the ternary operator often in embedded code to clarify what my code is doing.  Take the following (oversimplified for clarity) code samples: Snippet 1: Snippet 2: Here, I am dispatching an input or output request.  The process is the same whether the request is a read or a write, only the default I/O size changes.  In the first sample, I use the ternary operator to make it clear that the procedure is the same and that the size field gets a different value depending on the I/O direction.  In the second example, it is not as immediately clear that the algorithm for the two cases is the same (especially as the code grows much longer than three lines).  The second example would be more difficult to keep the common code in sync.  Here, the ternary operator does a better job of expressing the largely parallel nature of the code. The ternary operator has another advantage (albeit one that is normally only an issue with embedded software).  Some compilers can only perform certain optimizations if the code is not \"nested\" past a certain depth (meaning inside a function, you increase the nesting depth by 1 every time you enter an if, loop, or switch statement and decrease it by 1 when you leave it).  On occasion, using the ternary operator can minimize the amount of code that needs to be inside a conditional (sometimes to the point where the compiler can optimize away the conditional) and can reduce the nesting depth of your code.  In some instances, I was able to re-structure some logic using the ternary operator (as in my example above) and reduce the nested depth of the function enough that the compiler could perform additional optimization steps on it.  Admittedly this is a rather narrow use case, but I figured it was worth mentioning anyway.", "abstract": ""}, {"id": 1507461, "score": 1, "vote": 0, "content": "My recently formulated rule of thumb for determining whether you should use the ternary operator is: And be kind to readers of your code. If you are nesting ternary operators, format the code to make that nesting obvious.", "abstract": ""}, {"id": 535413, "score": 0, "vote": 0, "content": "string someSay = bCanReadThis ? \"No\" : \"Yes\";", "abstract": ""}, {"id": 535193, "score": 6, "vote": 0, "content": "If you're using the ternary operator for a simple conditional assignment I think it's fine.  I've seen it (ab)used to control program flow without even making an assignment, and I think that should be avoided.  Use an if statement in these cases.", "abstract": ""}, {"id": 535191, "score": 0, "vote": 0, "content": "I think it really depends on the context they are used in. Something like this would be a really confusing, albeit effective, way to use them: However, this: is perfectly reasonable. I personally think they should be used when they cut down on overly verbose IF statements. The problem is people are either petrified of them, or like them so much they get used almost exclusively instead of IF statements.", "abstract": ""}, {"id": 535124, "score": 5, "vote": 0, "content": "I've seen such beasts like (it was actually much worse since it was isValidDate and checked month and day as well, but I couldn't be bothered trying to remember the whole thing): where, plainly, a series of if-statements would have been better (although this one's still better than the macro version I once saw). I don't mind it for small things like: or even slightly tricky things like:", "abstract": ""}, {"id": 535107, "score": 18, "vote": 0, "content": "Like so many opinion questions, the answer is inevitably: it depends For something like: I think that is much more concise (and quicker for me to parse) than: Now if your conditional expression is complex, then the ternary operation is not a good choice.  Something like: is not a good candidate for the ternary operator. As an aside, if you are a C programmer, GCC actually has an extension that allows you to exclude the if-true portion of the ternary, like this: Which will set x to y assuming y is not NULL.  Good stuff.", "abstract": ""}, {"id": 535114, "score": 0, "vote": 0, "content": "No (unless they're misused).  Where the expression is part of a larger expression, the use of a ternary operator is often much clearer.", "abstract": ""}, {"id": 535109, "score": 0, "vote": 0, "content": "I used to be in the \u201cternary operators make a line un-readable\u201d camp, but in the last few years I\u2019ve grown to like them when used in moderation. Single line ternary operators can increase readability if everybody on your team understands what\u2019s going on. It\u2019s a concise way of doing something without the overhead of lots of curly braces for the sake of curly braces.  The two cases where I don\u2019t like them: if they go too far beyond the 120 column mark or if they are embedded in other ternary operators. If you can\u2019t quickly, easily and readably express what you\u2019re doing in a ternary operator. Then use the if/else equivalent.", "abstract": ""}, {"id": 535106, "score": 0, "vote": 0, "content": "No, ternary operators do not increase complexity. Unfortunately, some developers are so oriented to an imperative programming style that they reject (or won't learn) anything else. I do not believe that, for example: is \"more complex\" than the equivalent (but more verbose): or the even more awkward (which I've seen): That said, look carefully at your alternatives on a case-by-case basis. Assuming a propoerly-educated developer, ask which most succinctly expresses the intent of your code and go with that one.", "abstract": ""}, {"id": 160275, "score": 24, "vote": 0, "content": "It's a question of style, really; the subconscious rules I tend to follow are: I like it because it's concise and elegant for simple assignment operations.", "abstract": ""}, {"id": 162525, "score": 2, "vote": 0, "content": "I like Groovy's special case of the ternary operator, called the Elvis operator:  ?: This code evaluates to expr if it's not null, and default if it is. Technically it's not really a ternary operator, but it's definitely related to it and saves a lot of time/typing.", "abstract": ""}, {"id": 161172, "score": 0, "vote": 0, "content": "I use and recommend ternaries to avoid code lines in situations where the logic is trivial. In the above case I would choose a ternary, because it has less noise: Likewise conditional return values are good candidates: I think compactness can improve readability which in turn helps to improve the code quality. But readability always depends on the code's audience. The readers must be able to understand the a ? b : c pattern without any mental effort.\nIf you can not presume this, go for the long version.", "abstract": ""}, {"id": 160231, "score": 10, "vote": 0, "content": "I use it quite often in places where I'm constrained to work in a constructor - for example, the new .NET 3.5 LINQ to XML constructs - to define default values when an optional parameter is null. Contrived example: or (thanks asterite) No matter whether you use the ternary operator or not, making sure your code is readable is the important thing. Any construct can be made unreadable.", "abstract": ""}, {"id": 160238, "score": 160, "vote": 0, "content": "It makes debugging slightly more difficult since you can not place breakpoints on each of the sub expressions. I use it rarely.", "abstract": ""}, {"id": 160291, "score": 4, "vote": 0, "content": "I like using the operator in debug code to print error values so I don't have to look them up all the time.  Usually I do this for debug prints that aren't going to remain once I'm done developing.", "abstract": ""}, {"id": 160253, "score": 5, "vote": 0, "content": "I think the ternary operator should be used when needed. It is obviously a very subjective choice, but I find that a simple expression (specially as a return expression) is much clearer than a full test. Example in C/C++: Compared to: You also have the case where the solution is between the ternary operator and creating a function. For example in Python: The alternative is: It is needed enough that in Python (as an example), such an idiom could be seen regularly: this line uses properties of the logical operators in Python: they are lazy and returns the last value computed if it is equal to the final state.", "abstract": ""}, {"id": 160236, "score": 3, "vote": 0, "content": "I treat ternary operators a lot like GOTO. They have their place, but they are something which you should usually avoid to make the code easier to understand.", "abstract": ""}, {"id": 160221, "score": 14, "vote": 0, "content": "In my mind, it only makes sense to use the ternary operator in cases where an expression is needed. In other cases, it seems like the ternary operator decreases clarity.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55450694/is-there-a-c-like-exp1-exp2-exp3-in-python", "keywords": [], "tags": ["python", "refactoring"], "question": {"id": 55450694, "title": "Is there a c like &#39;Exp1 ? Exp2 : Exp3&#39; in Python?", "content": "i would like to know if there is an adequate python alternative for my beloved C Makro 'Exp1 ? Exp2 : Exp3'. I already tried to google but can't seem to find anything.  Example:", "abstract": ""}, "answers": [{"id": 55450734, "score": 0, "vote": 0, "content": "For Python 3.x: Ternary Operators: i.e: For Python 2.5 and older versions: Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?: [expr.] and [trueExp] or [falseExp ] i.e:", "abstract": ""}, {"id": 55450835, "score": 0, "vote": 0, "content": "Python does not have exactly something like Exp1 ? Exp2 : Exp3. However, you can  condense if-else statements into a single line. Something like Exp2 if Exp1 else Exp3 would be somewhat Python equivalent of what you are looking for. (I have followed the order in which you have written the C code) More precisely, it is something like: TrueVal if Expression else FalseVal.", "abstract": ""}, {"id": 55450769, "score": 0, "vote": 0, "content": "What you are looking for is called a ternary operator. There are multiple ways to achieve this in Python, but you will most often find this construct:", "abstract": ""}, {"id": 55450745, "score": 2, "vote": 0, "content": "It looks like this in your case", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52201848/how-is-ternary-operator-implemented-in-python", "keywords": [], "tags": ["python", "python-3.x", "ternary-operator", "cpython", "python-internals"], "question": {"id": 52201848, "title": "How is ternary operator implemented in Python", "content": "I understand that conditional expressions (or ternary operators) are lazy in Python. They represent conditional execution rather than conditional selection. In other words, only one of a or b is evaluated in the following: What I'm interested to know is how this is implemented internally. Does Python convert to an if statement as below and, if so, at what stage does this conversion occur? Or is the ternary operator actually a distinct and separate expression, defined entirely separately? If so, can I access the CPython code for conditional expressions? I've looked at the following which explain what the ternary operator does, but none of them make clear how they are implemented: Edit: You can assume CPython reference implementation.", "abstract": ""}, "answers": [{"id": 52201982, "score": 12, "vote": 0, "content": "Python doesn't have to convert anything, and couldn't if it wanted to. The conditional expression is parsed by using the language grammar into an abstract syntax tree, which in turn is then compiled to bytecode. You can produce the AST by using the ast.parse() function: Note the ast.IfExp() node in the AST produced for the assignment; this is a dedicated node for conditional expressions. It has test, body and orelse parts to represent the 3 expressions that make up the condition, true and false parts. This is documented in the ast module Abstract Grammar section: This shows that the type of each element is another expr expression node. The parse tree is then compiled to bytecode that uses the stack to conditionally jump to the right section based on the test; we can pass the AST produced by ast.parse() directly to the compile() function, after which the dis module lets us look at a human-friendly form of the bytecode produced by compilation: So if the condition is false, the interpreter loop jumps forward to instruction 8, otherwise instructions 4 and 6 are executed, with instruction 6 jumping forward to instruction 10 (so past the else expression). The end result is that either instruction 4 or instruction 8 puts a new result on the top of the stack for STORE_NAME to move to a variable. An if statement results in a different AST node, and the resulting bytecode happens to be very similar in that it too would use jumps. But the compiler treats them as distinct pieces of syntax, and it has to. Expressions and statements are two very different fundamental building blocks of a programming language. Statements can contain expressions, but expressions can't contain statements, only other expressions. And expressions can produce a value (for the surrounding syntax to use), but statements can't. So Python has to treat conditional expressions very differently from statements, in that the grammar parser knows when to expect a statement and when an expression is allowed. If you transformed a conditional expression into a statement, you would not be able to ever use such an expression as part of a bigger expression! Because an if statement is not an expression, it doesn't return a value (as only expressions can produce a value), and so the resulting bytecode would not produce a value on the top of the stack to be used by the surrounding Python code (there is no c = if condition : ...). if statements contain a condition expression, and a suite, which must always consist of more statements (there is such a thing as an 'expression statement' to let you put just an expression in a statement, such as 1 + 1 on a single line), and those statements can 'do stuff' like assignments or return from a function, but nothing they do would ever make if return something. This is reflected in the AST node definition for if statements: So for an If node, test is the only expression node, and body and orelse both consist of zero or more statements. The orelse part would hold any elif ...: tests as further If() nodes, or any other type of statement to form an unconditional else:. With zero-or-more elements, you can't expect a single result. So this isn't unique to CPython, this applies to all Python implementations. The Python grammar is not an implementation detail.", "abstract": ""}, {"id": 52202089, "score": 0, "vote": 0, "content": "If you are asking what, then to best understand it, you need to understand the difference between functional and procedural. One can be converted to the other, but both can be view independently, you don't have to translate one to the other to understand them. value_a if condition else value_b is functional, and returns a value value_a or value_b. is procedural, it does do_a or do_b. Note: Procedural is about doing, do this, then do that, or that. Functional is about value, is this or is that. If you are asking how, then you will need to look at the source-code of one of the implementations. Note that each implementation does not have to do it the same way, so long as behaviour is correct.", "abstract": ""}, {"id": 52202007, "score": 2, "vote": 0, "content": "Does Python convert to an if statement as below Almost. This outputs: These look almost the same, except for the location of JUMP_FORWARD and an additional STORE_FAST as pointed out by @L3viathan. We also get almost the same execution times (with a negligible difference): As to when this conversion happens, I'd assume sometime during \"compilation\" to bytecode.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/45620834/cs-equivalent-to-pythons-or-in-assignment", "keywords": [], "tags": ["c"], "question": {"id": 45620834, "title": "C&#39;s equivalent to Python&#39;s &quot;or&quot; in assignment", "content": "In Python you are able to assign values with the \"or\" operator. two = 2 or None  In the above expression, two will become equal to 2. Can C replicate this? I doubt int two = 2 || NULL; would work, but is there a solution other than an if statement?", "abstract": ""}, "answers": [{"id": 45620968, "score": 2, "vote": 0, "content": "In Python, a or b works like this: So, this is a simple ternary operator: (a)? (a) : (b); Let's take a look at how Python's logical OR operator works internally: So, the or is actually JUMP_IF_TRUE_OR_POP, which is implemented in the CPython source code, line #2939. JUMP_IF_TRUE_OR_POP(target) works like this: It turns out that, as expected, the result is determined with a bunch of if statements.", "abstract": ""}, {"id": 45620864, "score": -1, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/30076116/difference-between-c-and-python-ternary-operators", "keywords": [], "tags": ["python", "c", "ternary-operator"], "question": {"id": 30076116, "title": "Difference Between C and Python Ternary Operators", "content": "Well I just read a SOF thread where I see many people are talking about Python's ternary operator. I didn't know that Python has a ternary operator (ternary operator or conditional expression whatever you feel comfort with) equivalent though. So the syntax of Python ternary operator is... Here Python will test the block sun_shines after if. If the block returns true it will execute the block play_golf before if otherwise Python will execute the block stay_dumb after else. On the other hand I guess C's ternary operator is more readable. It is like asking a question sun_shines? True? Ok then play_golf otherwise stay_dumb. Now my questions are... Edit: I guess I got the answer to my 2nd question...  Python: true if true else false C: true ? true : false", "abstract": ""}, "answers": [{"id": 30076421, "score": 1, "vote": 0, "content": "Excerpt from the PEP 308 which defines the conditional expression: Many C-derived languages use this syntax: Eric Raymond even implemented this.  The BDFL rejected this for\n  several reasons: the colon already has many uses in Python (even\n  though it would actually not be ambiguous, because the question\n  mark requires a matching colon); for people not used to C-derived\n  language, it is hard to understand. In the PEP you can find the motivations of the decision, I find those appropriate, however this is just a personal opinion. The parsing order is not different from C, as said by @Marcus Muller.", "abstract": ""}, {"id": 30076188, "score": 3, "vote": 0, "content": "Now my questions are... How Python is more Pythonic here? \"Simple is better than complex\" failed here in my opinion. If I am wrong please clarify me. I want to\n  know what I am missing? The English sentence is  we go to the beach if the weather is nice, else we stay at home. Highlight the right words, leave out the fillers: that looks a lot like valid Python ;) Execution order of C and Python conditional expression is completely different I see. No. It's not. First, the line is parsed, then the condition after if is evaluated, then either one of the statements is evaluated.", "abstract": ""}]}]