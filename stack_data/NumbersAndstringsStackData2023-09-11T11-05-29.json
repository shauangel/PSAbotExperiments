[{"link": "https://stackoverflow.com/questions/76154258/convert-function-in-hexadecimal-or-octal-base", "keywords": [], "tags": ["c++", "hex", "buffer", "converters", "octal"], "question": {"id": 76154258, "title": "Convert Function in Hexadecimal or Octal base", "content": "I used to create my own printf. But for some format specifier I had to create, I need a convert function. I found this code on a specific website, I can give you the link if you want to, but I do not understand why they use a buffer and how does it work. why ptr could'nt be : *ptr = respresentation[num % base]", "abstract": ""}, "answers": [{"id": 76154701, "score": 0, "vote": 0, "content": "Your function is wrong because if returns the pointer to a local variable. This may appear to work under certain circumstances, but as explained in numerous comments this yields undefined behaviour because as soon as the function terminates, the local variables do no longer exist. *--ptr = foo is the same as ptr = ptr - 1; *ptr = foo. And this is a corrected version of your function and an example of how to call it. It is rather C code than C++ code (BTW are you actually programming in C or in C++?) and there may be errors as I haven't properly tested it. For memmove read it's documentation. BTW: 50 is too much for BUFFER_LENGTH. As an exercise I le you find out yourself which is the maximum buffer size actually needed.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66684904/octal-or-hexadecimal-number-to-decimal-in-c", "keywords": [], "tags": ["c"], "question": {"id": 66684904, "title": "octal or hexadecimal number to decimal in C", "content": "Scan a number along with its base value. If a number starts with 0 it is octal nd if it starts with 0x it is hexadecimal. print the corresponding decimal value. 3 test cases shows error .please help me with this.", "abstract": ""}, "answers": [{"id": 66686035, "score": 0, "vote": 0, "content": "another way", "abstract": ""}, {"id": 66685899, "score": 0, "vote": 0, "content": "Use scanf i flag: Matches an optionally signed integer; the next pointer\nmust be a pointer to int.  The integer is read in base 16\nif it begins with 0x or 0X, in base 8 if it begins with 0,\nand in base 10 otherwise.  Only characters that correspond\nto the base are used.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65555783/print-a-signed-64-bit-integer-in-hexadecimal-and-octal", "keywords": [], "tags": ["c"], "question": {"id": 65555783, "title": "Print a signed 64-bit integer in hexadecimal and octal", "content": "I'm creating a program that prints a signed 64-bit variable in hexadecimal and octal format. I searched online for the format specifier, but I only found results for unsigned 64-bit integers.", "abstract": ""}, "answers": [{"id": 65555867, "score": 4, "vote": 0, "content": "Specifiers %o and %x indeed are defined for unsigned integral values only. In case of a signed input, and if you want to show a signed value like -234 with a \"sign\" in hex as well, e.g. -ea, you'll have to handle signed values separately.\nOtherwise, if you want a negative value to show up as the proper unsigned conversion (i.e. the two's complement representation), simply cast it to unsigned: Output:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/63997346/scanning-an-octal-and-hexadecimal-number-in-d-format-specifier-with-scanf", "keywords": [], "tags": ["c", "hex", "scanf", "format-specifiers", "octal"], "question": {"id": 63997346, "title": "Scanning an octal and hexadecimal number in %d format specifier with scanf", "content": "I was experimenting with the printing octal and hexadecimal number in C. The following is printing as expected However, when I am scanning 012 using %d 0 is ignored and it is printing 12. What is the reason? When I am scanning 0x12 using %d the output is giving as 0 as follows What is the reason for this? Why they are not giving any runtime errors? Thanks in advance!!!", "abstract": ""}, "answers": [{"id": 63997832, "score": 1, "vote": 0, "content": "Explanation In the case of first code snippet, you are assigning a=10 (which is represented as octal 012) and printing it in decimal format. When you're using scanf with %d, it expects an integer in decimal format. So it ignores the first 0 and assigns b = 12. And when you print it, you see 12. In the above case, you are asking scanf to read an integer in decimal format and when you enter 0x12, it stops scanning at character x after reading 0 since x cannot be a part of a valid integer. Solution So here is the way to go.", "abstract": ""}, {"id": 63997403, "score": 2, "vote": 0, "content": "The %d format specifier to scanf explicitly expects a number formatted as a decimal integer.  So when you enter \"012\" is reads 12 since the leading 0 is essentially ignored.  Then when you enter \"0x12\", the scanning stops at the character \"x\" so the value 0 is read. If you use the %i format specifier, it will use hex if the string starts with \"0x\", octal if it starts with \"0\" and decimal otherwise.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/50303656/how-does-java-treat-octal-and-decimal-number", "keywords": [], "tags": ["java"], "question": {"id": 50303656, "title": "how does java treat octal and decimal number", "content": "I am not able to understand how java stores the value specified as octal and hexadecimal value.i need an explanation for the output of the following code snippet. The output produced by this code is  a detailed explanation on the output would be of great help.Thanks in advance", "abstract": ""}, "answers": [{"id": 50303980, "score": 1, "vote": 0, "content": "Basically if an assigned integer value begins with 0,it is considered to be an octal value and if the assigned integer value begins with 0x it is taken as hexadecimal value.  Decimal system is used for programming as it is easy to comprehend. In java,\n'println' outputs a single value after converting the value using the appropriate 'toString' method.By default toString() does not pass any radix value explicitly and processes value as radix of type decimal. Refer source As for your snippet, the following illustration will show how you arrive at the obtained result. b=017 is an octal value as it begins with '0'.Octal to decimal conversion takes place before the result is printed. CONVERSION:  (8^0) * 7 + (8^1) * 1 = 7+8 = 15 c=0X3A is a hexadecimal value as it begins with '0X'. Hexadecimal to decimal conversion takes place. CONVERSION: (16^0) * A + (16^1) * 3 = 10+48 =58 [since [A-F] in hexadecimal system indicates values [10-15] Thus we have a=10 b=15 and c=58 NOTE: If you need to print hexa or octal value as such you can change the format specifier. OUTPUT: 3a 17", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/47199335/why-would-you-write-in-octal-hexadecimal-binary-over-standard-notation", "keywords": [], "tags": ["php", "binary", "hex", "octal"], "question": {"id": 47199335, "title": "Why would you write in Octal/Hexadecimal/Binary over Standard Notation?", "content": "I was reading the PHP documentation on Integers, where it's specifies the different ways in which you can specify which notation to use. Here's a snippet of the doc for anyone interested. However, in PHP (and even some other programming languages where applicable), why would you ever choose to write in Octal, Hexadecimal, or Binary notation over Standard Notation (base 10). Doesn't this just make the numbers more difficult to read for other programmers? Is there a physical boost in performance in any way by using one notation over another? Is it counter intuitive if you have to change the notation later to be readable by users? E.g. Record users age in Hexadecimal but display it in standard.", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/33955243/how-adding-a-hexadecimal-value-with-integer-work", "keywords": [], "tags": ["c", "hex", "literals"], "question": {"id": 33955243, "title": "How adding a hexadecimal value with integer work?", "content": "In the below code ,variable 'b' holds value '133' which is quite straight forward. How about variable 'a' ? Why is it '131' ? I see the only difference is '015' instead of '15'. Can someone let me know whats going on in here ?", "abstract": ""}, "answers": [{"id": 33955294, "score": 7, "vote": 0, "content": "Leading zeros indicate that the number is expressed in octal. 015 in octal is 13 in decimal notation. octal-literal is the digit zero (0) followed by zero or more octal digits (0, 1, 2, 3, 4, 5, 6, 7)  (from cppreference)", "abstract": ""}, {"id": 33955335, "score": 3, "vote": 0, "content": "015 is actually a indicator for octal number system representation, so 015 means  1x8^1 + 5*8^0 = 13 So  Strictly speaking means (1*(8^1) + 5*(8^0) ) + (7*(16^1) + 1*(16^0)) + (5*(10^0)) = 133", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/30901500/assign-octal-hex-declared-int-uint-to-another-variable", "keywords": [], "tags": ["c++", "winapi", "int", "octal", "uint"], "question": {"id": 30901500, "title": "Assign octal/hex declared INT/UINT to another variable", "content": "My WIN32 (C++) code has a UINT lets call it number.\nThe value of this UINT (or INT doesn't matter) start with a 0 and is recognized as an octal value. It's possible to use the standart operators and the value will keep the octal-system. The same is possible with hex (with foregoing 0x).\nThe problem is I have to use the Value of number in a buffer to calculate with it without changing the value of number. I can assign a value like 07777 to buffer on declaration line but if use an operation like buffer = number the value in buffer is recognized on decimal base. Anybody has a solution for me?", "abstract": ""}, "answers": [{"id": 30901722, "score": 7, "vote": 0, "content": "There's no such thing in C as an \"octal value\". Integers are stored in binary. For example, these three constants: all have exactly the same type and value. They're just different notations -- and the difference exists only in your source code, not at run time. Assigning an octal constant to a variable doesn't make the variable octal. For example, this: stores the value ten in n. You can print that value in any of several formats: In all three cases, the stored value is converted to a human-readable sequence of characters, in decimal, octal, or hexadecimal. Anybody has a solution for me? No, because there is no actual problem. (Credit goes to juanchopanza for mentioning this in a comment.)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/14091444/differences-in-assignment-of-integer-variable", "keywords": [], "tags": ["c++", "variables", "variable-assignment"], "question": {"id": 14091444, "title": "Differences in assignment of integer variable", "content": "I just asked this question and it got me thinking if there is any reason  1)why you would assign a int variable using hexidecimal or octal instead of decimal and  2)what are the difference between the different way of assignment", "abstract": ""}, "answers": [{"id": 14091486, "score": 5, "vote": 0, "content": "You may have some constants that are more easily understood when written in hexadecimal.  Bitflags, for example, in hexadecimal are compact and easily (for some values of easily) understood, since there's a direct correspondence 4 binary digits => 1 hex digit - for this reason, in general the hexadecimal representation is useful when you are doing bitwise operations (e.g. masking). In a similar fashion, in several cases integers may be internally divided in some fields, for example often colors are represented as a 32 bit integer that goes like this: 0xAARRGGBB (or 0xAABBGGRR); also, IP addresses: each piece of IP in the dotted notation is two hexadecimal digits in the \"32-bit integer\" notation (usually in such cases unsigned integers are used to avoid messing with the sign bit). In some code I'm working on at the moment, for each pixel in an image I have a single byte to use to store \"accessory information\"; since I have to store some flags and a small number, I use the least significant 4 bits to store the flags, the 4 most significant ones to store the number. Using hexadecimal notations it's immediate to write the appropriate masks and shifts: byte & 0x0f gives me the 4 LS bits for the flags, (byte & 0xf0)>>4 gives me the 4 MS bits (re-shifted in place). I've never seen octal used for anything besides IOCCC and UNIX permissions masks (although in the last case they are actually useful, as you probably know if you ever used chmod); probably their inclusion in the language comes from the fact that C was initially developed as the language to write UNIX. By default, integer literals are of type int, while hexadecimal literals are of type unsigned int or larger if unsigned int isn't large enough to hold the specified value. So, when assigning a hexadecimal literal to an int there's an implicit conversion (although it won't impact the performance, any decent compiler will perform the cast at compile time). Sorry, brainfart. I checked the standard right now, it goes like this: (C++11, \u00a72.14.2, \u00b62 and Table 6) The difference may be relevant for overload resolution1, but it's not particularly important when you are just assigning a literal to a variable. Still, keep in mind that you may have valid integer constants that are larger than an int, i.e. assignment to an int will result in signed integer overflow; anyhow, any decent compiler should be able to warn you in these cases. Let's say that on our platform integers are in 2's complement representation, int is 16 bit wide and long is 32 bit wide; let's say we have an overloaded function like this: Then, calling a(1) and a(0x1) will produce the same result (signed), but a(32768) will print signed and a(0x10000) will print unsigned.", "abstract": ""}, {"id": 14091476, "score": 0, "vote": 0, "content": "It's similar to the assignment of and integer this way: it's all about preference, and when it breaks down you're just doing the same thing. Some might choose octal or hex to go along with their program that manipulates that type of data. ", "abstract": ""}, {"id": 14091469, "score": 3, "vote": 0, "content": "It matters from a readability standpoint - which one you choose expresses your intention. If you're treating the variable as an integral type, you know, like 2+2=4, you use the decimal representation. It's intuitive and straight-forward. If you're using it as a bitmask, you can use hexa, octal or even binary. For example, you'll know will have the last 8 bits set to 1. You'll know that is (...)11110000, but you couldn't directly say the same thing about although they are equivalent. It just depends on what you use the numbers for.", "abstract": ""}, {"id": 14091465, "score": 0, "vote": 0, "content": "well the truth is it doesn't matter if you want it on decimal, octal or hexadecimal its just a representation and for your information, numbers in computers are stored in binary(so they are just 0's and 1's) which you can use also to represent a number. so its just a matter of representation and readability. NOTE:\nWell in some of C++ debuggers(in my experience) I assigned a number as a decimal representation but in my debugger it is shown as hexadecimal.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/17078299/figuring-out-if-a-number-is-decimal-hexadecimal-or-octal-in-python", "keywords": [], "tags": ["python", "hex", "decimal", "octal"], "question": {"id": 17078299, "title": "figuring out if a number is decimal, hexadecimal, or octal in python", "content": "I'm trying to make a small program that reads in a file with only a single number in it, and then the program prints out whether it is a decimal, hexadecimal, or octal number and then displays the number itself. Here's the rules I made for what numbers are allowed: An integer can be unambiguously specified in decimal, binary, octal or hexadecimal form. All of these forms can begin with an optional sign, which can be a \"+\" or a \"-\" with no separating characters between it and the rest of the integer. A decimal integer can be a single zero or a sequence of one or more decimal digits that starts with a non-zero decimal digit. The decimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. An octal number starts with a zero and is followed by a single zero or a non-empty sequence of octal digits that starts with a non-zero octal digit. An octal digit is one of 0, 1, 2, 3, 4, 5, 6 or 7. A hexadecimal number starts with a zero and is followed by an upper or lower case \"x\", and either a single zero or a non-zero hexadecimal digit and a sequence of zero or more hexadecimal digits. Hexadecimal digits include the decimal digits and the letters a, b, c, d, e and f and their uppercase versions. Notice how long and confusing this description has to be to ensure that it is unambiguous. \"Leading zeros\" aren't allowed in any of the representations, e.g., 0x007 is a bad hex number, and 007 is both a bad octal number and a bad decimal number. I guess I'm just having trouble on how to get the program to figure out what kind of number is it. ", "abstract": ""}, "answers": [{"id": 17078307, "score": 4, "vote": 0, "content": "As a starting point, you can try to use the int() function with a 0 argument to let it figure out the conversion: That said, a regular expression is your best bet for distinguishing your exact specifications.  For example, here is a hex recognizer:", "abstract": ""}]}]