[{"link": "https://stackoverflow.com/questions/710551/use-import-module-or-from-module-import", "keywords": [], "tags": ["python", "python-import"], "question": {"id": 710551, "title": "Use &#39;import module&#39; or &#39;from module import&#39;?", "content": "I've tried to find a comprehensive guide on whether it is best to use import module or from module import. I've just started with Python and I'm trying to start off with best practices in mind. Basically, I was hoping if anyone could share their experiences, what preferences other developers have and what's the best way to avoid any gotchas down the road?", "abstract": ""}, "answers": [{"id": 74098243, "score": 0, "vote": 0, "content": "There is a crucial aspect of these imports that @ahfx already mentioned, namely the internals of the process of loading modules. This pops up if your system needs to use circular imports (e.g. you want to make use of dependency injection in some popular http frameworks). In such cases the from {module} import {function} appears much more aggressive with its requirements on how the loading process proceeds. Let us take the example: importing run via Of all the import possibilities in m2.py (A,B,C,D), the from {module} import {function} is the only one that actually crashes the load process, leading to the infamous (CPython 3.10.6) While I cannot say why this happens, it appears that the from ... import ... statement puts a more stringent requirement on \"how far\" the module in question is already in its initialization process.", "abstract": ""}, {"id": 72823907, "score": 0, "vote": 0, "content": "import module: When you use import module then to use methods of this module you have to write module.method(). Every time you use any method or property then you have to refer to the module. from module import all: When you use from module import all than to use methods of this module you just have to write method() without referring to the module.", "abstract": ""}, {"id": 57629367, "score": 7, "vote": 0, "content": "I would like to add to this. It can be useful to understand how Python handles imported modules as attributes if you run into circular imports. I have the following structure: From main.py I will import the other modules using differnt import methods main.py: dis.dis shows the difference (note module names, a b c d): In the end they look the same (STORE_NAME is result in each example), but this is worth noting if you need to consider the following four circular imports: This works No dice Similar issue... but clearly from x import y is not the same as import import x.y as y This one also works", "abstract": ""}, {"id": 67975106, "score": 3, "vote": 0, "content": "There have been many answers, but none have mentioned testing (with unittest or pytest). Use import foo for external modules to simplify testing. Importing classes/functions (from foo import bar) individually from a module makes red-green-refactor cycles tedious. For example, if my file looks like and my test is At first glance, this seems great. But what happens if I want to implement Thing class in a different file? My structure would have to change like this... Unfortunately, since I used from foo import bar, I need to update my patch to reference the tools module. Essentially, since my test knows too much about implementation, much more than expected needs to be changed to do this refactor. Using import foo, my tests can ignore how the module is implemented and simply patch the whole module. The less implementation details your tests know, the better. That way, if you come up with a better solution (use classes instead of functions, use additional files to separate ideas, etc.), less needs to be changed in your tests to accommodate the refactor.", "abstract": ""}, {"id": 19185936, "score": 279, "vote": 0, "content": "There's another detail here, not mentioned, related to writing to a module. Granted this may not be very common, but I've needed it from time to time. Due to the way references and name binding works in Python, if you want to update some symbol in a module, say foo.bar, from outside that module, and have other importing code \"see\" that change, you have to import foo a certain way. For example: module foo: module a: module b: However, if you import symbol names instead of module names, this will not work. For example, if I do this in module a: No code outside of a will see bar as \"oranges\" because my setting of bar merely affected the name \"bar\" inside module a, it did not \"reach into\" the foo module object and update its bar.", "abstract": ""}, {"id": 66036613, "score": 0, "vote": 0, "content": "I was answering a similar question post but the poster deleted it before i could post. Here is one example to illustrate the differences. Python libraries may have one or more files (modules). For exmaples, or We can define python functions or classes inside any of the files based design requirements. Let's define We can access func1() using one of these methods or or or We can use one of these methods to access foo(): or or or or", "abstract": ""}, {"id": 21547583, "score": 120, "vote": 0, "content": "Even though many people already explained about import vs import from, I want to try to explain a bit more about what happens under the hood, and where all the places it changes are. Imports foo, and creates a reference to that module in the current namespace. Then you need to define completed module path to access a particular attribute or method from inside the module. E.g. foo.bar but not bar Imports foo, and creates references to all the members listed (bar). Does not set the variable foo. E.g. bar but not baz or foo.baz Imports foo, and creates references to all public objects defined by that module in the current namespace (everything listed in __all__ if __all__ exists, otherwise everything that doesn't start with _). Does not set the variable foo. E.g. bar and baz but not _qux or foo._qux. Now let\u2019s see when we do import X.Y: Check sys.modules with name os and os.path: Check globals() and locals() namespace dicts with os and os.path: From the above example we found that only os is inserted in the local and global namespace.\nSo, we should be able to use: But not path. Once you delete the os from locals() namespace, you won't be able to access os as well as os.path even though they exist in sys.modules: We found that in sys.modules we found as same as we did before by using import name OK, let's check how it looks like in locals() and globals() namespace dicts: You can access by using name path not by os.path: Let's delete 'path' from locals(): One final example using an alias: And no path defined:", "abstract": ""}, {"id": 62796069, "score": 1, "vote": 0, "content": "since many people answered here but i am just trying my best :) import module is best when you don't know which item you have to import from module. In this way it may be difficult to debug when problem raises because\nyou don't know which item have problem. form module import <foo> is best when you know which item you require to import and also helpful in more controlling using importing specific item according to your need. Using this way debugging may be easy because you know which item you imported.", "abstract": ""}, {"id": 61181513, "score": 1, "vote": 0, "content": "As Jan Wrobel mentions, one aspect of the different imports is in which way the imports are disclosed. Module mymath Use of mymath: If I imported gcd only for internal use, not to disclose it to users of mymath, this can be inconvenient. I have this pretty often, and in most cases I want to \"keep my modules clean\". Apart from the proposal of Jan Wrobel to obscure this a bit more by using import math instead, I have started to hide imports from disclosure by using a leading underscore: In larger projects this \"best practice\" allows my to exactly control what is disclosed to subsequent imports and what isn't. This keeps my modules clean and pays back at a certain size of project.", "abstract": ""}, {"id": 61133861, "score": 5, "vote": 0, "content": "This is my directory structure of my current directory: The import statement remembers all intermediate names.\nThese names have to be qualified: The from ... import ... statement remembers only the imported name.\nThis name must not be qualified:", "abstract": ""}, {"id": 57394430, "score": 2, "vote": 0, "content": "One of the significant difference I found out which surprisingly no-one has talked about is that using plain import you can access private variable and private functions from the imported module, which isn't possible with from-import statement.   Code in image:", "abstract": ""}, {"id": 57075774, "score": 0, "vote": 0, "content": "There are some builtin modules that contain mostly bare functions (base64, math, os, shutil, sys, time, ...) and it is definitely a good practice to have these bare functions bound to some namespace and thus improve the readability of your code. Consider how more difficult is to understand the meaning of these functions without their namespace: than when they are bound to some module: Sometimes you even need the namespace to avoid conflicts between different modules (json.load vs. pickle.load)\n\nOn the other hand there are some modules that contain mostly classes (configparser, datetime, tempfile, zipfile, ...) and many of them make their class names self-explanatory enough: so there can be a debate whether using these classes with the additional module namespace in your code adds some new information or just lengthens the code.", "abstract": ""}, {"id": 50189715, "score": 8, "vote": 0, "content": "Since I am also a beginner, I will be trying to explain this in a simple way:\nIn Python, we have three types of import statements which are: 1. Generic imports: this type of import is my personal favorite, the only downside to this import technique is that if you need use any module's function you must use the following syntax: of course, it increases the typing effort but as a beginner, it will help you to keep track of module and function associated with it, (a good text editor will reduce the typing effort significantly and is recommended). Typing effort can be further reduced by using this import statement: now, instead of using math.sqrt() you can use m.sqrt(). 2. Function imports: this type of import is best suited if your code only needs to access single or few functions from the module, but for using any new item from the module you have to update import statement. 3. Universal imports: Although it reduces typing effort significantly but is not recommended because it will fill your code with various functions from the module and their name could conflict with the name of user-defined functions.\nexample:", "abstract": ""}, {"id": 28654914, "score": 5, "vote": 0, "content": "With import, the token must be a module (a file containing Python commands) or a package (a folder in the sys.path containing a file __init__.py.) When there are subpackages: the requirements for folder (package) or file (module) are the same, but the folder or file must be inside package2 which must be inside package1, and both package1 and package2 must contain __init__.py files. https://docs.python.org/2/tutorial/modules.html With the from style of import: the package or module enters the namespace of the file containing the import statement as module (or package) instead of package1.package2.module. You can always bind to a more convenient name: Only the from style of import permits you to name a particular function or variable: is allowed, but is not allowed.", "abstract": ""}, {"id": 710598, "score": 45, "vote": 0, "content": "Both ways are supported for a reason: there are times when one is more appropriate than the other. import module: nice when you are using many bits from the module. drawback is that you'll need to qualify each reference with the module name. from module import ...: nice that imported items are usable directly without module name prefix. The drawback is that you must list each thing you use, and that it's not clear in code where something came from. Which to use depends on which makes the code clear and readable, and has more than a little to do with personal preference. I lean toward import module generally because in the code it's very clear where an object or function came from. I use from module import ... when I'm using some object/function a lot in the code.", "abstract": ""}, {"id": 34892472, "score": 0, "vote": 0, "content": "Import Module - You don't need additional efforts to fetch another thing from module. It has disadvantages such as redundant typing  Module Import From - Less typing &More control over which items of a module can be accessed.To use a new item from the module you have to update your import statement.", "abstract": ""}, {"id": 710603, "score": 614, "vote": 0, "content": "The difference between import module and from module import foo is mainly subjective.  Pick the one you like best and be consistent in your use of it.  Here are some points to help you decide. import module from module import foo Either method is acceptable, but don't use from module import *.   For any reasonable large set of code, if you import * you will likely be cementing it into the module, unable to be removed.  This is because it is difficult to determine what items used in the code are coming from 'module', making it easy to get to the point where you think you don't use the import any more but it's extremely difficult to be sure.", "abstract": ""}, {"id": 21170625, "score": 10, "vote": 0, "content": "Here is another difference not mentioned.  This is copied verbatim from http://docs.python.org/2/tutorial/modules.html Note that when using  the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable. The import statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an ImportError exception is raised. Contrarily, when using syntax like  each item except for the last must be a package; the last item can be a module or a package but can\u2019t be a class or function or variable defined in the previous item.", "abstract": ""}, {"id": 16688845, "score": 12, "vote": 0, "content": "I've just discovered one more subtle difference between these two methods. If module foo uses a following import: Then module bar can by mistake use count as though it was defined in foo, not in itertools: If foo uses: the mistake is still possible, but less likely to be made. bar needs to: This caused some troubles to me. I had a module that by mistake imported an exception from a module that did not define it, only imported it from other module (using from module import SomeException). When the import was no longer needed and removed, the offending module was broken.", "abstract": ""}, {"id": 710861, "score": 4, "vote": 0, "content": "My own answer to this depends mostly on first, how many different modules I'll be using.  If i'm only going to use one or two, I'll often use from ... import since it makes for fewer keystrokes in the rest of the file, but if I'm going to make use of many different modules, I prefer just import because that means that each module reference is self-documenting.  I can see where each symbol comes from without having to hunt around. Usuaully I prefer the self documenting style of plain import and only change to from.. import when the number of times I have to type the module name grows above 10 to 20, even if there's only one module being imported.", "abstract": ""}, {"id": 710831, "score": 4, "vote": 0, "content": "To add to what people have said about from x import *: besides making it more difficult to tell where names came from, this throws off code checkers like Pylint.  They will report those names as undefined variables.", "abstract": ""}, {"id": 710656, "score": 35, "vote": 0, "content": "I personally always use  and then access everything as etc. The reason is that at the same time you have short invocation, and you clearly define the module namespace of each routine, something that is very useful if you have to search for usage of a given module in your source. Needless to say, do not use the import *, because it pollutes your namespace and it does not tell you where a given function comes from (from which module) Of course, you can run in trouble if you have the same module name for two different modules in two different packages, like in this case, of course you run into troubles, but then there's a strong hint that your package layout is flawed, and you have to rethink it.", "abstract": ""}, {"id": 710606, "score": 16, "vote": 0, "content": "Is best when you will use many functions from the module. Is best when you want to avoid polluting the global namespace with all the functions and types from a module when you only need function.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73783464/module-level-import-best-practices", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 73783464, "title": "Module level import best practices", "content": "Im getting a message from pycodestyles in VisualStudio that sais 'module level import not at top of file'. This is because, in my company, there is this big project that looks like this: So I need to use functions in the Utils.py that are going to be shared from different modules (MyModule & AnotherModule in this case). I have been reading a lot about python imports (stackoverflow is full of this kind of questions, maybe we should start thinking this is a not very friendly way to do it..) so I did this: My question is: is there a good way of doing this without restructuring the project? I have read a lot of workarounds, but I would like to know if there is a common-standard-good-way of resolving this. I'm using Python 3.10.7. Thanks in advance", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/69893772/python-best-practices-for-importing-module-inside-my-package", "keywords": [], "tags": ["python", "python-3.x", "pytest"], "question": {"id": 69893772, "title": "Python best practices for Importing module inside my package", "content": "I'm a bit confused (actually a lot) with Python packaging path system. I have this project: These packages should be published in private repository after CI process (if tests passed). Important: Package1 uses package2 while package2 uses package3. So setup.py of package1 looks like this: setup.py of package2 looks like this: The CI flow: Tests for package2 and package3 passed successfully, but the last step - when running pytest for package1 it complains on ModuleNotFoundError in package2: module1.py (of package2): AwsService is just a class defined in module2.py. I changed the import to: from . import AwsService, reinstalled the package and re-ran the package1 tests again. This time pytest complained about import in package3: module1.py (of package3): So I changed the import to from . import module2 and tests started to run. But in module3 of package2 I have from module2 import AwsService and it's ok, so how can I know when I must do relative import and when not?!. I'm completely confused of all this path behavior. Maybe my setup.py is not good or project structure or the way I'm testing it?", "abstract": ""}, "answers": [{"id": 69903823, "score": 0, "vote": 0, "content": "The solution for my problem was just to assign the path to myproject to PYTHONPATH: When you install package locally via pip install . and perform pip freeze you will see that your package was installed, but you will also see the path near your package and the path is like that: file:///Users/yuri/projects/myproject/package1 as kinda reference to the original location and Python doesn't see it. So you have to add the path manually.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66341940/module-importing-good-practice", "keywords": [], "tags": ["python", "class", "oop", "import", "module"], "question": {"id": 66341940, "title": "Module Importing Good Practice", "content": "What is \"good practice\" for importing modules? For example, if I had a module named 'module' and a function named 'func' which would be preferable? 1: 2: 3: 4: I need to make sure my code is written well for this project. Also with importing classes from modules (such as \"from bs4 import BeautifulSoup\") is it fine to import them into the global namespace at the top of my program? If not, do the same rules as here apply?", "abstract": ""}, "answers": [{"id": 66342048, "score": 0, "vote": 0, "content": "For me I prefer #3, my reasoning is: For importing a single class, if that's the only thing you will do with that module I would find that ok, but my point 1 can apply here, if that module also has helper functions and/or other classes, it might be better to import the module then do module.Class().", "abstract": ""}, {"id": 66342041, "score": 0, "vote": 0, "content": "From a performance point of view, import and import from are exactly the same. The interpreter will load the whole module into memory. That leaves you with a choice: which way to do it. I'd go with the one that makes the code more readable and less ambiguous: UPDATE: About local imports, please see this answer. Python will work with local or top-of-file imports. Local import can save you from circular dependency. A better design can also help you with that. You must chose your own poison, it's all about trade-offs.", "abstract": ""}, {"id": 66342055, "score": 0, "vote": 0, "content": "When looking for best practices PEP8 is usually the first place to look. According to PEP8 it's #2: https://www.python.org/dev/peps/pep-0008/#imports I also like #3, but only in certain cases: The danger of using aliases with unknown packages is that the abbreviation might make sense to you, but not to someone else. This could hinder code readability. You can also combine aliases and absolute imports. So option 5 would be:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/9916878/importing-modules-in-python-best-practice", "keywords": [], "tags": ["python", "coding-style", "workflow", "python-import"], "question": {"id": 9916878, "title": "Importing modules in Python - best practice", "content": "I am new to Python as I want to expand skills that I learned using R.\nIn R I tend to load a bunch of libraries, sometimes resulting in function name conflicts. What is best practice in Python. I have seen some specific variations that I do not see a difference between import pandas, from pandas import *, and  from pandas import DataFrame What are the differences between the first two and should I just import what I need.\nAlso, what would be the worst consequences for someone making small programs to process data and compute simple statistics. UPDATE I found this excellent guide. It explains everything.", "abstract": ""}, "answers": [{"id": 29193752, "score": 81, "vote": 0, "content": "When reading other people's code (and those people use very\ndifferent importing styles), I noticed the following problems with\neach of the styles: import modulewithaverylongname will clutter the code further down\nwith the long module name (e.g. concurrent.futures or django.contrib.auth.backends) and decrease readability in those places. from module import * gives me no chance to see syntactically that,\nfor instance, classA and classB come from the same module and\nhave a lot to do with each other.\nIt makes reading the code hard.\n(That names from such an import\nmay shadow names from an earlier import is the least part of that problem.) from module import classA, classB, functionC, constantD, functionE\noverloads my short-term memory with too many names\nthat I mentally need to assign to module in order to\ncoherently understand the code. import modulewithaverylongname as mwvln is sometimes insufficiently\nmnemonic to me. Based on the above observations, I have developed the following\nstyle in my own code: import module is the preferred style if the module name is short\nas for example most of the packages in the standard library.\nIt is also the preferred style if I need to use names from the module in\nonly two or three places in my own module;\nclarity trumps brevity then (\"Readability counts\"). import longername as ln is the preferred style in almost every\nother case.\nFor instance, I might import django.contrib.auth.backends as djcab.\nBy definition of criterion 1 above, the abbreviation will be used\nfrequently and is therefore sufficiently easy to memorize. Only these two styles are fully pythonic as per the\n\"Explicit is better than implicit.\" rule. from module import xx still occurs sometimes in my code.\nI use it in cases where even the as format appears exaggerated,\nthe most famous example being from datetime import datetime\n(but if I need more elements, I will import datetime as dt).", "abstract": ""}, {"id": 37867717, "score": 30, "vote": 0, "content": "Here are some recommendations from PEP8 Style Guide. Imports should usually be on separate lines, e.g.: but it is okay to Imports are always put at the top of the file, just after any module comments and docstrings, and before module globals and constants.\n Absolute imports are recommended \nThey are more readable and make debugging easier by giving better error messages in case you mess up import system. or explicit relative imports Implicit relative imports should never be used and is removed in Python 3. Wildcard imports ( from <module> import * ) should be avoided, as they make it unclear which names are present in the namespace, confusing both readers and many automated tools. Some recommendations about lazy imports from python speed performance tips. import statements can be executed just about anywhere. It's often useful to place them inside functions to restrict their visibility and/or reduce initial startup time. Although Python's interpreter is optimized to not import the same module multiple times, repeatedly executing an import statement can seriously affect performance in some circumstances. the given below is a scenario explained at the page,", "abstract": ""}, {"id": 9916942, "score": 2, "vote": 0, "content": "They are all suitable in different contexts (which is why they are all available). There's no deep guiding principle, other than generic motherhood statements around clarity, maintainability and simplicity. Some examples from my own code:", "abstract": ""}, {"id": 15780908, "score": 8, "vote": 0, "content": "essentially equals following three statements That's it, that is it all.", "abstract": ""}, {"id": 9916900, "score": 55, "vote": 0, "content": "import pandas imports the pandas module under the pandas namespace, so you would need to call objects within pandas using pandas.foo. from pandas import * imports all objects from the pandas module into your current namespace, so you would call objects within pandas using only foo. Keep in mind this could have unexepcted consequences if there are any naming conflicts between your current namespace and the pandas namespace.  from pandas import DataFrame is the same as above, but only imports DataFrame (instead of everything) into your current namespace. In my opinion the first is generally best practice, as it keeps the different modules nicely compartmentalized in your code.", "abstract": ""}, {"id": 9916925, "score": 26, "vote": 0, "content": "In general it is better to do explicit imports.\nAs in: Or: Another option in Python, when you have conflicting names, is import x as y:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/51956302/best-practice-for-nested-python-module-imports", "keywords": [], "tags": ["python", "python-import"], "question": {"id": 51956302, "title": "Best practice for nested Python module imports", "content": "Suppose I have a Python module \"main.py\": And I also need to import the standard math module in \"my_own_module.py\": In this case I think import math in \"main.py\" is redundant and can be omitted. What's best practice in this case:", "abstract": ""}, "answers": [{"id": 51956396, "score": 3, "vote": 0, "content": "does something else than simply including the full text of one file into the other.  It introduces a new namespace with the name math, and this math name will be known in your current namespace.  If you omit the from your main.py file, your command becomes illegal, as the math symbol will be not (recognized) in the main.py namespace.", "abstract": ""}, {"id": 51956503, "score": 0, "vote": 0, "content": "A good question. The short answer is yes, if you use a math function in a py file then you need to import the module at the top regardless of how many times its imported elsewhere. It gets interesting when we throw a thrid file into the mix, lets call this \"explanation.py\" And lets suppose that your \"main.py\" becomes \"my_functions.py\" and contains a function called foo: and in my_own_module.py: and finally explanation.py (new main()) Notice how you DO NOT need to add math if you call the functions imported from another file. I hope that might add further clarity to your enquiry :) However it might be worth noting that this would exclude maths from the current namespace, therefore rendering any further calls to the math functions useless.", "abstract": ""}, {"id": 51956392, "score": 1, "vote": 0, "content": "This is not like, eg #include in C++. The import is not optional. Importing a module is required to be able to refer to its contents. This is true for every single file that does it. ", "abstract": ""}, {"id": 51956372, "score": 5, "vote": 0, "content": "The reference to math.cos in main.py means that import math is required in main.py, regardless of whether my_own_module.py imports it or not.  It is not redundant, and it cannot be omitted (and if you try to omit it, you'll get an error).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44848556/python-import-good-practice", "keywords": [], "tags": ["python", "import"], "question": {"id": 44848556, "title": "Python import good practice?", "content": "For my current python projects, I currently add this lines of code at the beginning of each scripts : Here my_root_folder_name is the name of the root folder of the project. Having this in every script allows to import any of them from any other of them by writing (wherever the importing script is): Where subfolder1 is in the root folder my_root_folder_name (final path is /my_root_folder_name/subfolder1/subfolder2/thescript.py). Is that a good practice ? Do you see any disadvantage of this trick ? What better option do I have ? EDIT: Let say my project is organised as follow: The reason I use this trick is to make sure I can import a script of a subfolder from one another subfolder. This might lead to circular imports if you don't pay attention, but python '..' syntax for imports does as well. It also makes the imports clearer, since every import is done by writing the entire absolute path to the script.    EDIT 2: This piece of code doesn't import every other scripts !!. It just replaces the first (index 0) sys.path value of the script, which is the actual folder where the file is, by the main folder of the project.    ", "abstract": ""}, "answers": [{"id": 45021994, "score": 1, "vote": 0, "content": "The benefit of your approach doesn't justify the cost. The benefit is that you can write everywhere instead of some variant of The cost is that everyone reading your code must now figure out the answers to questions like Once Joe Programmer is convinced the code is bug free and has no bad implications, he can copy and paste it without thinking. But is it worth adding 5 lines of not-so-obvious boilerplate in order to avoid a slightly-ugly import syntax Joe already needs to understand? No. Choose one of these well-understood options:", "abstract": ""}, {"id": 45010431, "score": 1, "vote": 0, "content": "I had the same problem some time ago. In my opinion, this is a problem of the Python language that get complicated in a simple action like import statements. I done the same choise to solve the problem, update the PYTHONPATH enviroment variable via sys.path command. I do in a different way to you, i write a recursive folder explorer and put it into __init__.py in the root folder of your project. The code is the following: I think my solution is good because is portable and you need to write once.", "abstract": ""}, {"id": 45002787, "score": 1, "vote": 0, "content": "Does the solution need to be written inside the Python code itself? Setting PYTHONPATH=/path/to/module/root does exactly what you want.  For example: /tmp/py/modules/qwerty/a/b/target.py /tmp/py/modules/asdf/a/b/source The solution is in fact the same as what you're doing, just outside of Python code. Note that for Python2, you would need to create __init__.py files on each directory in the structure (the files may be empty).  Python3's documentation also says they're required but the example above worked just fine without them.   The updated directory contents would be as follows: (the files __init__.py are not strictly required under asdf for this simple example, but as you want to be able to import all scripts from all others, that's how you would do in your project) As an addtional note, if you keep your Python code above, my only suggestion would be to check for reaching the root folder, lest you end up in an infinite loop in the case where the script was moved and my_root_folder_name is not a component of its new location's path.  For UNIX, I'd do something like this:", "abstract": ""}, {"id": 44848667, "score": 4, "vote": 0, "content": "Generally no, this would not be good practice for a few reasons.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44830327/best-practices-for-importing-rarely-used-package-in-python", "keywords": [], "tags": ["python", "python-import"], "question": {"id": 44830327, "title": "Best practices for importing rarely used package in Python", "content": "My Python package depends on an external library for a few of it's functions. This is a non-Python package and can be difficult to install, so I'd like users to still be able to use my package but have it fail when using any functions that depend on this non-Python package.  What is the standard practice for this? I could only import the non-Python package inside the methods that use it, but I really hate doing this My current setup: The interfaces script myInterface.py imports classA and classB and classB imports the non-Python package. If the import fails I print a warning. If myMethod is called and the package isn't installed there will be some error downstream but I do not catch it anywhere, nor do I warn the user.  classB is imported every time the interface script is called so I can't have anything fail there, which is why I included the pass. Like I said above, I could import inside the method and have it fail there, but I really like keeping all of my imports in one place. From classB.py", "abstract": ""}, "answers": [{"id": 44830931, "score": 5, "vote": 0, "content": "If you are only importing one external library, I would go for something along these lines: The conditional and error checking is only needed if you want to give more descriptive errors. If not you can omit it and let python throw the corresponding error when trying to calling a non-imported module, as you do in your current setup. If multiple functions do use weirdModule, you can wrap the checking into a function: On the other hand, if you have multiple libraries to be imported by different functions, you can load them dynamically. Although it doesn't look pretty, python caches them and there is nothing wrong with it. I would use importlib Again, if multiple of your functions import complicated external modules you can wrap them into: And last, you could create a handler to prevent importing the same module twice, something along the lines of: Although I'm pretty sure that importlib does caching behing the scenes and you don't really need for manual caching. In short, although it does look ugly, there is nothing wrong with importing modules dynamically in python. In fact, a lot of libraries rely on this. On the other hand, if it is just for an special case of 3 methods accessing 1 external function, do use your approach or my first one in case you cant to add custom sception handling.", "abstract": ""}, {"id": 44830992, "score": 0, "vote": 0, "content": "You can also use given below approach to overcome the  problem  that  you're  facing.", "abstract": ""}, {"id": 44830986, "score": 0, "vote": 0, "content": "You can create two separate classes for the two cases. The first will be used when the the package exist . The second will used when the package does not exist.", "abstract": ""}, {"id": 44830851, "score": 3, "vote": 0, "content": "I'm not really sure that there's any best practice in this situation, but I would redefine the function if it's not supported:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/20009855/python-best-practices-import-modules", "keywords": [], "tags": ["python", "import", "module"], "question": {"id": 20009855, "title": "Python best practices import modules", "content": "Got one looping script that run by itself, now I want to add another script inside the first, I've inserted a var at the start of first file, if it's true then load the second module. It work,but I'm wondering if his is a good practice?", "abstract": ""}, "answers": [{"id": 20010586, "score": 1, "vote": 0, "content": "Python modules which 'do things' at global scope become fragile because they work differently when run directly to when they are imported. Also within a Python process a module will only be 'executed' once - on the first import. After that, import detects it's already been loaded and doesn't need to do anything. Have a look at this: http://plope.com/Members/chrism/import_time_side_effects This avoidance of side-effects is also the reason for the typical Python idiom which you will often in see in scripts run from the command line. When run from the command line, the __name__ global variable is the string 'main', but when a module is imported, __name__ is the name of the module, so nothing is run directly.", "abstract": ""}, {"id": 20010238, "score": 1, "vote": 0, "content": "Python is not C with #ifdef and so on and, as such, you should avoid conditional inclusion of code. Or to put it differently: you can do this but it's not recommended practise in Python. Instead you should figure out what the code should do and then write it based on that. For example, you can pass command-line flags to your script and let the runtime behaviour vary depending on which command-line flags were passed. That having been said in Python is common to have the following for modules that may or may not be installed:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6372159/what-is-the-most-pythonic-way-to-import-modules-in-python", "keywords": [], "tags": ["python", "python-import"], "question": {"id": 6372159, "title": "What is the most pythonic way to import modules in python", "content": "Can anyone suggest me what is the most pythonic way to import modules in python? \nLet me explain - i have read a lot of python code and found several different ways of how to import modules or if to be more precise - when to import: Please find samples below. So what is the most pythonic way to import modules in python?", "abstract": ""}, "answers": [{"id": 6373352, "score": 3, "vote": 0, "content": "Do not use from module import *.  This will pollute the namespace and is highly frowned upon.  However, you can import specific things using from; from module import something.  This keeps the namespace clean.  On larger projects if you use a wildcard you could be importing 2 foo or 2 bar into the same namespace. PEP 8 says to have imports on separate lines.  For instance: One thing I do is alphabetize my imports into two groups.  One is std/third party and the second is internal modules.", "abstract": ""}, {"id": 6373166, "score": 6, "vote": 0, "content": "People have already commented on the major style issues (at the top of the script, etc), so I'll skip that. For my imports, I usually have them ordered alphabetically by module name (regardless of whether it's 'import' or 'from ... import ...'. I split it into groups of: standard lib; third party modules (from pypi or other); internal modules.", "abstract": ""}, {"id": 6372388, "score": 3, "vote": 0, "content": "Python's \"import\" loads a Python module into its own namespace, so that you have to add the module name followed by a dot in front of references to any names from the imported module \"from\" loads a Python module into the current namespace, so that you can refer to it without the need to mention the module name again or using from is good, (but using a wildcard import is discouraging). but if you have a big scaled project, importing from diffrent modules may cause naming confilicts. Like importing Elephant() function from two diffrent modules will cause problem (like using wildcard imports with *) So, if you have a large scaled project where you import many diffrent things from other modules, it is better to use import and using imported things with module_name.your_class_or_function. Otherwise, use from notation...", "abstract": ""}, {"id": 6372175, "score": 17, "vote": 0, "content": "It really doesn't matter, so long as you don't from ... import *. The rest is all taste and getting around cyclic import issues. PEP 8 states that you should import at the top of the script, but even that isn't set in stone.", "abstract": ""}]}]