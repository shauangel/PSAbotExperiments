[{"link": "https://stackoverflow.com/questions/71025793/why-do-some-variables-need-self-and-others-dont-in-1-function", "keywords": [], "tags": ["python"], "question": {"id": 71025793, "title": "Why do some variables need `self.` and others don&#39;t, in 1 function?", "content": "i am starting my studies on OPP and I am struggling a little to grasp one concept. I believe this is very basic for you guys here, but I was hoping to get some help with it. I have this code: It is correct, it runs... but I am struggling to learn why I need the prefix self on the position argument and not on the steps within the function move for the class Player? any explanations or reading material suggestions are more than welcome\nthanks", "abstract": ""}, "answers": [{"id": 74740183, "score": -1, "vote": 0, "content": "Recently I faced quite similar problem and when searching the answer I stumbled your question and comprehensive answer given above by Grismar.\nI just want to bring here some practical examples that will show a bit more and reveal under-the-hood gears. Let's start with your code. If we call a few instances like below this will bring us a correct result. Notations p1.__dict__ and p2.__dict__ show what values are actually assigned to a position variable. So, what if we would like to use variable steps somewhere in another method (or methods)? I modified your code just a bit by adding additional method jump() to demonstrate what will happen. This code will not work correctly for the method jump(). But the method move() still correctly executed. To fix the problem and remove exception (here it is NameError: name 'steps' is not defined) we have to \u00abglue\u00bb self and steps. Now we can see that the method move() executed correctly (variable position assigned to 10). The method jump() executed without any exceptions as well. Instance p1 has now two available variables, they are 'position': 10 and 'steps': 100.\nIn other words self.variable notation gives the option to use the variable beyond the \u00abparent\u00bb method.", "abstract": ""}, {"id": 71025973, "score": 4, "vote": 0, "content": "In an example like this: attribute is defined as an attribute (or instance variable) on MyClass. This means that every instance of MyClass (a MyClass object) will have its own copy of attribute. Since every normal method (a function defined on the class) expects the first argument to be the object itself (which you don't have to pass; Python will pass it automatically), you can use self to refer to the instance the method was called on. (I say 'normal', because there are also 'static' and 'class' methods, but forget about those for now.) So, in this example: This works, because in the body of .my_method, the passed value, which gets assigned to some_parameter is assigned to the attribute attribute of an_object, because an_object is assigned to self in that call. Mind you, self could have been called anything; naming the first parameter self is just a convention you should follow. The reason some_parameter does not need self. is because it is just another parameter of a function. It's not an attribute of self \u2014 of the object the method was called on. So, when compared to your code, you should say: steps does not need self. because it is not an attribute of a Player instance. It is just a parameter of a method defined on Player, and the value is accessible like any parameter is in a function body. The instance of a Player object is passed as self, and you can change its attributes by accessing them on self inside the function body. A clue why you didn't grasp this is that you call position an 'argument', but an argument is something passed to a function, to a specific parameter; and a parameter is an internal variable of a function that is assigned the argument. position is an attribute of an object. So, when calling player.move(2), 2 is the argument, steps is the parameter in the body of move() and position is the attribute of player, with player being the Player class instance (or 'object') accessible through the self parameter in the body of move().", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65639571/what-is-the-actual-use-of-self-in-init-in-python", "keywords": [], "tags": ["python"], "question": {"id": 65639571, "title": "What is the actual use of self in init in python?", "content": "", "abstract": ""}, "answers": [{"id": 65639640, "score": 1, "vote": 0, "content": "Imagine you have: When you create a class like this, the self points to an instance. Doing print(instance1.print_1() will print \"hello\", and print(instance2.print_1() will print \"bye\" So, self is a way to differentiate and manage multiple instances of the same class. And different instances will have its own set of different variables.", "abstract": ""}, {"id": 65639617, "score": -1, "vote": 0, "content": "init is the instance of your class. When a class is called this method will be invoked first with the relevant arguments needs to be passed. self.minutes = minutes you are storing the minutes parameter to a new class variable reference called self.minutes. By convention we use self as the first parameter.", "abstract": ""}, {"id": 65639599, "score": 4, "vote": 0, "content": "self represents the instance of the class. Therefore, using self.hours and self.minutes you can set the instance attributes of the object of class Time.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/69937416/passing-in-self-as-a-parameter-in-function-call-in-a-class-python", "keywords": [], "tags": ["python", "class"], "question": {"id": 69937416, "title": "Passing in &quot;self&quot; as a parameter in function call in a class (Python)", "content": "I defined a class and within that class, created some methods. In one of the methods I wish to call another method. What is the reason that I cannot call the method by placing \"self\" into the argument? For example, method2(self).", "abstract": ""}, "answers": [{"id": 69939065, "score": 0, "vote": 0, "content": "You can call a method with self as an argument, but in this case the method should be called as the method of the class, not the instance.", "abstract": ""}, {"id": 69939000, "score": 2, "vote": 0, "content": "There are languages that let you write method2() as a shorthand for (what in Python would be) self.method2(), but you can't in Python. Python doesn't treat the self argument as special inside the function (except when calling super()). In Python, method2(self) first of all looks up method2 in the current scope. It seems like it should be in scope, but it actually isn't because of Python's weird scoping rules. Nothing in any class scope is ever visible in nested scopes: Even if method2 was in scope, calling it directly would call the method from the class currently being defined, not the overridden method appropriate to the dynamic type of self. To call that, you must write self.method2().", "abstract": ""}, {"id": 69937433, "score": 1, "vote": 0, "content": "The self parameter is automatically passed in as the object you are calling the method from. So if I said self.method2(), it automatically figures out that it is calling self.method2(self)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65184615/what-is-the-use-of-the-keyword-self-in-python-object-oriented-programming", "keywords": [], "tags": ["python", "class", "self"], "question": {"id": 65184615, "title": "What is the use of the keyword &quot;self&quot; in Python Object Oriented Programming?", "content": "I just started learning Python, and I'm starting to get into Object-Oriented Programming. I wrote the following code which simply draws shapes using the turtle module, but I still don't quite understand the use of the \"self\" keyword:", "abstract": ""}, "answers": [{"id": 65184652, "score": 1, "vote": 0, "content": "self refers to the instance of the class from inside the class.\nhttps://www.programiz.com/article/python-self-why Here is the content of the link: If you have been programming in Python (object-oriented programming) for some time, then you have definitely come across methods that have self as their first parameter. Let us first try to understand what this recurring self parameter is.\nWhat is self in Python? In object-oriented programming, whenever we define methods for a class, we use self as the first parameter in each case. Let's look at the definition of a class called Cat. In this case all the methods, including init, have the first parameter as self. We know that class is a blueprint for the objects. This blueprint can be used to create multiple numbers of objects. Let's create two different objects from the above class. The self keyword is used to represent an instance (object) of the given class. In this case, the two Cat objects cat1 and cat2 have their own name and age attributes. If there was no self argument, the same class couldn't hold the information for both these objects. However, since the class is just a blueprint, self allows access to the attributes and methods of each object in python. This allows each object to have its own attributes and methods. Thus, even long before creating these objects, we reference the objects as self while defining the class.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64468324/no-value-for-argument-39self39-when-calling-a-method-in-python", "keywords": [], "tags": ["python", "methods", "self", "method-call"], "question": {"id": 64468324, "title": "No value for argument &amp;#39;self&amp;#39; when calling a method in Python", "content": "I did quite a lot of research both within and outside of stackoverflow. Yes, there are similar topics. But I could not find the answer to my specific problem. Maybe because I can not see the bigger picture yet with my current understanding of Python. In the last line I get the error \"No value for argument 'self' in method call\". How would I have to properly call the method here? Or is it not possible at all to call methods within the same class? It might seem that there would be no reason for this class because I do not need to instantiate it. But I want to use the code of Main() in another class Gui() which is responsible for all the GUI stuff. So the different classes are a way for me to organize the code.\nGood approach or not? Thanks in advance for your help!", "abstract": ""}, "answers": [{"id": 64488468, "score": 0, "vote": 0, "content": "Thanks for all of your comments! I figured something out that works. I hope it makes sense, too. And I fixed my indentations.", "abstract": ""}, {"id": 64469238, "score": 1, "vote": 0, "content": "The problem here is that you are writing your class without a init function and that your class doesn't have self variables. For example: Only works because there is the init function. The reasoning for self variables like self.name is so the values can be edited later, like you tried with Main.bps. If you have self.bps in an init function, it can be edited later within your function, given you also write self.bps in the function. I'm not sure about just using things like bpm on their own in a class rather than self.bps because i'm sure bps would be private within the scope of Main disregarding functions. Also, be sure to check your indentations! :)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64430714/python-class-avoid-using-self-parameter-multiple-times-in-function", "keywords": [], "tags": ["python", "class", "self"], "question": {"id": 64430714, "title": "Python Class: avoid using &quot;self&quot; parameter multiple times in function", "content": "I created the following class to generate prime numbers in python: Is there a way to avoid using self parameter in functions multiple times? Like, instead of using self.primeNum every time, can I use only primeNum ?", "abstract": ""}, "answers": [{"id": 64430839, "score": 2, "vote": 0, "content": "In Python, self is used to reference the current instance. Unless you need to keep those values as attributes of your primeGen instances, you can just remove them. You can read more about it here. Example: Edit: as correctly pointed out by @wwii in their answer, maybe you don't need a class at all.", "abstract": ""}, {"id": 64430873, "score": 1, "vote": 0, "content": "Is there a way to avoid using self parameter in functions multiple times Instead of using a class, get your functionality from a function.", "abstract": ""}, {"id": 64430830, "score": 0, "vote": 0, "content": "In your case you can create only self.primeNum. This is the only variable used by other function members of the cass. Do you really need all other variables to be fields of the class? They look like temporary variables. You don't need to add them to the class.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64366138/classes-vs-function-do-i-need-to-use-39self39-keyword-if-using-a-class-in", "keywords": [], "tags": ["python", "function", "class", "object", "self"], "question": {"id": 64366138, "title": "Classes vs Function: Do I need to use &amp;#39;self&amp;#39; keyword if using a class in Python?", "content": "I have a data engineering program that is grabbing some data off of Federal government websites and transforming that data. I'm a bit confused on whether I need to use the 'self' keyword or if it's a better practice to not use a class at all. This is how it's currently organized: I'm mostly using a class here for organization purposes. For instance, there might be a dozen different methods from one class that I need to use. I find it more aesthetically pleasing / easier to type out this: Rather than: Which just has a boatload of underscores. So I'm just curious if this would be considered bad code to use a class like this, without bothering with 'self'? Or should I just eliminate the classes and use a bunch of functions in my files instead?", "abstract": ""}, "answers": [{"id": 64366295, "score": 2, "vote": 0, "content": "I suppose you have a file called data/get_govt_data.py that contains your first code block. You can just rename that file to data/GetGovtData.py, remove the class line and not bother with classes at all, if you like. Then you can do Depending on your setup you may need to create an empty file data/__init__.py for Python to see data as a module. EDIT: Regarding the file naming, Python does not impose any too tight restrictions here. Note however that many projects conventionally use camelCase or CapitalCase to distinguish function, class and module names. Using CapitalCase for a module may confuse others for a second to assume it's a class. You may choose not to follow this convention if you do not want to use classes in your project.", "abstract": ""}, {"id": 64366373, "score": 6, "vote": 0, "content": "If you develop functions within a Python class you can two ways of defining a function: The one with a self as first parameter and the other one without self. So, what is the different between the two? The first one is a method, which is able to access content within the created object. This allows you to access the internal state of an individual object, e.g., a counter of some sorts. These are methods you usually use when using object oriented programming. A short intro can be fund here [External Link]. These methods require you to create new instances of the given class. Functions without initialising an instance of the class. This is why you can directly call them on the imported class. This is based on the comment of Tom K. Instead of using self, you can also use the decorator @staticmethod to indicate the role of the method within your class. Some more info can be found here [External link]. To answer you initial question: You do not need to use self. In your case you do not need self, because you do not share the internal state of an object. Nevertheless, if you are using classes you should think about an object oriented design.", "abstract": ""}, {"id": 64366372, "score": 1, "vote": 0, "content": "To answer the question in the title first: The exact string 'self' is a convention (that I can see no valid reason to ignore BTW), but the first argument in a class method is always going to be a reference to the class instance. Whether you should use a class or flat functions depends on if the functions have shared state. From your scenario it sounds like they may have a common base URL, authentication data, database names, etc. Maybe you even need to establish a connection first? All those would be best held in the class and then used in the functions.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64298914/python-self-function", "keywords": [], "tags": ["python", "function", "self"], "question": {"id": 64298914, "title": "Python self function", "content": "I am modifying some Python code. In this code there is a class called Proxy which has a function \"run\" that is executed. I need to change the self.run = lambda: ('...') so that proxy.run() executes the following code: How do I do this? I don't think I need a lambda expression and I should be using something else. How do I make proxy.run() execute the 2 lines of code from above? Assume I have all the proper dependencies imported and that the Proxy class functions as intended. Thanks in advance for your help. I tried the following: Then I tried proxy.run() and I get the error:", "abstract": ""}, "answers": [{"id": 64298953, "score": 2, "vote": 0, "content": "Usually the way you define a function that's an attribute of an object is to make it a method:", "abstract": ""}, {"id": 64299088, "score": 0, "vote": 0, "content": "Thanks everyone for your contributions, they helped me figure it out.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/54555141/what-is-self-in-python", "keywords": [], "tags": ["python", "self"], "question": {"id": 54555141, "title": "What is self() in python?", "content": "I thought I understood self on some pretty decent level. But I came across this: What does self(...) do?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/49442025/understanding-self-internally-in-python", "keywords": [], "tags": ["python", "python-3.x", "class", "oop", "self"], "question": {"id": 49442025, "title": "Understanding Self Internally in Python", "content": "I fully understand what is being passed to self in this example.  I'm very confused on how it is being passed to self internally.  Could someone help me understand?", "abstract": ""}, "answers": [{"id": 49442675, "score": 13, "vote": 0, "content": "There are many steps that beginner tutorials do not cover, so I will attempt to be brief but thorough. I will try to be precise in my terminology, so you can look up all the sections you are unclear about. In general, methods in Python are functions in the class object. All functions are descriptors. Part of what being a descriptor means is that when you access a method through the instance of a class, it creates a closure that automatically passes the instance you created it on as the self parameter. For example, if Cars had a method start(self) in addition to __init__, then tesla.start would be a \"bound method\", which is a closure that passes tesla as self to Cars.start. Notice that I did not put parentheses after tesla.start. Putting parentheses would actually invoke the bound method. Second piece of information: if a class defines a __call__ special method, its instances are said to be callable. This means that you can invoke an instance as if it were a function using the () operator. You can see a case of this when you do tesla = Cars(...). Here Cars is a class object, but you are calling it as if it were a function. We are now getting close to where self actually gets passed in to __init__. Thirdly, pretty much everything in Python is an object and obeys the general rules you know for objects, like being created from a class, etc. This includes functions and classes. A class object is created from another class, which is appropriately named a metaclass. Normally metaclasses are a can of worms you don't want to open, so we will scratch just enough of the surface here and no more. The most common metaclass is type: 99%1 of all class objects you will encounter as a beginner as instances of type. type defines a __call__ method, which is what you are invoking when you do Cars(...), since Cars is an instance of type. type.__call__(Cars, ...) does a couple of things. First it calls Cars.__new__(Cars, ...). This returns the new instance that you will later end up assigning to tesla or ford or whatever. Then, if the thing that __new__ returned is an instance of Cars, it will call Cars.__init__(self, ...), where self is that new instance it just created. And that's how self gets passed to __init__. Keep in mind that all the steps can be customized or overridden, so this is really just a basic overview of the simplest case. The links in this text should get you started in more specific research. All the links are completely distinct, even when they are for the same term. All the links are to Stack Exchange sites (SO with one exception), or the official Python 3 documentation, with one exception. 1 I made up that statistic, but it's probably right anyway.", "abstract": ""}]}]