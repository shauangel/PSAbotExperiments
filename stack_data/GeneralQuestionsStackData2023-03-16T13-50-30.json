[{"link": "https://stackoverflow.com/questions/75694674/is-there-a-python-linter-to-check-for-a-missing-raise-keyword", "keywords": [], "tags": ["python", "static-analysis", "pylint"], "question": {"id": 75694674, "title": "Is there a Python linter to check for a missing `raise` keyword?", "content": "I have seen the following pattern several times: There is an obvious but relatively easy-to-miss bug here: the raise keyword is missing from ApplicationError. An exception object is constructed but not raised, and an invalid value continues to the rest of the function. We use flake8, pyright, and a select set of pylint lints. My expectation is that some sort of static analysis tool would find this problem: The last option seems like something mypy/pyright should be capable of catching, at least, but I'm completely unable to find any sort of linter for this. Is there a linting tool for Python code that can detect this problem (missing raise keyword) and how to configure it to do so?", "abstract": ""}, "answers": [{"id": 75709627, "score": 3, "vote": 0, "content": "pointless-exception-statement in pylint does what you want, this is a builtin check that is activated by default, see https://pylint.readthedocs.io/en/latest/user_guide/messages/warning/pointless-exception-statement.html", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65749022/python-static-code-analysis-tools-code-analysis-preliminary-research-question", "keywords": [], "tags": ["python", "abstract-syntax-tree", "pylint"], "question": {"id": 65749022, "title": "python static code analysis tools - code analysis (preliminary research question)", "content": "Disclaimer:\nI've just started researching this area/domain of knowledge; so I have no idea what exactly it's called; but through a google search, I believe it has to do with (static code analysis, or at least it's related to it). My question is:\nGiven a python code - file - script - module - package. Is there a tool that can produce a report out of it detailing:\nhow many classes are used, functions, built-in functions; decorators ;if/for/while statements etc? To give you an analogy most of us can relate to:\nGiven a text file: find all the verbs / nouns / adjectives / adverbs / proper noun.\nNLP tools like spaCy or NLTK have the ability to do that for natural languages. But what about programming languages? Is there a tool for that?\nCan a tool like pylint do that? UPDATE As I expected such tools exist; one of them as @BoarGules suggested in his comment is the ast module ... It's the hint I needed to go further in my research; any further suggestions are welcome. BTW ast stands for abstract syntax tree.", "abstract": ""}, "answers": [{"id": 65749199, "score": 1, "vote": 0, "content": "Given a python code - file - script - module - package. Is there a tool that can produce a report out of it detailing: how many classes are used... When that primitive is executed, the set of classes or functions of your Python program can increase. Be aware of Rice's theorem. Consider using abstract interpretation and type inference techniques in your Python static analyzer. Consider also using (painfully) Frama-C on the source code (the code written in C) of the Python interpreter. With a lot of work, Frama-C could be extended to analyze Python source code. (but someone needs to do that work, or to pay for it)\n Read also recent proceedings of ACM SIGPLAN conferences.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/12884623/static-and-dynamic-code-analysis", "keywords": [], "tags": ["code-analysis", "static-code-analysis", "dynamic-analysis"], "question": {"id": 12884623, "title": "static and dynamic code analysis", "content": "I found several questions about this topic, and all of them with lot of references, but still I don't have a clear idea about that, because most of the references speak about concrete tools and not about the concept in general of the analysis. Thus I have some  questions: About Static analysis:\n1. I would like to have a reference, or a summary of which techniques are successful and have more relevance nowadays. \n2. What really can they do about discovering bugs, can we make a summary or it is depending of the tool? About symbolic execution:\n1. Where could be enclose symbolic execution? I guess depending of the approach, \nI would like to know if they are dynamic analysis, or mix of static and dynamic analysis if it is possible to determine. I found problems to differentiated the two different techniques in the tools, even I think I know the theoretical difference.  I'm actually working with C\nThanks in advance ", "abstract": ""}, "answers": [{"id": 29002944, "score": 3, "vote": 0, "content": "The term \"static analysis\" means that the analysis does not actually run a code. On the other hand, \"dynamic analysis\" runs a code and also requires some kinds of real test inputs. That is the definition. Nothing more. Static analysis employs various formal methods such as abstract interpretation, model checking, and symbolic execution. In general, abstract interpretation or model checking is suitable for software verification. Symbolic execution is more appropriate for the purpose of bug finding. Symbolic execution is categorized into static analysis. However, there is a hybrid method called concolic execution which uses both symbolic execution and dynamic testing. Added for Zane's comment: Maybe my explanation was little confusing. The difference between software verification and bug finding is whether the analysis is sound or not. For example, when we say the buffer overrun analyzer is sound, it means that the analyzer must report all possible buffer overruns. If the analyzer reports nothing, it proves the absence of buffer overruns in the target program. Because model checking is the method that guarantees soundness, it is mostly used for software verification. On the other hands, symbolic execution which is actively used by today's most commercial static analyzers does not guarantee soundness since sound analysis inherently issues lots, lots of false positives. For the purpose of bug finding, it is more important to reduce false positives even if some true positives are also lost. In summary, soundness: there are no false negatives completeness: there are no false positives software verification: soundness is more important than completeness bug finding: completeness is more important than soundness", "abstract": ""}, {"id": 12884799, "score": 8, "vote": 0, "content": "I'm trying to give a short answer: Static analysis looks at the syntactical structure of code and draws conclusions about the program behavior. These conclusions must not always be correct. A typical example of static analysis is data flow analysis, where you compute sets like used, read, write for every statement. This will help to find e.g. uninitialized values. You can also analyze the code regarding code-patterns. This way, these tools can be used to check if you are complying to a specific coding standard. A prominent coding standard example is MISRA. This coding standard is used for safety critical systems and avoids problematic constructs in C. This way you can already say a lot about the robustness of your applications against memory leaks, dangling pointers, etc. Dynamic analysis is not looking at the syntax only, but takes state information into account. In symbolic execution, you are adding assumptions about the possible values of all variables to the statements. The most expensive and powerful method of dynamic analysis is model checking, where you really look at all possible execution states of the system. You can think of a model checked system as a system that is tested with 100% coverage - but there are of course a lot of practical problems that prevent real systems to be checked that way. These methods are very powerful, and you can gain a lot from the static code analysis tools especially when combined with a good coding standard. A feature my software team found really impressive is e.g. that it will tell you in C++ when a class with virtual methods does not have a virtual destructor. Easy to check in fact, but really helpful. The commercial tools are very expensive, but worth the money, once you learned how to use them. A typical problem in the beginning is that you will get a lot of false alarms, and don't know where to look for the real problem. Note that nowadays g++ has some of this stuff already built-in, and that you can use something like pclint which is free. Sorry - this is already getting quite long...hope it's interesting.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6025714/tools-for-static-type-checking-in-python", "keywords": [], "tags": ["python", "static-typing"], "question": {"id": 6025714, "title": "Tools for static type checking in Python", "content": "I'm working with a large existing Python codebase and would like to start adding in type annotations so I can get some level of static checking.  I'm imagining something like Erlang, Strongtalk, or Typed Scheme/Racket. I've seen quick-and-dirty decorators that insert dynamic checks based on function parameter and return type annotations, but I'm looking for something that is more robust and that performs checks at compile-time. What tools are available right now for this kind of thing?  I'm familiar with compilers and type checking and am definitely willing to improve an incomplete tool if it has a good foundation. (Note: I'm not interested in a discussion of the pros/cons of static typing.) EDIT: An example: I'd like to be able to annotate the put function as having type put<K,V>(dict<K,V>, K, V) -> None. UPDATE: The new PEP 484 (Sep 2014) defines a standard for static typing and type annotations in Python 3.5+.  There's a type-checking tool called mypy that is compatible with PEP 484.", "abstract": ""}, "answers": [{"id": 6025725, "score": 17, "vote": 0, "content": "Edit 2016-11-11: Just use mypy. Type hints can be added gradually. In Python 3 source code, it verifies standard PEP 484 type hints. Types can still be expressed in Python 2 using special comments. Guido likes it. This post was originally written a long time ago before mypy was a thing. I've preserved the post's original content below, even though it isn't quite accurate. Original post: You might want to check out some of the projects mentioned in this related StackOverflow post on static analysis for Python. In summary: Since Python uses duck typing extensively, things that might be called \"type errors\" in other languages might end up being \"object X doesn't support method Y\" in Python. Edit 2011-05-17: I agree with delnan that static typing is not possible for Python [apparently wrong].  But since our skepticism doesn't seem to deter you, I can only give you more information on the subject.  I present:", "abstract": ""}, {"id": 33404131, "score": 1, "vote": 0, "content": "I had a similar need some time ago.\nAll the existing solutions that I've found had some problem or does not have a feature that I'd like to have, so I've made my own. Here's how you use it: I hope this is useful for you. For more details look at: P.S.: (quoting myself from github repo) For most cases I'd recommend using tests instead of type checking since it's more natural to do that in Python. But, there are some cases where you want/need to specify a specific type to use and since python does not have type checks for parameters here's where this is useful.", "abstract": ""}, {"id": 25714986, "score": 11, "vote": 0, "content": "You may find mypy interesting. It has been proposed for inclusion in Python 3.5 by Guido.", "abstract": ""}, {"id": 25508204, "score": 2, "vote": 0, "content": "I like prospector, backend of landscape.io. It combines output of existing analyzers, such as pylint, pyflakes, pep8, frosted..., into one report. Neat.", "abstract": ""}, {"id": 19947840, "score": 2, "vote": 0, "content": "There is the 'gradual' package for Python 3; see PIP or the Bitbucket Repo Apparently this is an implementation by the group around Jeremy Siek who seems to be quite an authority in the field of gradual typing. Some annotations are apparently necessary, here is an example: As far as annotations go, this is not so bad. I have not used the package so I cannot speak to its quality, but the syntax (and the people behind it) certainly make it look promising.", "abstract": ""}, {"id": 17401346, "score": 6, "vote": 0, "content": "Check out this post: PySonar: a Static Analyzer for Python. PySonar is a tool that infers types  using abstract interpretation (partially executing) of code. It finds all possible execution paths of your program and finds all possible types of all variables. There are basically three versions of PySonar: None of them (except of closed source one) is fully implemented. But the basic idea is that you can use it as a basis for your work.", "abstract": ""}, {"id": 6362211, "score": 3, "vote": 0, "content": "I don't know if this helps but for what it's worth, Jeremy Siek at U of Colorado did some work on gradual typing, and I found this doing a quick search.\nhttp://www.wiki.jvmlangsummit.com/pdf/28_Siek_gradual.pdf My guess (I might be wrong) is there isn't any promising open source tools you can find at the moment since his research looks relatively new. Your best bet might be to contact the authors and ask if they can release their code to you.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/10279346/static-code-analysis-in-python", "keywords": [], "tags": ["python", "debugging", "refactoring", "static-code-analysis"], "question": {"id": 10279346, "title": "Static code analysis in Python?", "content": "Which helpful static code analysis can you recommend for Python. I believe they are useful for refactoring code.\nI know Are there static call analyzers? If I wanted to program a custom one, which would be the easiest way? What other type of static code checks can you think of? Or maybe even some Python magic like ABCs? EDIT: I've found that either using http://docs.python.org/3.3/library/ast.html or maybe even http://www.astroid.org/ can be used to program some custom parser. Then one can use graphviz to visualize or even PlantUML for UML graphs.", "abstract": ""}, "answers": [{"id": 27955410, "score": 2, "vote": 0, "content": "this is a very powerful python type inferencer\nhttps://github.com/yinwang0/pysonar2 it has strong bug check ability but it's not exposed through its interface, but I assume you could do many awesome checks based on it.", "abstract": ""}, {"id": 27978079, "score": 0, "vote": 0, "content": "Pysonar2 is a very nice implementation of abstract interpretation to type inference Python projects. My answer to another similar question is here. ", "abstract": ""}, {"id": 20085999, "score": 2, "vote": 0, "content": "check out pychecker and pyflakes. There was a famous question to discuss the pylint-pychecker-or-pyflakes", "abstract": ""}, {"id": 10300801, "score": 0, "vote": 0, "content": "Not exactly \"static code analyzer\" but even a bit more: http://code.google.com/p/shedskin/", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/27412550/is-there-a-tool-to-statically-analyse-python-code-to-determine-if-mutable-parame", "keywords": [], "tags": ["python", "functional-programming"], "question": {"id": 27412550, "title": "Is there a tool to statically analyse python code to determine if mutable parameters are changes (detect side effects)", "content": "Is there a Python static analysis tool which can detect when function parameters are mutated, therefore causing a side-effect? will change the calling scope x when x is a list.  Can this reliably be detected? I'm asking because such a tool would make it easier to comply with pure functional approaches.  I suppose a decorator could be used to warn about it (for development) but this wouldn't be as reliable as static analysis. ", "abstract": ""}, "answers": [{"id": 27412811, "score": 3, "vote": 0, "content": "Your foo function will mutate its argument if it's called with a list\u2014but if it's called with something different, it might raise an exception, or do something that doesn't mutate it. Similarly, you can write a type that mutates itself every time you call len on it, and then a function that just printing the length of its argument would be mutating its arguments. It's even worse if you use an operator like +=, which will call the (generally-mutating) __iadd__ method on types that have it, like list, but will call the (non-mutating) __add__ method on types that don't, like tuple. So, what are you going to do in those cases? For that matter, even a for loop over an argument is mutating if you pass in an iterator, but (usually) not if you pass in a sequence. If you just want to make a list of frequently-mutating method names and operators and search for those, that wouldn't be too hard to write as an AST visitor. But that's going to give you a lot of both false negatives and false positives. This is exactly the kind of problem that static typing was designed to solve. Python doesn't have static typing built it, but it's possible to build on top of Python. First, if you're using Python 3.x, you can use annotations to store the types of the parameters. For example: Now you know, from the fact that it takes a MutableSequence (or a list) rather than a Sequence, that it intends to mutate its parameter. And, even if it doesn't do so now, some future version might well do so, so you should trust its annotations anyway. And now you can solve your problem the same way you would in Haskell or ML: your pure functional code takes a Sequence and it calls functions with that Sequence, and you just need to ensure that none of those functions is defined to take a MutableSequence, right? That last part is the hard part. Python doesn't stop me from writing this: For that, you need a static type checker. Guido has been pushing to standardize annotations to allow the mypy static checker to become a semi-official part of Python. It's not completely finished yet, and it's not as powerful a type system as typical typed functional languages, but it will handle most Python code well enough for what you're looking for. But mypy isn't the only static type checker available; there are others if you search. Anyway, with a type checker, that foo function would fail with an error explaining that Sequence has no such method append. And if, on the other hand, foo were properly defined as taking a MutableSequence, your functional code that calls it with a Sequence would fail with an error explaining that Sequence is not a subtype of MutableSequence.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/19263704/is-there-a-tool-to-help-find-bugs-or-perform-static-analysis-in-python", "keywords": [], "tags": ["python", "debugging", "static-analysis"], "question": {"id": 19263704, "title": "Is there a tool to help find bugs or perform static analysis in Python?", "content": "Is there any tool to help to find bugs or perform static analysis in Python?   I search this question in Google i found answer - Pychecker \nBut i try to use pychecker its not work for import modules.\nIs it possible to debug the program along with checking the package is present or not.", "abstract": ""}, "answers": [{"id": 19270786, "score": 3, "vote": 0, "content": "Go with pylint. It will detect imported modules are present or not. Check out the more details on http://www.pylint.org Also check simple program where I have imported test module which is not present. when I run pylint on this I am able to detect following: Go with pylint, it will help you lot.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/956104/is-there-a-static-analysis-tool-for-python-ruby-sql-cobol-perl-and-pl-sql", "keywords": [], "tags": ["python", "ruby", "plsql", "static-analysis", "cobol"], "question": {"id": 956104, "title": "Is there a static analysis tool for Python, Ruby, Sql, Cobol, Perl, and PL/SQL?", "content": "I am looking for a static analysis tool for Python, Ruby, Sql, Cobol, Perl, PL/SQL, SQL similar to find bugs and check style. I am looking for calculating the line count, identify bugs during the development, and enforcing coding standard.", "abstract": ""}, "answers": [{"id": 956560, "score": 0, "vote": 0, "content": "I use Pylint for Python which was nicely integrated into Komodo by Brandon Corfman (if ActiveState's Komodo is your thing).", "abstract": ""}, {"id": 2399795, "score": 0, "vote": 0, "content": "See various static analysis tools from Semantic \nDesigns. These cover standard metrics for Java, C# and COBOL.   There are also tools to detect duplicate code (clones) for many languages, including Python, Java, PL/SQL (from your list). Finally, there is a style checker (coding standards checks) for COBOL (with optional Eclipse plugin) that offers refactoring support to fix some of the style errors.", "abstract": ""}, {"id": 957748, "score": 0, "vote": 0, "content": "Sonar has a PL/SQL plugin that is based on Toad CodeXpert code analyzer.", "abstract": ""}, {"id": 956666, "score": 2, "vote": 0, "content": "For Ruby, you're probably best served looking at this previous SO question: https://stackoverflow.com/questions/286564/can-anyone-recommend-a-ruby-source-code-analyzer-something-like-pylint which seems pretty thorough.", "abstract": ""}, {"id": 956182, "score": 10, "vote": 0, "content": "Perl has Perl::Critic (and perlcritic.com)", "abstract": ""}, {"id": 956145, "score": 4, "vote": 0, "content": "I use PyChecker and pylint as Python code checkers. However it seems that they get buggy when you use some modules (e.g., socket or pygame, IIRC).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/5463296/python-code-checker-for-comparing-a-function-as-an-attribute", "keywords": [], "tags": ["python", "static-analysis", "lint"], "question": {"id": 5463296, "title": "Python code checker for comparing a function as an attribute", "content": "I occasionally spend a considerable amount of time tracking down brainfarts in my code... while I normally run pylint against it, there are some things that slip past pylint.  The easiest problem for me to overlook is this... Neither pylint nor Python bark about this... is there a python code-checking tool that can flag this particular issue?", "abstract": ""}, "answers": [{"id": 6048912, "score": 0, "vote": 0, "content": "This is pylint ticket #65910", "abstract": ""}, {"id": 5980803, "score": 0, "vote": 0, "content": "@Mike Pennington I just want to first say that I also run into this a lot -.- @eyquem 'lower()' is a function. 'lower' is a function pointer (if I'm not mistaken). Python will let you attempt to run this code, but it will not invoke the function. I think the reason this is hard to catch is that you don't always know the type of the variable which you're calling methods on. For example, say I have 2 classes. If your code has a function in it that takes an argument 'baz' like so: Either one of these could be valid depending on baz's type.\nThere is literally no way of knowing if baz is of type 'Foo' or 'Bar', though. EDIT: I meant with static analysis...", "abstract": ""}, {"id": 5982920, "score": 0, "vote": 0, "content": "How do you propose a code-checker validate this?  It's perfectly legitimate syntax. Rather than checking for this kind of mistake, it would be better to get into the habit of using better patterns. Instead of: Do this: This way you're always explicitly calling .lower() on the value you're comparing against, instead of relying on an in-place method-call and comparison, which leads to the very pitfall you're experiencing.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1598887/is-there-a-program-that-uses-static-analysis-to-look-for-bugs-in-actionscript-co", "keywords": [], "tags": ["apache-flex", "actionscript-3", "actionscript", "flex3", "static-analysis"], "question": {"id": 1598887, "title": "Is there a program that uses static analysis to look for bugs in actionscript code?", "content": "Is thre any program which uses static analysis to look for bugs in actionscript code?", "abstract": ""}, "answers": [{"id": 1598912, "score": 1, "vote": 0, "content": "FlexPMD is probably the only thing resembling this. You can tune/train it to fit your needs.", "abstract": ""}]}]