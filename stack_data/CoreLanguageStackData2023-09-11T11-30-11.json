[{"link": "https://stackoverflow.com/questions/366422/how-can-i-avoid-issues-caused-by-pythons-early-bound-default-parameters-e-g-m", "keywords": [], "tags": ["python", "default-parameters"], "question": {"id": 366422, "title": "How can I avoid issues caused by Python&#39;s early-bound default parameters (e.g. mutable default arguments &quot;remembering&quot; old data)?", "content": "Sometimes it seems natural to have a default parameter which is an empty list. However, Python produces unexpected behavior in these situations. For example, consider this function: The first time it is called, the default will work, but calls after that will update the existing list (with one \"a\" each call) and print the updated version. How can I fix the function so that, if it is called repeatedly without an explicit argument, a new empty list is used each time?", "abstract": ""}, "answers": [{"id": 75853508, "score": 0, "vote": 0, "content": "Python evaluates default values for arguments/parameters ahead of time; they are \"early-bound\". This can cause problems in a few different ways. For example: The most common way the problem manifests, however, is when the argument to the function is mutable (for example, a list), and gets mutated within the function's code. When this happens, changes will be \"remembered\", and thus \"seen\" on subsequent calls: Because a_list was created ahead of time, every call to the function that uses the default value will use the same list object, which gets modified on each call, appending another 1 value. This is a conscious design decision that can be exploited in some circumstances - although there are often better ways to solve those other problems. (Consider using functools.cache or functools.lru_cache for memoization, and functools.partial to bind function arguments.) This also implies that methods of an instance cannot use an attribute of the instance as a default: at the time that the default value is determined, self is not in scope, and the instance does not exist anyway: (The class Example also doesn't exist yet, and the name Example is also not in scope; therefore, class attributes will also not work here, even if we don't care about the mutability issue.) The standard, generally-considered-idiomatic approach is to use None as the default value, and explicitly check for this value and replace it in the function's logic. Thus: This works because the code a_list = [] runs (if needed) when the function is called, not ahead of time - thus, it creates a new empty list every time. Therefore, this approach can also solve the datetime.now() issue. It does mean that the function can't use a None value for other purposes; however, this should not cause a problem in ordinary code. If it is not necessary to modify the argument in order to implement the function's logic, because of the principle of command-query separation, it would be better to just not do that. By this argument, append_one_and_return is poorly designed to begin with: since the purpose is to display some modified version of the input, it should not also actually modify the caller's variable, but instead just create a new object for display purposes. This allows for using an immutable object, such as a tuple, for the default value. Thus: This way will avoid modifying the input even when that input is explicitly provided: It works fine without an argument, even repeatedly: And it has gained some flexibility: There are plans to introduce new syntax in Python 3.12, documented in PEP 671, that would allow an explicit request for late binding of default values rather than early binding. The syntax would most likely look like: However, as of this writing, the proposal is not formally accepted and not on the list of incoming changes.", "abstract": ""}, {"id": 366430, "score": 256, "vote": 0, "content": "The docs say you should use None as the default and explicitly test for it in the body of the function.", "abstract": ""}, {"id": 44272023, "score": 62, "vote": 0, "content": "Other answers have already already provided the direct solutions as asked for, however, since this is a very common pitfall for new Python programmers, it's worth adding the explanation of why Python behaves this way, which is nicely summarized in The Hitchhikers Guide to Python under Mutable Default Arguments: Python's default arguments are evaluated once when the function is defined, not each time the function is called (like it is in say, Ruby). This means that if you use a mutable default argument and mutate it, you will and have mutated that object for all future calls to the function as well.", "abstract": ""}, {"id": 63969205, "score": 0, "vote": 0, "content": "Perhaps the simplest thing of all is to just create a copy of the list or tuple within the script.  This avoids the need for checking.  For example,", "abstract": ""}, {"id": 63923760, "score": 0, "vote": 0, "content": "Quote from https://docs.python.org/3/reference/compound_stmts.html#function-definitions Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use None as the default, and explicitly test for it in the body of the function, e.g.:", "abstract": ""}, {"id": 56823024, "score": -5, "vote": 0, "content": "I took the UCSC extension class Python for programmer Which is true of: def Fn(data = []): a) is a good idea so that your data lists start empty with every call. b) is a good idea so that all calls to the function that do not provide any arguments on the call will get the empty list as data. c) is a reasonable idea as long as your data is a list of strings. d) is a bad idea because the default [] will accumulate data and the default [] will change with subsequent calls. Answer: d) is a bad idea because the default [] will accumulate data and the default [] will change with subsequent calls.", "abstract": ""}, {"id": 2021717, "score": 14, "vote": 0, "content": "If the intent of the function is to modify the parameter passed as working_list, see HenryR's answer (=None, check for None inside). But if you didn't intend to mutate the argument, just use it as starting point for a list, you can simply copy it: (or in this simple case just print starting_list + [\"a\"] but I guess that was just a toy example) In general, mutating your arguments is bad style in Python.  The only functions that are fully expected to mutate an object are methods of the object.  It's even rarer to mutate an optional argument \u2014 is a side effect that happens only in some calls really the best interface? If you do it from the C habit of \"output arguments\", that's completely unnecessary - you can always return multiple values as a tuple. If you do this to efficiently build a long list of results without building intermediate lists, consider writing it as a generator and using result_list.extend(myFunc()) when you are calling it.  This way your calling conventions remains very clean. One pattern where mutating an optional arg is frequently done is a hidden \"memo\" arg in recursive functions:", "abstract": ""}, {"id": 45503780, "score": -1, "vote": 0, "content": "There have already been good and correct answers provided. I just wanted to give another syntax to write what you want to do which I find more beautiful when you for instance want to create a class with default empty lists: This snippet makes use of the if else operator syntax. I like it especially because it's a neat little one-liner without colons, etc. involved and it nearly reads like a normal English sentence. :) In your case you could write", "abstract": ""}, {"id": 367774, "score": 3, "vote": 0, "content": "I might be off-topic, but remember that if you just want to pass a variable number of arguments, the pythonic way is to pass a tuple *args or a dictionary **kargs. These are optional and are better than the syntax myFunc([1, 2, 3]). If you want to pass a tuple: If you want to pass a dictionary:", "abstract": ""}, {"id": 366446, "score": 18, "vote": 0, "content": "Not that it matters in this case, but you can use object identity to test for None: You could also take advantage of how the boolean operator or is defined in python: Though this will behave unexpectedly if the caller gives you an empty list (which counts as false) as working_list and expects your function to modify the list he gave it. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73598938/why-is-dataclass-field-shared-across-instances", "keywords": [], "tags": ["python", "python-dataclasses"], "question": {"id": 73598938, "title": "Why is dataclass field shared across instances", "content": "First time using dataclass, also not really good at Python. The following behaviour conflicts with my understanding so far: This prints Why does c1 behave like a class variable? What can I do to keep n2.c1 != n1.c1, do I need to write an init function? I can get sensible results with this addition to Y: prints:", "abstract": ""}, "answers": [{"id": 73599520, "score": 5, "vote": 0, "content": "Why does c1 behave like a class variable? Because you specified default value for them and they're now a class attribute. In the Mutable Default Values section, it's mentioned: Python stores default member variable values in class attributes. But look at this: c1 doesn't have default value so it's not in class's namespace. Indeed by doing so(defining default value), Python stores that c1 and c2 inside both instance's namespace (n1.__dict__) and class's namespace (Y.__dict__). Those are the same objects, only the reference is passed: So now, If you want them to be different you have several options: In the second option, because I didn't specify default parameter(you can't mix both), nothing is going to be stored in the class's namespace. field(default=SOMETHING) is another way of saying = SOMETHING.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6838255/python-class-function-default-variables-are-class-objects", "keywords": [], "tags": ["python"], "question": {"id": 6838255, "title": "Python class function default variables are class objects?", "content": "I was writing some code this afternoon, and stumbled across a bug in my code. I noticed that the default values for one of my newly created objects was carrying over from another object! For example: So I know it can be solved by doing this: What I would like to know is... Why? Why are Python classes structured so that the default values are saved across instances of the class?", "abstract": ""}, "answers": [{"id": 6838605, "score": 4, "vote": 0, "content": "Several others have pointed out that this is an instance of the \"mutable default argument\" issue in Python. The basic reason is that the default arguments have to exist \"outside\" the function in order to be passed into it. But the real root of this as a problem has nothing to do with default arguments. Any time it would be bad if a mutable default value was modified, you really need to ask yourself: would it be bad if an explicitly provided value was modified? Unless someone is extremely familiar with the guts of your class, the following behaviour would also be very surprising (and therefore lead to bugs): 9 times out of 10, if you discover yourself reaching for the \"pattern\" of using None as the default value and using if value is None: value = default, you shouldn't be. You should be just not modifying your arguments! Arguments should not be treated as owned by the called code unless it is explicitly documented as taking ownership of them. In this case (especially because you're initialising a class instance, so the mutable variable is going to live a long time and be used by other methods and potentially other code that retrieves it from the instance) I would do the following: Now you're initialising the data of your class from a list provided as input, rather than taking ownership of a pre-existing list. There's no danger that two separate instances end up sharing the same list, nor that the list is shared with a variable in the caller which the caller may want to continue using. It also has the nice effect that your callers can provide tuples, generators, strings, sets, dictionaries, home-brewed custom iterable classes, etc, and you know you can still count on self.my_list having an append method, because you made it yourself. There's still a potential problem here, if the elements contained in the list are themselves mutable then the caller and this instance can still accidentally interfere with each other. I find it not to very often be a problem in practice in my code (so I don't automatically take a deep copy of everything), but you have to be aware of it. Another issue is that if my_list can be very large, the copy can be expensive. There you have to make a trade-off. In that case, maybe it is better to just use the passed-in list after all, and use the if my_list is None: my_list = [] pattern to prevent all default instances sharing the one list. But if you do that you need to make it clear, either in documentation or the name of the class, that callers are relinquishing ownership of the lists they use to initialise the instance. Or, if you really want to be constructing a list solely for the purpose of wrapping up in an instance of One, maybe you should figure out how to encapsulate the creation of the list inside the initialisation of One, rather than constructing it first; after all, it's really part of the instance, not an initialising value. Sometimes this isn't flexible enough though. And sometimes you really honestly do want to have aliasing going on, and have code communicating by mutating values they both have access to. I think very hard before I commit to such a design, however. And it will surprise others (and you when you come back to the code in X months), so again documentation is your friend! In my opinion, educating new Python programmers about the \"mutable default argument\" gotcha is actually (slightly) harmful. We should be asking them \"Why are you modifying your arguments?\" (and then pointing out the way default arguments work in Python). The very fact of a function having a sensible default argument is often a good indicator that it isn't intended as something that receives ownership of a pre-existing value, so it probably shouldn't be modifying the argument whether or not it got the default value.", "abstract": ""}, {"id": 6840648, "score": 1, "vote": 0, "content": "Not an answer, but it's worth noting this is also true for class variables defined outside any class functions. Example: Note that not only does the value of myList persist, but every instance of myList points to the same list. I ran into this bug/feature myself, and spent something like 3 hours trying to figure out what was going on. It's rather challenging to debug when you are getting valid data, but it's not from the local computations, but previous ones. It's made worse since this is not just a default argument. You can't just put myList in the class definition, it has to be set equal to something, although whatever it is set equal to is only evaluated once. The solution, at least for me, was to simply create all the class variable inside __init__.", "abstract": ""}, {"id": 6838271, "score": 10, "vote": 0, "content": "This is a known behaviour of the way Python default values work, which is often surprising to the unwary. The empty array object [] is created at the time of definition of the function, rather than at the time it is called. To fix it, try:", "abstract": ""}, {"id": 6838280, "score": 3, "vote": 0, "content": "This is standard behavior of default arguments anywhere in Python, not just in classes.\nFor more explanation, see Mutable defaults for function/method arguments.", "abstract": ""}, {"id": 6838283, "score": 3, "vote": 0, "content": "Basically, python function objects store a tuple of default arguments, which is fine for immutable things like integers, but lists and other mutable objects are often modified in-place, resulting in the behavior you observed.", "abstract": ""}, {"id": 6838275, "score": 2, "vote": 0, "content": "Python functions are objects. Default arguments of a function are attributes of that function. So if the default value of an argument is mutable and it's modified inside your function, the changes are reflected in subsequent calls to that function.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/68362936/python-using-classes-as-default-values-of-another-class-attribute-nameerror", "keywords": [], "tags": ["python", "python-3.x", "class", "nameerror"], "question": {"id": 68362936, "title": "Python - Using classes as default values of another class&#39; attribute - NameError", "content": "I'm creating a structure of classes for a wrapper of an API I'm currently writing.\nI have multiple classes defined inside my models file. I want to assign the default value of some attributes of classes to other classes. When I do this, I get a NameError because sometimes I try to use classes that are defined below the current class, thus Python does not know these classes yet. I've tried multiple solutions but none of them seem to work. Does anybody know an alternative or has experience with this? my classes I've defined: As you can see above, I'm initialising the attribute 'provider' on the class RateResponse with the an empty object of the class Provider, which is defined below it. I'm getting a NameError on this line because it's defined below RateResponse. The simple solution to above would be to shift the places of the classes. However, this is only a snippet of my file that is currently 400 lines long, all with these types of classes and initializations. It would be impossible to order them all correctly. I've looked up some solutions where I thought I could return an empty object of a class by a string. I thought the function would only evaluate after all the classes were defined, but I was wrong. This is what I tried: But to no avail. Does anybody have experience with this? Is this even possible within Python? Is my structure just wrong? Any help is appreciated. Thanks.", "abstract": ""}, "answers": [{"id": 68363104, "score": 4, "vote": 0, "content": "This code might not mean what you want it to mean: This code is saying that when this class is declared you want to make an instance of Provider which will be the default value for the provider parameter. You may have meant that the default argument should be a new instance of Provider for each client that makes an instance of RateResponse. You can use the Mutable Default Argument pattern to get the latter: However, if you really do want a single instance when the client wants the default you could add a single instance below the Provider definition: Then the RateResponse class could still use the current pattern, but instead perform this assignment inside the if: At the time that the assignment is performed, the Singleton_Provider will have been created.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64458794/attr-library-classes-are-sharing-default-value", "keywords": [], "tags": ["python", "attr"], "question": {"id": 64458794, "title": "attr library classes are sharing default value?", "content": "Here is an example of strange attr behavior. Why is this happening, and how can I get the behavior that we obtain a new list each time?", "abstract": ""}, "answers": [{"id": 64458963, "score": 2, "vote": 0, "content": "The below code will create a 'private' list for each instance of List\nSee here for the docs.", "abstract": ""}, {"id": 64458906, "score": -1, "vote": 0, "content": "Though I don't know much about attr package. But I am pretty sure l is a static variable for the class List, which means it is not a member variable and it is shared across all the instances of List. You may want to make it become a member variable.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61424737/default-values-in-functions", "keywords": [], "tags": ["python"], "question": {"id": 61424737, "title": "Default Values in Functions", "content": "The following warning is in the Default Values in Function Arguments section in Python Docs. Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls: This will print [1] [1, 2] [1, 2, 3] If you don\u2019t want the default to be shared between subsequent calls, you can write the function like this instead: I didn't quite understand how the L=None part of code solves this problem. Can you help me understand. Thanks", "abstract": ""}, "answers": [{"id": 61424917, "score": 1, "vote": 0, "content": "Let's talk about the solution first than we will investigate the problem a little! When you call without passing L, a new list is being created everytime the function is called. passed value for a is appended to L and newly created L is returned. This is pretty straightforward. Let's look at what is happening when L has a default value of [] In Python default values for function parameters are evaluated at the time def is evaluated. You can see that using <function_name>.__defaults__ You can see that defaults in the beginning (before calling function is empty list)\nAfter few calls -  This ofcourse surprises every Python developer!", "abstract": ""}, {"id": 61424805, "score": 1, "vote": 0, "content": "Like the documentation mentions, when you put L=[] in an argument, the value for the argument is evaluated only one, so the list that L has is created only once and shared between invocations. So, if what you want is to create a new list every time the function is called, you have to create the list inside the function with a statement like L = []. But if the caller passes a list, you don't want to create a new empty one, you just want to use the one the caller gave you. That's where the None here comes in, it's just a signal that you want an empty list. That's why you do the if to check if the argument is None and create an empty list only when that's true. An since None is just a value that's immutable, it will not be shared between calls.", "abstract": ""}, {"id": 61424772, "score": 2, "vote": 0, "content": "None is immutable, meaning it cannot be changed. So if None is set to be the default value of the parameter, it is always the same on every function call, and a new empty list is set to L (because it is evaluated every time, not just the first time the function is called). Further reading: http://effbot.org/zone/default-values.htm", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/56878667/setting-default-values-in-a-class", "keywords": [], "tags": ["python", "class", "default"], "question": {"id": 56878667, "title": "Setting default values in a class", "content": "I am creating a class in Python, and I am unsure how to properly set default values. My goal is to set default values for all class instances, which can also be modified by a class method. However, I would like to have the initial default values restored after calling a method. I have been able to make it work with the code shown below. It isn't very \"pretty\", so I suspect that are better approaches to this problem. When I use this class, I would do something like my_instance = plots() and my_instance.method1(), my_instance.method1(b = 5), and my_instance.method1(). When calling method1 the third time, b would be 5 if I don't reset the default values at the end of the method definition, but I would like it to be 2 again.  Note: the code above is just an example. The real class has dozens of default values, and using all of them as input arguments would be considered an antipattern. Any suggestion on how to properly address this issue?", "abstract": ""}, "answers": [{"id": 56880524, "score": 0, "vote": 0, "content": "You can use a context manager or a decorator to apply and reset the values without having to type the same code on each method. Rather than having self.default_attr, I'd just return to the previous state. Using a decorator you could get: IMHO this is a bad idea, and would at least suggest not mutating plots. You can do this by making a new object and passing that to method1 as self.", "abstract": ""}, {"id": 56883874, "score": 3, "vote": 0, "content": "There is a whole bunch of ways to solve this problem, but if you have python 3.7 installed (or have 3.6 and install the backport), dataclasses might be a good fit for a nice solution. First of all, it lets you define the default values in a readable and compact manner, and also allows all the mutation operations you need: You also get the option to define default factories instead of default values for free with the dataclass field definition. It might not be a problem yet, but it avoids the mutable default value gotcha, which every python programmer runs into sooner or later. Last but not least, writing a reset function is quite easy given an existing dataclass, because it keeps track of all the default values already in its __dataclass_fields__ attribute: So now you can write some function do_stuff(...) that updates the fields in a Plot instance, and as long as you execute reset() the changes won't persist. ", "abstract": ""}, {"id": 56879961, "score": 2, "vote": 0, "content": "You can use class variables, and property to achieve your goal to set default values for all class instances. The instances values can be modified directly, and the initial default values restored after calling a method. In view of the context that \"the real class has dozens of default values\", another approach that you may consider, is to set up a configuration file containing the default values, and using this file to initialize, or reset the defaults. Here is a short example of the first approach using one class variable: output:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1680528/how-to-avoid-having-class-data-shared-among-instances", "keywords": [], "tags": ["python", "class"], "question": {"id": 1680528, "title": "How to avoid having class data shared among instances?", "content": "What I want is this behavior: Of course, what really happens when I print is: Clearly they are sharing the data in class a. How do I get separate instances to achieve the behavior I desire?", "abstract": ""}, "answers": [{"id": 41683345, "score": 20, "vote": 0, "content": "Although the accepted anwer is spot on, I would like to add a bit description. Let's do a small exercise  first of all define a class as follows: So what do we have here? Pretty straight forward so far yeah? Now let's start playing around with this class. Let's initialize  this class first: Now do the following: Well, a.temp worked as expected but how the hell did A.temp work? Well it worked because temp is a class attribute. Everything in python is an object. Here A is also an object of class type. Thus the attribute temp is an attribute held by the A class and if you change the value of temp through A (and not through an instance of a), the changed value is going to be reflected in all the instance of A class.\nLet's go ahead and do that: Interesting isn't it? And note that id(a.temp) and id(A.temp) are still the same. Any Python object is automatically given a __dict__ attribute, which contains its list of attributes. Let's investigate what this dictionary contains for our example objects: Note that temp attribute is listed among A class's attributes while x is listed for the instance. So how come that we get a defined value of a.temp if it is not even listed for the instance a. Well that's the magic of __getattribute__() method. In Python the dotted syntax automatically invokes this method so when we write a.temp, Python executes a.__getattribute__('temp'). That method performs the attribute lookup action, i.e. finds the value of the attribute by looking in different places. The standard implementation of __getattribute__() searches first the internal dictionary (dict) of an object, then the type of the object itself. In this case a.__getattribute__('temp') executes first a.__dict__['temp'] and then a.__class__.__dict__['temp'] Okay now let's use our change method: Well now that we have used self, print(a.temp) gives us a different value from print(A.temp).  Now if we compare id(a.temp) and id(A.temp), they will be different.", "abstract": ""}, {"id": 51728891, "score": 0, "vote": 0, "content": "To protect your variable shared by other instance you need to create new instance variable each time you create an instance. When you are declaring a variable inside a class it's class variable and shared by all instance. If you want to make it for instance wise need to use the init method to reinitialize the variable as  refer to the instance   From Python Objects and Class by Programiz.com: __init__() function. This special function gets called whenever a new object of that class is instantiated. This type of function is also called constructors in Object Oriented\n  Programming (OOP). We normally use it to initialize all the variables. For example:", "abstract": ""}, {"id": 21492237, "score": 5, "vote": 0, "content": "So nearly every response here seems to miss a particular point.  Class variables never become instance variables as demonstrated by the code below.  By utilizing a metaclass to intercept variable assignment at the class level, we can see that when a.myattr is reassigned, the field assignment magic method on the class is not called.  This is because the assignment creates a new instance variable.  This behavior has absolutely nothing to do with the class variable as demonstrated by the second class which has no class variables and yet still allows field assignment. IN SHORT Class variables have NOTHING to do with instance variables. More clearly They just happen to be in the scope for lookups on instances. Class variables are in fact instance variables on the class object itself.  You can also have metaclass variables if you want as well because metaclasses themselves are objects too.  Everything is an object whether it is used to create other objects or not, so do not get bound up in the semantics of other languages usage of the word class.  In python, a class is really just an object that is used to determine how to create other objects and what their behaviors will be.  Metaclasses are classes that create classes, just to further illustrate this point. ", "abstract": ""}, {"id": 15590354, "score": 28, "vote": 0, "content": "The accepted answer works but a little more explanation does not hurt.  Class attributes do not become instance attributes when an instance is created. They become instance attributes when a value is assigned to them. In the original code no value is assigned to list attribute after instantiation; so it remains a class attribute. Defining list inside __init__ works because __init__ is called after instantiation. Alternatively, this code would also produce the desired output: However, the confusing scenario in the question will never happen to immutable objects such as numbers and strings, because their value cannot be changed without assignment. For example a code similar to the original with string attribute type works without any problem: So to summarize: class attributes become instance attributes if and only if a value is assigned to them after instantiation, being in the __init__ method or not. This is a good thing because this way you can have static attributes if you never assign a value to an attribute after instantiation.", "abstract": ""}, {"id": 1680555, "score": 182, "vote": 0, "content": "You want this: Declaring the variables inside the class declaration makes them \"class\" members and not instance members. Declaring them inside the __init__ method makes sure that a new instance of the members is created alongside every new instance of the object, which is the behavior you're looking for.", "abstract": ""}, {"id": 1680545, "score": 13, "vote": 0, "content": "You declared \"list\" as a \"class level property\" and not \"instance level property\".  In order to have properties scoped at the instance level, you need to initialize them through referencing with the \"self\" parameter in the __init__ method (or elsewhere depending on the situation). You don't strictly have to initialize the instance properties in the __init__ method but it makes for easier understanding.", "abstract": ""}, {"id": 1680581, "score": 4, "vote": 0, "content": "Yes you must declare in the \"constructor\" if you want that the list becomes an object property and not a class property.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/2313075/default-value-in-a-function-in-python", "keywords": [], "tags": ["python", "default-value"], "question": {"id": 2313075, "title": "Default value in a function in Python", "content": "I am noticing the following: Is this the correct behavior?", "abstract": ""}, "answers": [{"id": 2313105, "score": 13, "vote": 0, "content": "Yes, it's correct behavior. However, from your question, it appears that it's not what you expected. If you want it to match your expectations, be aware of the following: Rule 1.  Do not use mutable objects as default values. Will not create a fresh list object.  The default list object for arg will be shared all over the place.   Similarly will not create a fresh dict object.  This default dict will be shared. That's a common way to provide a default argument value that is a fresh, empty list object.", "abstract": ""}, {"id": 2313178, "score": 1, "vote": 0, "content": "Always make functions like this then: Alternatively you could also use data = data or [], but that prevents the user from passing empty parameters ('', 0, False etc.).", "abstract": ""}, {"id": 2313113, "score": 4, "vote": 0, "content": "This is a classic pitfall. See http://zephyrfalcon.org/labs/python_pitfalls.html, section 5: \"Mutable default arguments\"", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/13389325/why-do-two-class-instances-appear-to-be-sharing-the-same-data", "keywords": [], "tags": ["python", "class"], "question": {"id": 13389325, "title": "Why do two class instances appear to be sharing the same data?", "content": "I was doing some work in Python when I ran into an unexpected problem.  I have a class, and two variables x and y.  x and y are meant to be separate copies of the class each with their own data.  So I set x equal to the class and give it some values, then do the same with y.  Once I try to use that data though, I realize that I overwrote my values for x.  It seems that I have not created two separate copies of the class to work with but instead two references to the same class.  So here is the general example in code: The end result is that 3 is printed instead of 2.  I want to create a separate \"version\" of the class to hold different data for each variable.  Not sure as to how though.  Using Python 3.3.  Here is the code for the class:", "abstract": ""}, "answers": [{"id": 13389510, "score": 7, "vote": 0, "content": "You fell into a common newbie trap for Python.  Using a list as a default variable as you did with def __init__(self, list = [0,0,0,0,0,0,0,0,0,0]) means that all instances of that class share the same list instance as the value for that argument.  See also \"Least Astonishment\" and the Mutable Default Argument By the way, a common idiom if you want to use a container object such as a list as a default argument, is to instead use None and check for that.  For example: Or whatever.  Not quite as clearly self-documenting as default arguments but it works. As a side note, don't use list as a variable name, as it shadows the (somewhat commonly used) list builtin.", "abstract": ""}]}]