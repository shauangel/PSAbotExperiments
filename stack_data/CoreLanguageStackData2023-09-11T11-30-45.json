[{"link": "https://stackoverflow.com/questions/34439/finding-what-methods-a-python-object-has", "keywords": [], "tags": ["python", "introspection"], "question": {"id": 34439, "title": "Finding what methods a Python object has", "content": "Given a Python object of any kind, is there an easy way to get the list of all methods that this object has? Or if this is not possible, is there at least an easy way to check if it has a particular method, other than checking if an error occurs when the method is called?", "abstract": ""}, "answers": [{"id": 34467, "score": 362, "vote": 0, "content": "You can use the built in dir() function to get a list of all the attributes a module has.  Try this at the command line to see how it works. Also, you can use the hasattr(module_name, \"attr_name\") function to find out if a module has a specific attribute. See the Python introspection for more information.", "abstract": ""}, {"id": 34452, "score": 745, "vote": 0, "content": "For many objects, you can use this code, replacing 'object' with the object you're interested in: I discovered it at diveintopython.net (now archived), that should provide some further details! If you get an AttributeError, you can use this instead: getattr() is intolerant of pandas style Python 3.6 abstract virtual sub-classes.  This code does the same as above and ignores exceptions.", "abstract": ""}, {"id": 20100900, "score": 153, "vote": 0, "content": "The simplest method is to use dir(objectname). It will display all the methods available for that object.", "abstract": ""}, {"id": 65186594, "score": 24, "vote": 0, "content": "Suppose we have a Python obj. Then to see all the methods it has, including those surrounded by __ (magic methods): To exclude magic builtins one would do:", "abstract": ""}, {"id": 50050651, "score": 28, "vote": 0, "content": "The simplest way to get a list of methods of any object is to use the help() command. It will list out all the available/important methods associated with that object. For example:", "abstract": ""}, {"id": 68474764, "score": 0, "vote": 0, "content": "Most of the time, I want to see the user-defined methods and I don't want to see the built-in attributes that start with '__', if you want that you can use the following code: For example, for this class: Above code will print: ['print_name']", "abstract": ""}, {"id": 67662964, "score": -1, "vote": 0, "content": "Here's a nice one liner (but will get attributes as well):", "abstract": ""}, {"id": 63620684, "score": 3, "vote": 0, "content": "I have done the following function (get_object_functions), which receives an object (object_) as its argument, and returns a list (functions) containing all of the methods (including static and class methods) defined in the object's class: Well, it just checks if the string representation of the type of a class' attribute equals \"<class 'function'>\" or \"<class 'method'>\" and then includes that attribute in the functions list if that's True. For a cleaner version of the code: https://github.com/revliscano/utilities/blob/master/get_object_functions/object_functions_getter.py", "abstract": ""}, {"id": 63481052, "score": -1, "vote": 0, "content": "You can make use of dir() which is pre-defined in Python. You can also pass an object to dir() as If the object is an object of a pre-defined class such as int, str, etc. it displays the methods in it (you may know those methods as built in functions). If that object is created for a user-defined class, it displays all the methods given in that class.", "abstract": ""}, {"id": 47317075, "score": 16, "vote": 0, "content": "Open a Bash shell (Ctrl + Alt + T on Ubuntu). Start a Python\u00a03 shell in it. Create an object to observe the methods of. Just add a dot after it and press Tab twice and you'll see something like this:", "abstract": ""}, {"id": 37464502, "score": 41, "vote": 0, "content": "I believe that you want something like this: a list of attributes from an object The built-in function dir() can do this job. Taken from help(dir) output on your Python shell: dir(...) If called without an argument, return the names in the current scope. Else, return an alphabetized list of names comprising (some of) the attributes of the given object, and of attributes reachable from it. If the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns: For example:", "abstract": ""}, {"id": 27380776, "score": 11, "vote": 0, "content": "The problem with all methods indicated here is that you can't be sure that a method doesn't exist. In Python you can intercept the dot calling through __getattr__ and __getattribute__, making it possible to create method \"at runtime\" Example: If you execute it, you can call non-existing methods in the object dictionary... And it's why you use the Easier to ask for forgiveness than permission paradigms in Python.", "abstract": ""}, {"id": 15640132, "score": 2, "vote": 0, "content": "...is there at least an easy way to check if it has a particular method other than simply checking if an error occurs when the method is called While \"Easier to ask for forgiveness than permission\" is certainly the Pythonic way, you may be looking for:", "abstract": ""}, {"id": 34481, "score": 28, "vote": 0, "content": "On top of the more direct answers, I'd be remiss if I didn't mention IPython. Hit Tab to see the available methods, with autocompletion. And once you've found a method, try: to see the pydocs, method signature, etc. Ahh... REPL.", "abstract": ""}, {"id": 58987382, "score": 4, "vote": 0, "content": "This should work :)", "abstract": ""}, {"id": 61189861, "score": 0, "vote": 0, "content": "If you are, for instance, using shell plus you can use this instead: that way, with the '??' just after your object, it'll show you all the attributes/methods the class has.", "abstract": ""}, {"id": 49194581, "score": 0, "vote": 0, "content": "In order to search for a specific method in a whole module", "abstract": ""}, {"id": 48284803, "score": 2, "vote": 0, "content": "Take a list as an object list(filter(lambda x:callable(getattr(obj,x)),obj.__dir__())) You get:", "abstract": ""}, {"id": 28220562, "score": 21, "vote": 0, "content": "If you specifically want methods, you should use inspect.ismethod. For method names: For the methods themselves: Sometimes inspect.isroutine can be useful too (for built-ins, C extensions, Cython without the \"binding\" compiler directive).", "abstract": ""}, {"id": 32608298, "score": 5, "vote": 0, "content": "There is no reliable way to list all object's methods. dir(object) is usually useful, but in some cases it may not list all methods. According to dir() documentation: \"With an argument, attempt to return a list of valid attributes for that object.\" Checking that method exists can be done by callable(getattr(object, method)) as already mentioned there.", "abstract": ""}, {"id": 29851741, "score": 2, "vote": 0, "content": "One can create a getAttrs function that will return an object's callable property names That'd return", "abstract": ""}, {"id": 34472, "score": 35, "vote": 0, "content": "To check if it has a particular method:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46312470/difference-between-methods-and-attributes-in-python", "keywords": [], "tags": ["python", "class", "oop", "methods", "attributes"], "question": {"id": 46312470, "title": "Difference between methods and attributes in python", "content": "I am learning python and doing an exercise about classes. It tells me to add an attribute to my class and a method to my class. I always thought these were the same thing until I read the exercise. What is the difference between the two?", "abstract": ""}, "answers": [{"id": 75163847, "score": -1, "vote": 0, "content": "#Below u can see that I made a class called \"example\" with two class attributes:\nvariable1 and variable2. class example():\ndef init(self, variable1, variable2):\nself.variable1 = variable1\nself.variable2 = variable1 #below i created an object \"object1\" with the example class. I created the example class with two arguments \"variable1\" and \"variable2\". \"self\" does not count), so i have to pass two arguments when calling the example class. I gave two variables \"10\" and \"20\". object1 = example(10,20) with the code below i just get the value of the first argument, which is 10. print(object1.variable1)", "abstract": ""}, {"id": 46312533, "score": 51, "vote": 0, "content": "Mental model: According to Python's glossary: attribute: A value associated with an object which is referenced by\nname using dotted expressions. For example, if an object o has an\nattribute a it would be referenced as o.a method: A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which is usually called self). See function and nested scope. Terminology applied to actual code:", "abstract": ""}, {"id": 63671283, "score": 15, "vote": 0, "content": "A quick,simplified explanation. Attribute == characteristics.\nMethod == operations/ actions. For example, Let's describe a cat (meow!). What are the attributes(characteristics) of a cat?\nIt has different breed, name, color, whether they have spots...etc. What are methods (actions) of a cat?\nIt can meow, climb, scratch you, destroy your laptop, etc. Notice the difference, attributes define characteristics of the cat. Methods, on the other hand, defines action/operation (verb). Now, putting the above definition in mind, let's create an object of class 'cat'...meowww To create attributes, use def init(self, arg1, arg2) - (as shown below). The 'self' keyword is a reference to a particular instance of a class. Notice (above) 'mybreed' is an input argument that the user need to specify, whereas self.breed is an attribute of the instance assigned to 'mybreed' argument. Usually, they're the same (e.g. breed for both, self.breed = breed). Here, it's coded differently to avoid confusion. And attributes are usually written as 'self.attribute_name' (as shown above). Now, methods are more like actions, or operations, where you define a function inside the body of a class to perform some operation, for example, killing a mouse. A method could also utilize the attributes that you defined within the object itself. Another key difference between a method and attribute is how you call it. For example, let's say we create an instance using the above class we defined. To call an attribute, you use or For methods, you call it to execute some action. In Python, you call method with an open and close parenthesis, as shown below:", "abstract": ""}, {"id": 62319919, "score": 0, "vote": 0, "content": "output:\nmethod associated with obj1: first name: reyan & Last name: ishtiaq................\nmethod associated with obj2: first name: ishtiaq & Last name: reyan................\n20\n30", "abstract": ""}, {"id": 46312508, "score": 17, "vote": 0, "content": "A method is an attribute, but not all attributes are methods. For example, if we have the class This class has two attributes, class_name and my_method. But only my_method is a method. Methods are functions that belong to your object. There are additional hidden attributes present on all classes, but this is what your exercise is likely talking about.", "abstract": ""}, {"id": 46312502, "score": 1, "vote": 0, "content": "A method is a function defined in the class. An attribute is an instance variable defined in the class.  Example: Here hello is a method, and name is an attribute. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/2675028/list-attributes-of-an-object", "keywords": [], "tags": ["python", "class", "python-3.x"], "question": {"id": 2675028, "title": "List attributes of an object", "content": "Is there a way to grab a list of attributes that exist on instances of a class? The desired result is that \"multi, str\" will be output.  I want this to see the current attributes from various parts of a script.", "abstract": ""}, "answers": [{"id": 41737776, "score": 43, "vote": 0, "content": "Inspect module: The inspect module provides several useful functions to help get\ninformation about live objects such as modules, classes, methods,\nfunctions, tracebacks, frame objects, and code objects. Using getmembers() you can see all attributes of your class, along with their value. To exclude private or protected attributes use .startswith('_'). To exclude methods or functions use inspect.ismethod() or inspect.isfunction(). Note that ismethod() is used on the second element of i since the first is simply a string (its name). Offtopic: Use CamelCase for class names.", "abstract": ""}, {"id": 49330731, "score": -4, "vote": 0, "content": "__attrs__ gives the list of attributes of an instance.", "abstract": ""}, {"id": 52563286, "score": 179, "vote": 0, "content": "All previous answers are correct, you have three options for what you are asking  dir() vars() __dict__", "abstract": ""}, {"id": 60299405, "score": 1, "vote": 0, "content": "This is the best I have:", "abstract": ""}, {"id": 57856158, "score": 6, "vote": 0, "content": "In addition to these answers, I'll include a function (python 3) for spewing out virtually the entire structure of any value. It uses dir to establish the full list of property names, then uses getattr with each name. It displays the type of every member of the value, and when possible also displays the entire member: Now any of the following should give insight: ", "abstract": ""}, {"id": 56552463, "score": 2, "vote": 0, "content": "", "abstract": ""}, {"id": 53820273, "score": 18, "vote": 0, "content": "You can use dir(your_object) to get the attributes and getattr(your_object, your_object_attr) to get the values usage : This is particularly useful if your object have no __dict__. If that is not the case you can try var(your_object) also", "abstract": ""}, {"id": 2675542, "score": 235, "vote": 0, "content": "Then you can test what type is with type() or if is a method with callable().", "abstract": ""}, {"id": 43118136, "score": 8, "vote": 0, "content": "Please see the python shell script which has been executed in sequence, here you will get the attributes of a class in string format separated by comma. I am using python 3.4", "abstract": ""}, {"id": 37778894, "score": 10, "vote": 0, "content": "There is more than one way to do it: When run, this code produces:", "abstract": ""}, {"id": 41735640, "score": 1, "vote": 0, "content": "As written before using obj.__dict__ can handle common cases but some classes do not have the __dict__ attribute and use __slots__ (mostly for memory efficiency). example for a more resilient way of doing this: this code's output: Note1:\nPython is a dynamic language and it is always better knowing the classes you trying to get the attributes from as even this code can miss some cases. Note2:\nthis code outputs only instance variables meaning class variables are not provided. for example: code outputs: This code does not print the url class attribute and might omit wanted class attributes.\nSometimes we might think an attribute is an instance member but it is not and won't be shown using this example.", "abstract": ""}, {"id": 41734655, "score": 0, "vote": 0, "content": "Please see the following Python shell scripting execution in sequence, it will give the solution from creation of class to extracting the field names of instances.", "abstract": ""}, {"id": 39945328, "score": 11, "vote": 0, "content": "It's often mentioned that to list a complete list of attributes you should use dir(). Note however that contrary to popular belief dir() does not bring out all attributes. For example you might notice that __name__ might be missing from a class's dir() listing even though you can access it from the class itself. From the doc on dir() (Python 2, Python 3): Because dir() is supplied primarily as a convenience for use at an\n  interactive prompt, it tries to supply an interesting set of names\n  more than it tries to supply a rigorously or consistently defined set\n  of names, and its detailed behavior may change across releases. For\n  example, metaclass attributes are not in the result list when the\n  argument is a class. A function like the following tends to be more complete, although there's no guarantee of completeness since the list returned by dir() can be affected by many factors including implementing the __dir__() method, or customizing __getattr__() or __getattribute__() on the class or one of its parents. See provided links for more details.", "abstract": ""}, {"id": 39387607, "score": -1, "vote": 0, "content": "", "abstract": ""}, {"id": 31967014, "score": 95, "vote": 0, "content": "vars(obj) returns the attributes of an object.", "abstract": ""}, {"id": 2675528, "score": 8, "vote": 0, "content": "What do you want this for? It may be hard to get you the best answer without knowing your exact intent. It is almost always better to do this manually if you want to display an instance of your class in a specific way. This will include exactly what you want and not include what you don't want, and the order will be predictable.  If you are looking for a way to display the content of a class, manually format the attributes you care about and provide this as the __str__ or __repr__ method for your class. If you want to learn about what methods and such exist for an object to understand how it works, use help. help(a) will show you a formatted output about the object's class based on its docstrings. dir exists for programatically getting all the attributes of an object. (Accessing __dict__ does something I would group as the same but that I wouldn't use myself.) However, this may not include things you want and it may include things you do not want. It is unreliable and people think they want it a lot more often than they do. On a somewhat orthogonal note, there is very little support for Python 3 at the current time. If you are interested in writing real software you are going to want third-party stuff like numpy, lxml, Twisted, PIL, or any number of web frameworks that do not yet support Python 3 and do not have plans to any time too soon. The differences between 2.6 and the 3.x branch are small, but the difference in library support is huge.", "abstract": ""}, {"id": 2675148, "score": 455, "vote": 0, "content": "You may also find pprint helpful.", "abstract": ""}, {"id": 2675059, "score": 38, "vote": 0, "content": "This of course will print any methods or attributes in the class definition. You can exclude \"private\" methods by changing i.startwith('__') to i.startwith('_')", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6886493/get-all-object-attributes-in-python", "keywords": [], "tags": ["python", "introspection", "python-2.6"], "question": {"id": 6886493, "title": "Get all object attributes in Python?", "content": "Is there a way to get all attributes/methods/fields/etc. of an object in Python? vars() is close to what I want, but it doesn't work unless an object has a __dict__, which isn't always true (e.g. it's not true for a list, a dict, etc.).", "abstract": ""}, "answers": [{"id": 39392891, "score": 175, "vote": 0, "content": "I use __dict__ and dir(<instance>) Example:", "abstract": ""}, {"id": 53820171, "score": 91, "vote": 0, "content": "You can use dir(your_object) to get the attributes and getattr(your_object, your_object_attr) to get the values usage :", "abstract": ""}, {"id": 6886536, "score": 121, "vote": 0, "content": "What you probably want is dir(). The catch is that classes are able to override the special __dir__ method, which causes dir() to return whatever the class wants (though they are encouraged to return an accurate list, this is not enforced). Furthermore, some objects may implement dynamic attributes by overriding __getattr__, may be RPC proxy objects, or may be instances of C-extension classes. If your object is one these examples, they may not have a __dict__ or be able to provide a comprehensive list of attributes via __dir__: many of these objects may have so many dynamic attrs it doesn't won't actually know what it has until you try to access it.  In the short run, if dir() isn't sufficient, you could write a function which traverses __dict__ for an object, then __dict__ for all the classes in obj.__class__.__mro__; though this will only work for normal python objects. In the long run, you may have to use duck typing + assumptions - if it looks like a duck, cross your fingers, and hope it has .feathers.", "abstract": ""}, {"id": 6886507, "score": 785, "vote": 0, "content": "Use the built-in function dir().", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/63115155/how-to-know-attributes-vs-methods-in-python-object", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 63115155, "title": "How to know attributes vs methods in Python object?", "content": "How do you know attributes vs methods in Python object?  When using the dir method it only list everything for example dir('string').", "abstract": ""}, "answers": [{"id": 63115368, "score": 5, "vote": 0, "content": "You can test the attributes's type: prints Note that this won't print True for builtin methods that are not explicitly defined in the class definition (or attached later, see __str__ and another_method above). Note, also, that unlike testing for callable, this actually catches the distinction between methods and callable attributes.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/191010/how-to-get-a-complete-list-of-objects-methods-and-attributes", "keywords": [], "tags": ["python"], "question": {"id": 191010, "title": "How to get a complete list of object&#39;s methods and attributes?", "content": "does not return pattern as one of the lists's elements. Namely it returns: According to the manual, it is supposed to contain  the object's attributes' names, the\n  names of its class's attributes, and\n  recursively of the attributes of its\n  class's base classes. It says also that The list is not necessarily complete. Is there a way to get the complete list? I always assumed that dir returns a complete list but apparently it does not... Also: is there a way to list only attributes? Or only methods? Edit: this is actually a bug in python -> supposedly it is fixed in the 3.0 branch (and perhaps also in 2.6)", "abstract": ""}, "answers": [{"id": 10313703, "score": 22, "vote": 0, "content": "Here is a practical addition to the answers of PierreBdR and Moe:   For old-style classes, we can at least do what a standard module does to support tab completion: in addition to dir(), look for __class__, and then to go for its __bases__: (Test code and output are deleted for brevity, but basically for new-style objects we seem to have the same results for get_object_attrs() as for dir(), and for old-style classes the main addition to the dir() output seem to be the __class__ attribute.)", "abstract": ""}, {"id": 52846957, "score": 11, "vote": 0, "content": "Only to supplement: Solutions other than dir() merely provide their way of dealing the output of dir(). Listing 2nd level attributes or not, it is important to do the sifting by yourself, because sometimes you may want to sift out internal vars with leading underscores __, but sometimes you may well need the __doc__ doc-string. IMPORTANT: __dir__() can be sometimes overwritten with a function, value or type, by the author for whatever purpose. Here is an example: TypeError: descriptor __dir__ of 'object' object needs an argument The author of PyTorch modified the __dir__() method to something that requires an argument. This modification makes dir() fail. If you want a reliable scheme to traverse all attributes of an object, do remember that every pythonic standard can be overridden and may not hold, and every convention may be unreliable.", "abstract": ""}, {"id": 39286285, "score": 6, "vote": 0, "content": "This is how I do it, useful for simple custom objects to which you keep adding attributes: Given an object created with obj = type(\"Obj\",(object,),{}), or by simply:  Add some attributes: then, to obtain a dictionary with only the custom attributes:", "abstract": ""}, {"id": 191029, "score": 147, "vote": 0, "content": "For the complete list of attributes, the short answer is: no. The problem is that the attributes are actually defined as the arguments accepted by the getattr built-in function. As the user can reimplement __getattr__, suddenly allowing any kind of attribute, there is no possible generic way to generate that list. The dir function returns the keys in the __dict__ attribute, i.e. all the attributes accessible if the __getattr__ method is not reimplemented. For the second question, it does not really make sense. Actually, methods are callable attributes, nothing more. You could though filter callable attributes, and, using the inspect module determine the class methods, methods or functions.", "abstract": ""}, {"id": 191679, "score": 61, "vote": 0, "content": "That is why the new __dir__() method has been added in python 2.6 see:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55114133/what-are-an-objects-attributes-in-python-and-in-general", "keywords": [], "tags": ["python", "attributes", "directory"], "question": {"id": 55114133, "title": "What are an &#39;object&#39;s attributes&#39; in python and in general?", "content": "I'm learning python and one of the built-in functions being taught is dir() -- the course describes it as 'returning the directory of valid attributes for an object,' but what are an object's attributes?  I think I see some member functions in the returned list of attributes, __len__ I assume refers to len(), but what are all these other things listed?  Also, what does it mean, it can be incomplete? This is my first question and I wouldn't ask it if I didn't already spend 45 minutes trying to figure this out. ", "abstract": ""}, "answers": [{"id": 55114442, "score": 0, "vote": 0, "content": "Let's say you have a class Person The output of the above program looks like this: What you can see from the above output is that it returns a sorted list of valid attributes for that object. If you look at the class Person: name, age, country \nare attributes and method1 is the method of that class. Hence when you use dir(Person), it will display all the attributes of that class. The default dir() mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete, information: For example,  This will print: Here, you can see few other attributes names insert, pop, remove etc. If you check with previous list, they were not present. It's because different types of objects have different attributes and with these attributes you can use these objects in different forms.\nYou can use a.pop(2) to remove an element etc. len I assume refers to len() Generally, len() is the public interface you use to get the length of an object. The __len__ method is the implementation that an object that supports the concept of length is expected to implement. len() calls __len__() I think I see some member functions in the returned list of attributes, len I assume refers to len(), but what are all these other things listed? Visit the following link, https://docs.python.org/3.6/reference/datamodel.html#object.dir. Majority of them are listed here. There usages are also described.", "abstract": ""}, {"id": 55114458, "score": 0, "vote": 0, "content": "Those are the methods that the object superclass has. And any object that inherits from this attains these properties. Now I think you are confusing yourself with __len__() and len(something).  len() is a function that is brought into scope by default. What it simply does is it calls the __len__() function that resides in that object. Say you called len([1,2,3,4]) this will call the __len__() method that is present inside the class List i.e the class which this list object was created from. Various functions use these dunder methods for their own purposes.  here's an example 'I have been called' Same way many of these functions also work.", "abstract": ""}, {"id": 55114287, "score": 0, "vote": 0, "content": "Depends on what type of object you are talking about. Say the object in question is a class, then all the attributes that come under class's namespace are listed by dir. And that includes any methods, class level variables that are specifically declared by the user + anything that is inherited. Remember classes inherit from 'object' which provides a bunch of special methods See if below code makes sense: If you do dir on class A, you will see all attributes under namespace of A + the ones inherited from object as below. Also try dir(object) to see what are the specific 'object' attributes Note that self.a isn't listed as self.a belongs to instance and not the class itself To add, your object numbers is of type list and hence all attributes of list are listed (see dir(list))", "abstract": ""}, {"id": 55114294, "score": 1, "vote": 0, "content": "You're confusing a few things and are possibly confused about a few confusing things. __len__ is not referring to len(), rather len(something) will call the __len__ method of something. Any object that has a __len__ method can be asked for its length by calling len(something). Note how this is different from something.len() and how it is more legible than something.__len__(). An object's attributes in Python include what you would normally consider its attributes, as well as all of its property and method names. So for this example: Any instance of T would include in its attributes x, afunc and y. An object's attributes also include all the attributes of its base classes (so what classes it inherits from), ultimately always including the attributes of object. The remark about it being incomplete is in in reference to objects that don't have a __dir__ attribute to be called by the dir() function. In those cases, the dir() function will look at its __dict__ attribute (if available) and as a result it may not offer a complete list of attributes - note that this isn't the case for most objects.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52001152/how-python-display-list-of-all-attribute-and-method-using-dirobject", "keywords": [], "tags": ["python"], "question": {"id": 52001152, "title": "how python display list of all attribute and method using dir(object)?", "content": "I was reading python dunder method and came across that the we can have our own definition for built-in method like len(object)\nSo I created a class otherclass which has definition And it does print len of the object and further inspecting I also found len dunder method is available in otherclass object using dir     I am wondering how python display the value for dir(object) as there is no dir dunder method in the result of dir(otherclass)", "abstract": ""}, "answers": [{"id": 52001363, "score": 0, "vote": 0, "content": "dir is a built-in function. When it is passed an object it uses the object's __dict__ (if defined) and its corresponding type object to attempt to display attributes. Note that built-in dir can result in strange outputs if __getattr__ has been overridden in the object. Read more:\nhttps://docs.python.org/3/library/functions.html#dir Addressing comment:\nApologies, I don't have enough reputation to comment. All objects in Python implicitly have a bunch of special attributes, one of these is the __dict__ attribute. In Python, classes are objects too. Therefore your otherclass class already has a __dict__. In your code, try: In the output you'll see some of the output corresponds to the output of the dir call. Edit 2: Like I said, classes are objects in Python. They implicitly have all of the methods objects have. Try: and you'll find dir in there.", "abstract": ""}, {"id": 52001314, "score": 1, "vote": 0, "content": "I mean for me (python 3.6) dir(otherclass) prints  The iteresting one is __dict__.  So this holds all the methods/attributes specific to that object. However, where do all the others come from? Well, from the superclass: object.__dict__ So dir looks for a __dir__ method, then looks at __dict__ (or __slots__) and then recursively looks up the method resolution order (available as otherclass.mro()) at each class in turn.", "abstract": ""}, {"id": 52001311, "score": 0, "vote": 0, "content": "The answer is in the Python Docs: https://docs.python.org/3/library/functions.html#dir If the object does not provide __dir__(), the function tries its best to gather information from the object\u2019s __dict__ attribute, if defined, and from its type object. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/687239/is-there-a-function-in-python-to-list-the-attributes-and-methods-of-a-particular", "keywords": [], "tags": ["python"], "question": {"id": 687239, "title": "Is there a function in Python to list the attributes and methods of a particular object?", "content": "Is there a function in Python to list the attributes and methods of a particular object? Something like:", "abstract": ""}, "answers": [{"id": 42589909, "score": -1, "vote": 0, "content": "It is surprising to me that no one mentioned the python object function:\nkeys()", "abstract": ""}, {"id": 687252, "score": 68, "vote": 0, "content": "You want to look at the dir() function: li is a list, so dir(li) returns a list of all the methods of a list. Note that the returned list contains the names of the methods as strings, not the methods themselves.  Edit in response to comment:  No this will show all inherited methods as well. Consider this example: test.py: Python interpreter: You should note that Python's documentation states: Note: Because dir()  is supplied\n  primarily as a convenience for use at\n  an interactive prompt, it tries to\n  supply an interesting set of names\n  more than it tries to supply a\n  rigorously or consistently defined set\n  of names, and its detailed behavior\n  may change across releases. For\n  example, metaclass attributes are not\n  in the result list when the argument\n  is a class. Therefore it's not safe to use in your code. Use vars() instead. Vars() doesn't include information about the superclasses, you'd have to collect them yourself. If you're using dir() to find information in an interactive interpreter, consider the use of help().", "abstract": ""}, {"id": 687442, "score": 11, "vote": 0, "content": "and for a more human-readable way, you can use see:", "abstract": ""}, {"id": 687312, "score": 2, "vote": 0, "content": "Another way to do this is with the nifty IPython environment. It lets you tab complete to find all the methods and fields of an object. ", "abstract": ""}, {"id": 687251, "score": 12, "vote": 0, "content": "Don't dir() and vars() suit you?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16284702/python-how-can-i-check-if-an-attribute-of-an-object-is-a-method-or-not", "keywords": [], "tags": ["python", "object", "types", "attributes"], "question": {"id": 16284702, "title": "Python: How can I check if an attribute of an object is a method or not?", "content": "I want to define a class with it's __repr__ method defined in such a way that it will write out only the names and values of all attributes that are not methods. How can I do this? I have managed to write it like this, but I realize that this does not check for the attribute type. What is missing here is the check for the type of the attribute.", "abstract": ""}, "answers": [{"id": 16284994, "score": 2, "vote": 0, "content": "Assuming your class does not define __slots__, you could also just iterate the instance's __dict__ (or via the vars() function). This prints", "abstract": ""}, {"id": 16284833, "score": 5, "vote": 0, "content": "You can use inspect for something like this: This also picks up the double underscore attributes (__module__, __doc__).  If you don't want those, you can pretty easily filter them out.", "abstract": ""}, {"id": 16284773, "score": 2, "vote": 0, "content": "Try built-in function callable:\nhttp://docs.python.org/2/library/functions.html#callable ", "abstract": ""}]}]