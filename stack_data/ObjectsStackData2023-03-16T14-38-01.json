[{"link": "https://stackoverflow.com/questions/71895185/convert-derived-class-to-base-class-in-python", "keywords": [], "tags": ["python", "python-3.x", "casting", "polymorphism", "downcast"], "question": {"id": 71895185, "title": "Convert derived class to base class in Python", "content": "I want to get option from order object like.", "abstract": ""}, "answers": [{"id": 71895268, "score": 0, "vote": 0, "content": "This is not really like inheritance works in Python. One option would be to have a class method te recreate the Option object. I must admit that I don\u2019t see concrete example where this should be usefull.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/9539052/how-to-dynamically-change-base-class-of-instances-at-runtime", "keywords": [], "tags": ["python", "inheritance", "dynamic"], "question": {"id": 9539052, "title": "How to dynamically change base class of instances at runtime?", "content": "This article has a snippet showing usage of __bases__ to dynamically change the inheritance hierarchy of some Python code, by adding a class to an existing classes collection of classes from which it inherits.  Ok, that's hard to read, code is probably clearer: That is, Person doesn't inherit from Friendly at the source level, but rather this inheritance relation is added dynamically at runtime by modification of the __bases__attribute of the Person class.  However, if you change Friendly and Person to be new style classes (by inheriting from object), you get the following error: A bit of Googling on this seems to indicate some incompatibilities between new-style and old style classes in regards to changing the inheritance hierarchy at runtime.  Specifically: \"New-style class objects don't support assignment to their bases attribute\". My question, is it possible to make the above Friendly/Person example work using new-style classes in Python 2.7+, possibly by use of the __mro__ attribute? Disclaimer: I fully realise that this is obscure code.  I fully realize that in real production code tricks like this tend to border on unreadable, this is purely a thought experiment, and for funzies to learn something about how Python deals with issues related to multiple inheritance.", "abstract": ""}, "answers": [{"id": 67276193, "score": 1, "vote": 0, "content": "This method isn't technically inheriting during runtime, since __mro__ can't be changed. But what I'm doing here is using __getattr__ to be able to access any attributes or methods from a certain class. (Read comments in order of numbers placed before the comments, it makes more sense) So this sort of substitution and redirection will simulate the inheritance of the class we wanted to inherit from. And it even works with attributes or methods that don't take any parameters.", "abstract": ""}, {"id": 9639512, "score": 28, "vote": 0, "content": "I've been struggling with this too, and was intrigued by your solution, but Python 3 takes it away from us: I actually have a legitimate need for a decorator that replaces the (single) superclass of the decorated class. It would require too lengthy a description to include here (I tried, but couldn't get it to a reasonably length and limited complexity -- it came up in the context of the use by many Python applications of an Python-based enterprise server where different applications needed slightly different variations of some of the code.) The discussion on this page and others like it provided hints that the problem of assigning to __bases__ only occurs for classes with no superclass defined (i.e., whose only superclass is object). I was able to solve this problem (for both Python 2.7 and 3.2) by defining the classes whose superclass I needed to replace as being subclasses of a trivial class:", "abstract": ""}, {"id": 16157223, "score": 3, "vote": 0, "content": "Right of the bat, all the caveats of messing with class hierarchy dynamically are in effect.  But if it has to be done then, apparently, there is a hack that get's around the \"deallocator differs from 'object\" issue when modifying the __bases__ attribute for the new style classes. You can define  a class object Which derives a class from the built-in metaclass type.\nThat's it, now your new style classes can modify the __bases__ without any problem. In my tests this actually worked very well as all existing (before changing the inheritance) instances of it and its derived classes felt the effect of the change including their mro getting updated.", "abstract": ""}, {"id": 34607323, "score": 1, "vote": 0, "content": "The above answers are good if you need to change an existing class at runtime. However, if you are just looking to create a new class that inherits by some other class, there is a much cleaner solution. I got this idea from https://stackoverflow.com/a/21060094/3533440, but I think the example below better illustrates a legitimate use case.  Correct me if I'm wrong, but this strategy seems very readable to me, and I would use it in production code. This is very similar to functors in OCaml.", "abstract": ""}, {"id": 28075525, "score": 2, "vote": 0, "content": "I needed a solution for this which: Here's what I came up with: Used like this within the application: Use like this from within unit test code:", "abstract": ""}, {"id": 9541560, "score": 43, "vote": 0, "content": "Ok, again, this is not something you should normally do, this is for informational purposes only.   Where Python looks for a method on an instance object is determined by the __mro__ attribute of the class which defines that object (the M ethod R esolution O rder attribute).  Thus, if we could modify the __mro__ of Person, we'd get the desired behaviour.  Something like: The problem is that __mro__ is a readonly attribute, and thus setattr won't work.  Maybe if you're a Python guru there's a way around that, but clearly I fall short of guru status as I cannot think of one. A possible workaround is to simply redefine the class: What this doesn't do is modify any previously created Person instances to have the hello() method.  For example (just modifying main()): If the details of the type call aren't clear, then read e-satis' excellent answer on 'What is a metaclass in Python?'.", "abstract": ""}, {"id": 9540669, "score": 6, "vote": 0, "content": "I can not vouch for the consequences, but that this code does what you want at py2.7.2. We know that this is possible. Cool. But we'll never use it!", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/29620443/python-inheritance-convert-from-base-class-to-derived-class", "keywords": [], "tags": ["python", "inheritance"], "question": {"id": 29620443, "title": "Python inheritance: convert from Base class to Derived class", "content": "I'm still pretty new to Python, so bear with me.  Here is my problem: I have a base class, lets call it a sports game: and I have multiple derived classes for each sport, but lets use baseball as an example: So far everything is good.  However I have another utility function in a separate python module which will generate and populate a list of all the games being played on a given day for that sport. Its obviously much more complicated than this with a lot of parsing using BeautifulSoup, but you get the point.  My problem is that this function returns a list of the Base class, but I need a list of the Derived class.  The derived classes will be the ones calling this function to populate a list and operate on it.  The way I see it, I have two options: Another option I considered, but quickly fell apart, was to send an existing list of derived class objects into the fetch_game_data function, and instead of creating new Game objects it would just populate existing ones.  The problem is that I won't know how many game objects I need.  The fetch_game_data function determines how many games are needed by parsing the webpage.  I suppose I could send in the max number of games but using number_of_teams/2, but what if there is a double-header in baseball?  This quickly falls apart.  I suppose I could write a function that will fetch the game data and just return the number of games for the day.  Then I could populate a list of Derived games that size and send it in to be populated.  But I would have to fetch all the webpage data AGAIN and parse it AGAIN to populate the list. Nothing but bad options!  I'm hoping there is a simple and elegant solution that has just eluded me thus far.  I'm open to any suggestions, including a redesign if it makes sense. Thanks!", "abstract": ""}, "answers": [{"id": 63653214, "score": 0, "vote": 0, "content": "You can convert a class of instance after it is initiated, see example below: In your case, you can convert the class Game to whatever subclass you want after the instance is created.", "abstract": ""}, {"id": 63653014, "score": 0, "vote": 0, "content": "I am porting existing code from c++ and I encountered a similar problem. I have a generic class X and type specific classes e.g. XInt, XStr etc. There is more differences between these classes than just the type of the value. In c++ it was easy: I have virtual X::compare(X const& other). It is overridden in XInt. Inside the overridden method I first handle cases where the 'other' is not XInt and then do static_cast<XInt const&>(other). It is clearly impossible in python. So here is my solution. I added a non-virtual non-public function to do actual comparison to XInt and did not annotate the type of the parameter: Did not test it yet but mypy does not complain and it seems that it will work due to duck typing in python. Maybe something similar will work for you.", "abstract": ""}, {"id": 29621915, "score": -3, "vote": 0, "content": "Python cannot cast an object to another class (even subclass). You must use concrete class when you create the game object. It can be done in a factory method (e.g. create_game), like this:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/57273070/create-a-class-instance-in-python-where-its-base-class-is-specified-dynamically", "keywords": [], "tags": ["python", "metaprogramming", "metaclass"], "question": {"id": 57273070, "title": "create a class instance in python where its base class is specified dynamically by a parameter", "content": "i need to do something like this: the parameters to Base1 and Base2 are uniform and consistent.  the requirement is to pass in the class that DynamicDerive is to derive from at instance creation time. the alternative is \"simple\":  create DynamicDerive1(Base1), DynamicDerive2(Base2), except unfortunately: so a cut/paste option of creating entire swathes of hundreds of identical classes, which merely change the name of the base class, is just not an option. hypothetically this could be solved through a \"redirection\" API, where a special class does this: however although it will work, that entirely defeats the object of the exercise.  there has to be a way to do this that involves meta-programming (meta-classes). looking up metaclass programming tutorials, unfortunately, all show how to create classes from outside of the constructor, whereas what is needed above is for the metaclass to be created inside the constructor. anyone have any clues? [update] - i need to then be able to further derive from DynamicDerive.  GreenCloakGuy kindly answered by providing a function that would do the task, however it is not possible to derive classes from functions. (note: as this is actual libre code, the place where this is required is here:\nhttps://git.libre-riscv.org/?p=ieee754fpu.git;a=blob;f=src/ieee754/fpadd/addstages.py;h=2bc23df0dabf89f8a4e194d5e573a88d5d740d0e;hb=78cbe8c5131a84426a3cad4b0b3ed4ab7da49844#l19 SimpleHandShake needs to be dynamically replaced in around 40 places, where users of this IEEE754 compliant RTL may specify the class that they wish to use.  this is just of over 50 classes that need this capability).", "abstract": ""}, "answers": [{"id": 57278969, "score": 1, "vote": 0, "content": "This thing would be cleaner if you could just use multiple inheritance, and your configuring parameters as Mixin classes  -to the point no special metaclass or action at class creation time would be needed. And, of course, if one won't need neither an issubclass check nor to have subclasses  of DynamicDerive, a factory function, that would take in the bases, keep a registry as a cache, and just instantiate the new object would also not require any special code. But, if you need the parametric bases to be higher up in the MRO than \"DerivedClass\", as you are asking for, then, the way to customize the instance class at class-instantiation time, is to override the __call__ method of the metaclass. (This is what Python run, type.__call__, that will ultimately call the class' __new__ and __init__ methods).  This thing worked here for what I tried - see if it suits you: I imported this, and run this snippet in a Python session: ", "abstract": ""}, {"id": 57273449, "score": 0, "vote": 0, "content": "One thing you might be able to do is to make either a method or a static class that creates the necessary class dynamically and returns an instance of it: This works because the interior code of a function isn't evaluated until it's called, so you can determine the base class of DynamicDerive dynamically, and then do whatever modifications you need to its definition. The downside of this is it's significantly slower, as you have to actually go through the trouble of redefining the class every time. But here's an example of this in action: If you wanted to be really ambitious you could maybe change the __class__ variable in the new class's __init__ (after all, you have the superclass right there if you want it). Before implementing this properly, you'll want to think very carefully about exactly what use cases it's supposed to cover, and whether you can do that in a less hacky - and more explicit - way. Having a bunch of classes that look identical but are not is very confusing to maintain, and could lead to very easy-to-make coding errors.  It would probably be better practice to define separate classes in every individual case where they're necessary, and tailor them to the appropriate use case. Python is duck typed (if it looks like a duck and quacks like a duck, then we may as well assume it's a duck), so anything besides the code that's instantiating a class shouldn't actually care about its type, only about what it can do.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/29413046/python-how-to-rebase-or-dynamically-replace-a-class-with-a-different-base-class", "keywords": [], "tags": ["python", "class", "inheritance", "pyqt", "pyside"], "question": {"id": 29413046, "title": "Python: How to rebase or dynamically replace a class with a different base class", "content": "I am trying to create a common class which I want to use inside different applications.  The idea: a class which could be used as a base class for ui creations. This class will be based to a widget of the applications in it's specific gui system (PySide, or PyQt) This would allow me to follow the same code flow to generate gui's. I like to have same structures inside my pipeline and it makes it much easier to work in different applications with the same commands. The problem: PyQt and PySide are compiled in C++ and do not follow the Python class structure I tried a lot of different things to get it to work, but every time I got stock at some point and doesn't get the result I want. Try (rebase): in this try I used __class__ to rebase the class itself.  The errors I get are reasonable and doesn't has to be explained. Try (rebase): in this try I used __bases__ to rebase the class itself.  In this result, we can see that the object now get's the right base, but don't get it's methods and variables (not even if I call super after setting __bases__).  Try (decorator) : instead of rebase an object I tried to replace the class with another one that has the right base Th e result of this variant doesn't error and prints: <PyQt4.QtGui.QMenuBar object at 0x00000000021C9D38>, but MyGui is not based to PySideGui.QMainWindow like I expected EDIT: Why do not defining classes with a base of PySide and one with a base of PyQt4?:  Because I want to leave it open for a genral use and later extensions. It should be free to set a parent widget, which is defined by the application (PySide or PyQt). But each application has it's own method or function to get it's MainWindow. So if you want extend some widgets of this MainWindow, or just parent a new ui to it you need to define it as the parent, or directly base from it. Some applications and it's API's do not support a free generated ui from type PySide.QtGui.QMainWindow  or PyQt4.QtGui.QMainWindow. That's the main reason I was trying to do it in this way. Of course I could create a UiMainWindow class for each application and base it to it's main window (this is what I do for now), but I was trying to make it more generic and global for my pipeline API. Example of usage: This example is for 3DS-Max and inside a module of it's pipeline integration. Does anyone has a solution for this situation?  Cheers,\nMichael", "abstract": ""}, "answers": [{"id": 29413984, "score": 2, "vote": 0, "content": "Make a factory function which dynamically generates the correct base class. In real life, you'd probably memoize the factory so that it always returns the same class object for a given parent, rather than creating multiple identical classes.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/37679421/adding-extra-functionality-to-parent-class-method-without-changing-its-name", "keywords": [], "tags": ["python", "class"], "question": {"id": 37679421, "title": "Adding extra functionality to parent class method without changing its name", "content": "I have two classes one parent and other child. After inheriting the parent I want to modify Parent method method_parent keeping the original functionality of that method and adding some extra lines of code to that method. I know that I can create a new method like But I want to use the original name of method. I can't copy the source for that method because, the method is from a C module what I want to achieve is something like this Is that even possible?", "abstract": ""}, "answers": [{"id": 37679592, "score": 24, "vote": 0, "content": "You can always call code from the parent using the super() function. It gives a reference to the parent. So, to call parent_method(), you should use super().parent_method().  Here's a code snippet (for python3) that shows how to use it.  In python2, you need to call super with extra arguments: super(ChildClass, self). So, the snippet would become:  If you call f() on an instance of ChildClass, it will show: \"Hi! Hello!\".  If you already coded in java, it's basically te same behaviour. \nYou can call super wherever you want. In a method, in the init function, ...  There are also other ways to do that but it's less clean. For instance, you can do:  To call the f function of parent class. ", "abstract": ""}, {"id": 37679593, "score": 1, "vote": 0, "content": "You can call the parent method exactly the same way you used for the __init__ one: This one is when you want to explicitely name the parent class. If you prefere, you can ask python to give you next class in Method Resolution Order by using super:", "abstract": ""}, {"id": 37679583, "score": 4, "vote": 0, "content": "This is what the super function does. In Python 3, you can call super without the arguments, like super().method_parent()", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/36598311/python-change-base-class-attribute", "keywords": [], "tags": ["python", "class", "attributes"], "question": {"id": 36598311, "title": "python: change base class attribute", "content": "So, I have this class which keeps track of the number of instances that are created: Now, I want to create a derived class, but I don't want its instances to add to the total in Base. So I subtract in order to undo the adding: It works, however, it does not seem to me a good practice to access a base class attribute in the derived class. Is there a better method?", "abstract": ""}, "answers": [{"id": 36598960, "score": 1, "vote": 0, "content": "You can avoid calling superclass constructor in child class. It works fine but not looking very nice class Derived(Base):", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11442100/safe-to-change-base-class-in-python", "keywords": [], "tags": ["python", "class"], "question": {"id": 11442100, "title": "Safe to change base class in python?", "content": "Questions like this exist, but none exactly like this, and I found no completely satisfactory answers. I'm doing an agent-based biological model.  Suppose I have a class of cell type A, and one of type B.  They age according to a clock.  Suppose when a cell of type A reaches a certain age, it changes to a cell of type B. I have an inventory of cells.  I don't want to just create new B cells, and add them to the inventory, and leave the A cells still in the inventory. This appears to work, but is it safe? Or, is there a better approach?", "abstract": ""}, "answers": [{"id": 11442679, "score": 3, "vote": 0, "content": "I tried that many years ago while working on a parser. It seemed to do what I wanted at the time, so was safe enough from the language perspective, but now I am older and wiser I don't think I'd use it for code that anyone else might have to maintain - I don't think it's very \"safe\" from that perspective", "abstract": ""}, {"id": 11442396, "score": 0, "vote": 0, "content": "This might be a good place for delegation. Internally you keep the actual object type that you want, and switch it out when appropriate.", "abstract": ""}, {"id": 11442256, "score": 7, "vote": 0, "content": "While it may be safe for the interpreter, it is definitely unsafe to one trying to understand what's happening. It is hard to find a more natural mapping to object design than a biological cell and you are trying to discard what is naturally there. A cell has-a age and various mechanisms turn on and off as a function of age. In the world, an osteoblast doesn't pop out of existence and an osteocyte takes its place, but rather the cell retains its \"identity\" but behaves differently depending on state values like age. I'd certainly take considerations like that into the object model if I were coding such a model.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/10357394/changing-the-base-class-of-a-class-with-new", "keywords": [], "tags": ["python"], "question": {"id": 10357394, "title": "Changing the base class of a class with __new__", "content": "I would like to change the base class of a class at runtime using __new__.\nI looked as hard as I could, but I couldn't figure it out. What is the proper code to put in __new__() so that the last line return 'hello' and x is an instance of C with base class A. ADDED\nMy use case is the following. I would like the last line to print. I'm a pet.\n  My species is dog. My goal is to use __new__() in PetBuyer like a factory for the animals class. \nMy reason for doing this are that the syntax PetBuyer('Dog') is convenient in my program. ADDED2\nMy reason for doing this is the following. What I have to code is complex for me in the sense that, per see, I cannot infer the proper class design. So I resort to code my problem in anyway I can an refactor as I better understand it. However, with the situation that arise above, it will be too early for me to refactor. I have yet to understand the interaction between some components of my problem, and changing the base class at runtime will help me to do it. I will be more comfortable for refactoring afterward.", "abstract": ""}, "answers": [{"id": 10374190, "score": 0, "vote": 0, "content": "The immediate answer to my question as provided by TokenMacGuy and hinted by delnan is This prints I'm a pet.\n  My species is dog.", "abstract": ""}, {"id": 10359672, "score": 1, "vote": 0, "content": "Based on your new information, it sounds like you need to create types dynamically.  You certainly are not obligated to create a class suite to describe those types, you can create them at run time by calling the type function directly:", "abstract": ""}, {"id": 10357472, "score": 4, "vote": 0, "content": "When you are overriding __new__ that class is already in existence, anyway __new__ is used  to create instances of a given class, what you want can be done via a metaclass, which can act like a factory for classes e.g. output: After seeing OP's edit I will say forget all of the above, you don't need any metaclass, just a simple PetBuyer class which is composed of (has a) Pet , so question is why can't you just pass the pet to PetBuyer e.g. I also do not understand why you need to change the class of PetBuyer, is bad design IMO", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1334222/how-to-change-baseclass", "keywords": [], "tags": ["python", "dynamic", "class"], "question": {"id": 1334222, "title": "How to change baseclass", "content": "I have a class which is derived from a base class, and have many many lines of code e.g. What I want to do is change the baseclass so that it works like I have use for both type of AutoCompletes and may be would like to add more base classes, so how can I do it dynamically? Composition would have been a solution, but I do not want to modify code a lot. any simple solutions?", "abstract": ""}, "answers": [{"id": 1335308, "score": 2, "vote": 0, "content": "You could use multiple inheritance for this: Also, there's the option of a metaclass: But I'd still suggest the class factory approach already suggested, one level of indentation really isn't that big of a deal.", "abstract": ""}, {"id": 1334242, "score": 7, "vote": 0, "content": "You could have a factory for your classes: And then use: On the other hand depending on what you want to achieve and how your classes look, maybe AutoComplete is meant to be a mixin, so that you would define TextAutoComplete with:", "abstract": ""}, {"id": 1334256, "score": 1, "vote": 0, "content": "You could modify the __bases__ tuple. For example you could add another baseclass: But in general I would try to avoid such hacks, it quickly creates a terrible mess.", "abstract": ""}]}]