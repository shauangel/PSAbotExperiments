[{"link": "https://stackoverflow.com/questions/75534669/list-api-scopes-of-service-account-in-domain-wide-delegation", "keywords": [], "tags": ["python", "oauth-2.0", "google-api", "google-oauth"], "question": {"id": 75534669, "title": "List API scopes of Service Account in domain-wide delegation", "content": "Is there a way to list all of the API scopes for a service account in the domain wide delegation using the python SDK?\nFor example if I had a service account with the client id \"1234\", how would I, using the python SDK, list all of its scopes (for example https://www.googleapis.com/auth/admin.directory.group and such) assuming that I don't know any of its scopes beforehand. I have tried to ask chatGPT but it said that the scopes would be part of the build() function response (which I didn't find), I also tried looking for it on google and didn't find any information regarding this question.", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/74562159/google-calendar-api-with-domain-wide-delegation-events-watch-method-fails-with", "keywords": [], "tags": ["python", "google-cloud-platform", "google-calendar-api", "google-api-python-client", "service-accounts"], "question": {"id": 74562159, "title": "Google Calendar API with domain wide delegation: events.watch method fails with &quot;The request is missing a valid API key&quot;", "content": "I have followed all of the steps for domain wide delegation. An example of this is the ability to sign in with the service account json, impersonate users in my Google Workspace account and list their events (see example below). The problem I am having is that the same setup doesn't let me receive notifications from the watch() method... Running the watch() method returns the following to the terminal. Upon following the resourceUri I see the aforementioned error message. very single change in the target calendar hits my https webhook/endpoint with a 400 BAD REQUEST. I cannot even read the request in my Flask backend. Can someone please help me understand why I am not able to receive push notifications (why they all return 400 BAD REQUEST)? PS: I have read that I can provide some further access credentials via a bearer token in the header. But there is no header attribute in these methods. Here are the images below for the workspace admin settings in question:\n", "abstract": ""}, "answers": [{"id": 74563541, "score": 0, "vote": 0, "content": "'resourceUri': 'https://www.googleapis.com/calendar/v3/calendars/workspace-user-1%40company.com/events?alt=json' All that is is telling you what notification endpoint the message response is for. In which case you will need to do a Your getting missing api key because your calling the endpoint without first being authorized. Authorize the call then check it and you will get a response.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/74838075/how-do-i-use-python-with-google-apis-to-request-a-list-of-delegates-and-to-also", "keywords": [], "tags": ["python", "google-api-python-client", "delegation"], "question": {"id": 74838075, "title": "How do I use Python with Google APIs to request a list of delegates, and to also add and remove delegates?", "content": "People in our environment think if they can not see a group, or user, it is okay to request that email address as a group. For whatever purpose, not realizing that it may already be created, they just do not have access. I am attempting to design a website where my help desk can do a lookup of an email alias, return if it's a group or an email.  If it's a group, return the managers for the group, if it's an email account, return any delegates to the account.  I have most of this already worked out...  but I am having difficulty with the delegate list, add, delete code.  I can't find any working examples online (like I seem to be able to find for everything else). What I am searching for:\nThe scope for this lookup (listing) and possibly modification (create\\delete delegates)\nThe code for the lookup (please see below for what has NOT worked for me)\nIt may also require a separate credentials call...  but I can't seem to find concrete evidence of this. For example, I have been attempting to create a function, which is not currently working. I am getting the following error, which leads me to believe my command is not formatted properly. I would expect the delegateDump variable to be the successful list of delegates on the account I replace email@domain.com with. The account I am replacing it with does have a few delegates assigned.", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/74289149/delegation-pattern-in-python-using-annotation", "keywords": [], "tags": ["python-3.x", "annotations", "delegation"], "question": {"id": 74289149, "title": "Delegation pattern in Python using annotation", "content": "I have a class that should mimic behaviour of other class but with some flavour. For example Kotlin have delegation pattern (https://www.baeldung.com/kotlin/delegation-pattern) as a part of language to do such thing. But for Python when I try code below: I get the following error: What are my final purposes: Any suggestion how can I do something like this in Python 3?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/70329648/type-friendly-delegation-in-python", "keywords": [], "tags": ["python", "python-3.x", "python-typing"], "question": {"id": 70329648, "title": "type friendly delegation in Python", "content": "Consider the following code sample The code works well except that type hint is lost.\nIt's very common in Python to use *args, **kwargs to implement delegation pattern. It would be great to have a way to keep the type hint while using them, but I don't know if it is possible and how.", "abstract": ""}, "answers": [{"id": 73454235, "score": 2, "vote": 0, "content": "See https://github.com/python/typing/issues/270 for a long discussion of this problem. You can achieve this by decorating wrap with an appropriately typed identity function: As far as I know, the decorator is necessary - it is still not possible to do this using type hints alone, even with PEP612. Since it was already good practice to use the functools.wraps decorator in this situation (which copies the runtime type information), this is not such a loss - you could instead define and then both the runtime and static type information should be correct so long as you use this decorator. (Sadly the typeshed stubs for functools.wraps included with mypy aren't quite restrictive enough to get this working out of the box.) PEP612 adds the ability to add/remove arguments in your wrapper (by combining ParamSpec with Concatenate), but it doesn't remove the need for some kind of higher-order function (like a decorator) to let the type system infer the signature of wrap from that of s.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72195089/creating-an-automatic-delegating-wrapper-class-in-python-3", "keywords": [], "tags": ["python", "python-3.x", "metaprogramming", "wrapper", "delegation"], "question": {"id": 72195089, "title": "Creating an automatic delegating wrapper class in Python 3", "content": "I created a delegating wrapper class in Python 3(.8), which allow me to fully replicate the base-class' API, delegate to the underlying instance, and swap the underlying instance when necessary. I'm still not getting full API-parity, so I thought I'd share and ask for help. I know this is an odd choice, but I need to support an existing API, which is (a) very extensive, and (b) not in my control (3rd party library), while being able to swap the underlying instance without the caller-code knowing. E.g.: Here's the code I have thus far: The calling code prints oddly - instead of calling the newly-minted delegating properties, it just prints property(...). Would be happy for any help. Thanks!", "abstract": ""}, "answers": [{"id": 72203178, "score": 1, "vote": 0, "content": "I just realized this can be easily solved using Python's dynamic dispatch. For posterity, you can achieve this by: For a deeper explanation, see this SO question.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64264164/automatic-method-delegation-in-python", "keywords": [], "tags": ["python-3.x", "oop"], "question": {"id": 64264164, "title": "Automatic method delegation in Python", "content": "I have a rather contrived code here : So the BackendAdaptor class basically would be used to do some validation and conversion of the data that we get from the Backend . The client should only be asked to interact with the API of the BackendAdaptor which is exactly similar to that of Backend . The adaptor class sits in middle and gets data from Backend does some validation if required and the gives back the data to client. The issue is that the validation on the data that is getting returned from the Backend is not done for every method(For ex: there is validation done on get_all_members but not on get_all_admins and also not on get_all_juniors). The method just gives back a generator on whatever data it gets from Backend. As is the case now i still have to implement a one liner methods for them . Is there a way in Python to avoid this ? I am thinking in lines of magic methods like __getattribute__ ? But i have no idea on how to do this for methods. So the best case scenario is this: Any help would be greatly appreciated.", "abstract": ""}, "answers": [{"id": 64265414, "score": 1, "vote": 0, "content": "You can implement __getattr__. It is only called if a non-existing attribute is accessed. This will return some generic function with the desired functionality.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/21961806/method-delegation-in-python", "keywords": [], "tags": ["python", "python-2.7", "reflection", "delegation", "message-passing"], "question": {"id": 21961806, "title": "Method delegation in python", "content": "I'm writing a small framework for orchestrating AWS clusters and there are some common hierarchical patterns that appear over and over again. One such pattern is gathering a collection of instances into a bigger object and then delegating some methods down to all the instances directly. So instead of copying and pasting the same boilerplate code over and over again I abstracted it with the following pattern: Is there a better way or pattern for accomplishing the delegation?", "abstract": ""}, "answers": [{"id": 55563139, "score": 14, "vote": 0, "content": "I've been researching on this and found two solutions. Use a decorator to change the class and create the delegators, or using descriptors for the delegators. I started with the first and then evolve to the second which I like more, so I will start by it. Both can be found here: https://gist.github.com/dhilst/7435a09b4419da349bb4cc4ae855a451 with doctests :) -- Edit -- For anybody interested I made this a library: https://pypi.org/project/delegateto/ There were bugs in gist implementation, people contributed to this on github, the pypi project is updated, gist not. I strongly recommend you to use pypi version. Descriptors are things that can be getted and setted. In this case we are interested in the gettable ability of descriptors. The delegate descriptor defined like this And is used like this To call a descriptor simply call the method Foo('hello').upper(). Magic methods also works len(Foo('', [1,2,3,4])) returns 4. The gist link above has a more powerful implementation but the basics is the same. Everytime that you need to change a class behavior in an repetitive way, a decorator is a candidate. In this case the decorator will call setattr at the class to create the delegators. The usage is also simple, just decorate the class, as many times you want. The decorator will modify the class inplace so the same class is returned. Here is a usage And the call of the delegated method is also transparent Foo('hello').upper(). I prefer the second one because it seems more idiomatic for me. The decorator has an advantage to support multiple methods but this is implementable on the descriptor form too.  Again, I really recommend that you see the gist: https://gist.github.com/dhilst/7435a09b4419da349bb4cc4ae855a451 there are tons of examples in the docstring. Just modify them and execute the scripts to play around. -- Edit -- For any body interested, I make this a pip package https://pypi.org/project/delegateto/ -- Edit --  There were bugs in gist implementation, people contributed to this on github, the pypi project is updated, gist not. I strongly recommend you to use pypi version. Regards", "abstract": ""}, {"id": 21966266, "score": 15, "vote": 0, "content": "__getattr__ is called when the whole class hirarchy is traversed and the attribute is not found. So it is better to generate the method once and store it in the class. Then finding the method takes less time next time. Here you can see the adaption of your code to do that:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46677221/delegation-design-pattern-with-abstract-methods-in-python", "keywords": [], "tags": ["python", "inheritance", "design-patterns", "delegation", "abc"], "question": {"id": 46677221, "title": "Delegation design pattern with abstract methods in python", "content": "I have the following classes implementing a \"Delegation Design Pattern\" with an additional DelegatorParent class: Everything looks fine. Now I would like to put an abstract method in DelegatorParent, to ensure that \"myMethod\" is always defined. Can you help me find an \"elegant\" way to remove \"myMethod\" from \"Delegator\"... Intuition tells me that it is somehow redundant (considering that a custom getattr method is defined). And more importantly, notice that with this implementation, if I forget to define myMethod in ConcreteDelegatee the program compiles, but it may crash in runtime if I call Delegator.myMethod(), which is exactly what I wanted to avoid by using abstract methods in DelegatorParent. Obviously a simple solution would be to move @abstractmethod to the Delegator class, but I want to avoid doing that because in my program DelegatorParent is a very important class (and Delegator is just an auxiliary class).", "abstract": ""}, "answers": [{"id": 46761813, "score": 6, "vote": 0, "content": "You can decide to automatically implement abstract methods delegared to ConcreteDelegatee. For each abstract method, check if it's name exist in the ConcreteDelegatee class and implement this method as a delegate to this class method. This solves the main problem (prevent ConcreteDelegatee from forgetting to define myMethod). Other abstract methods are still checked if you forgot to implement them. The __new__ method is in charge of the delegation, that frees your __init__ to do it.", "abstract": ""}, {"id": 46760730, "score": 0, "vote": 0, "content": "Here is my current solution. It solves the main problem (prevent ConcreteDelegatee from forgetting to define myMethod), but I'm still not convinced because I still need to define myMethod inside Delegator, which seems redundant", "abstract": ""}, {"id": 46747139, "score": 0, "vote": 0, "content": "Since you use ABCMeta, you must defined the abstract methods. One could remove your method from the __abstractmethods__ set, but it is a frozenset. Anyway, it involves listing all abstract methods. So, instead of playing with __getattr__, you can use a simple descriptor. For instance: An advantage here: the developer has the explicit information that \"myMethod\" is delegated. If you try: It works! But if you forget to implement myMethod in Delegator class, you have the classic error: Edit This implementation can be generalized as follow: Here, we can specify the delegatee name and delegatee method.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/3643538/delegates-in-python", "keywords": [], "tags": ["python", "design-patterns", "delegates"], "question": {"id": 3643538, "title": "Delegates in python", "content": "I've implemented this short example to try to demonstrate a simple delegation pattern. My question is. Does this look like I've understood delegation right?", "abstract": ""}, "answers": [{"id": 3643731, "score": 17, "vote": 0, "content": "One Python tip: you don't need to say: just say: I'm not sure what you are doing with your Handler class, it isn't used in your example. And in Python, methods with upper-case names are very very unusual, usually a result of porting some existing API with names like that.", "abstract": ""}, {"id": 3643625, "score": 10, "vote": 0, "content": "That's the basic concept, yes - passing on some incoming request to another object to take care of.", "abstract": ""}]}]