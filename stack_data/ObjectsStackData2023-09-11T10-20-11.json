[{"link": "https://stackoverflow.com/questions/57300379/how-to-force-derived-class-to-call-super-class-method-at-multiple-layers", "keywords": [], "tags": ["java", "design-patterns"], "question": {"id": 57300379, "title": "How to force derived class to call super class method at multiple layers?", "content": "I am trying to find the most elegant way to allow a child and parent to react to an event initiated by the grandparent. Here's a naive solution to this: So basically, I'm trying to find the best way to allow all related classes to perform some logic when foo() is called. For stability and simplicity purposes I prefer if it is all done in order, although it's not a requirement. One other solution I found involves storing all the event handlers as some form of Runnable: This method is certainly preferable to the first. However I am still curious if there is a better option.", "abstract": ""}, "answers": [{"id": 76953555, "score": 0, "vote": 0, "content": "I really like the idea of accumulating handlers from the OP!\nMy approach so far was to define a public inner class with a private constructor in my given base class and then use it as a return type of the method that was supposed to be overridden in subclasses: This way regardless how many levels of inheritance there are, each subsequent subclass must call super.methodToOverrideInSubclasses() to obtain an instance of SuperEnforcer to return it at the end.\nThis also gives subclasses a freedom to decide at which point of their implementation to call super.methodToOverrideInSubclasses() (with \"handler\" approach this can be also achieved by providing addHeadFooHandler(fooHandler) and addTailFooHandler(fooHandler)).\nUnfortunately, it is still possible to return null, but this can now be statically checked with @Nonnull.", "abstract": ""}, {"id": 61865242, "score": 0, "vote": 0, "content": "Have you considered the Template Method pattern? It works well to define a high level method that delegates to derived types to fill-in the gaps.", "abstract": ""}, {"id": 57334037, "score": 0, "vote": 0, "content": "What about this by calling the super method?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/357307/how-to-call-a-parent-class-function-from-derived-class-function", "keywords": [], "tags": ["c++", "oop", "inheritance"], "question": {"id": 357307, "title": "How to call a parent class function from derived class function?", "content": "How do I call the parent function from a derived class using C++? For example, I have a class called parent, and a class called child which is derived from parent. Within \neach class there is a print function.  In the definition of the child's print function I would like to make a call to the parents print function.  How would I go about doing this?", "abstract": ""}, "answers": [{"id": 357312, "score": 267, "vote": 0, "content": "Given a parent class named Parent and a child class named Child, you can do something like this: Note that Parent is the class's actual name and not a keyword.", "abstract": ""}, {"id": 55987086, "score": 11, "vote": 0, "content": "Call the parent method with the parent scope resolution operator. Parent::method()", "abstract": ""}, {"id": 357380, "score": 968, "vote": 0, "content": "I'll take the risk of stating the obvious: You call the function, if it's defined in the base class it's automatically available in the derived class (unless it's private). If there is a function with the same signature in the derived class you can disambiguate it by adding the base class's name followed by two colons base_class::foo(...). You should note that unlike Java and C#, C++ does not have a keyword for \"the base class\" (super or base) since C++ supports multiple inheritance which may lead to ambiguity. Incidentally, you can't derive directly from the same class twice since there will be no way to refer to one of the base classes over the other.", "abstract": ""}, {"id": 34461014, "score": 10, "vote": 0, "content": "If access modifier of base class member function is protected OR public, you can do call member function of base class from derived class. \nCall to the base class non-virtual and virtual member function from derived member function can be made.\nPlease refer the program.   Output:", "abstract": ""}, {"id": 357325, "score": 38, "vote": 0, "content": "If your base class is called Base, and your function is called FooBar() you can call it directly using Base::FooBar()", "abstract": ""}, {"id": 23996527, "score": -19, "vote": 0, "content": "Reference example.", "abstract": ""}, {"id": 912128, "score": 32, "vote": 0, "content": "In MSVC there is a Microsoft specific keyword for that: __super MSDN:\nAllows you to explicitly state that you are calling a base-class implementation for a function that you are overriding. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61980377/im-trying-to-make-a-derived-class-method-available-through-a-base-class-referen", "keywords": [], "tags": ["java", "oop", "dynamic-binding"], "question": {"id": 61980377, "title": "I&#39;m trying to make a derived class method available through a base class reference", "content": "I'm trying to call a derived class method with a base class reference but I do not want to implement it in the base class or other derived classes. Only in that one derived class. One alternative I looked into was to declare the function and base class as abstract. The only problem is if I make the base class and method abstract, I have to implement the abstract method in all of the derived classes. Is there a way to do this where I don't have to implement the abstract method in all of the derived classes and I can just define it in the class where the method makes sense? Keep in mind that I also don't want to implement method this in the base class and I want to call it through a base class reference of a derived object. \"inputSquareFt\" is the function that I'm trying to call in the derived class (Landscaping) from the base class (Service) reference \"newS\" is main. Thanks", "abstract": ""}, "answers": [{"id": 61980608, "score": 0, "vote": 0, "content": "Downcast the Service reference to Landscaping to tell the compiler that you know for sure it's a Landscaping object, then it will let you call the method. If you're wrong you'll get a ClassCastException at runtime, your penalty for lying to the compiler.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/56431762/why-does-java-base-class-constructor-call-derived-class-methods", "keywords": [], "tags": ["java", "inheritance"], "question": {"id": 56431762, "title": "Why does Java base class constructor call derived class&#39; methods?", "content": "I have a derived Java class override a base class' method. When the base class calls the method, it executes the derived class' function, rather than its own. Why? The code prints Derived::f() twice, I expect it to print Base::f() followed by Derived::f(), as would happen in C++", "abstract": ""}, "answers": [{"id": 56431853, "score": 2, "vote": 0, "content": "Your Derived f() method is overriding the Base f() method. If you want to see the Base method try putting super.f(); in the start of the Derived f() method, this will call the super class' f() method.", "abstract": ""}, {"id": 56431822, "score": 5, "vote": 0, "content": "In Java, unlike in C++, instance methods are virtual by default. It means that a method call is dispatched at the run time according to the actual run-time class of an object (not at the compile time). In C++, you achieve this behaviour with keyword virtual.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/54977662/using-derived-class-instance-inside-base-class-to-call-base-class-method-with-de", "keywords": [], "tags": ["angular", "typescript", "generic-programming"], "question": {"id": 54977662, "title": "Using Derived-Class Instance Inside Base-Class to Call Base-Class Method with Derived-class Data", "content": "i have a base generic component and i want to call derived method from base class that return data that belongs to derived class. first problem is, i cant define it static in abstract class! second problem is, when i create new instance of derived class with {} as TDomain inside base generic class, its empty and method return null ref error ! Base Entity is like this: My Model is Like this: I have a generic base component: and derived component:", "abstract": ""}, "answers": [{"id": 55557047, "score": 0, "vote": 0, "content": "To create an instance of TDomain you need to pass the constructor of TDomain to the base class: link form github repository call derived class method inside base generic class", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52631439/typescript-inheritance-call-function-from-base-class", "keywords": [], "tags": ["typescript", "oop", "inheritance"], "question": {"id": 52631439, "title": "Typescript inheritance call function from base class", "content": "I am using inheritance to split the logic through base and derived class. In the following case scenario: what is the way to call the function from the base class? Should the \"consoleGivenMessage(text:string)\" been implemented in the base class as well? Any help is welcome", "abstract": ""}, "answers": [{"id": 52631739, "score": 1, "vote": 0, "content": "The short answer to your question is, you have to implement consoleGivenMessage(text: string) in FirstClass so that you can call it on instances of both FirstClass and SecondClass.  However, there is more-- Most of the time, you call an inherited method from the derived class instead of the other way round. But, you can also have a base class that depends on an abstract method that is implemented in a derived class. Say, you have a class A that depends on a method DoIt() which is implemented only in derived class B, you would have to declare A as an abstract class and DoIt() as an abstract method; then, in B (which is not abstract--that is, it is concrete) you would implement the method DoIt(). This also means that you cannot instantiate an object of A because it is not complete without a full implementation of DoIt, but you can instantiate an object of B. However, you can define an object of A, like this: const a: A = new B(). And, you can call a.DoIt(). In this case, the implementation of B.DoIt() would actually be called. This technique is used in the Template Method design pattern.  TypeScript classes, inheritance, and abstract classes are well documented.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/49779734/whose-method-gets-overridden-when-a-derived-class-extends-a-base-class-and-at-th", "keywords": [], "tags": ["java", "inheritance", "interface", "overriding"], "question": {"id": 49779734, "title": "Whose method gets overridden when a derived class extends a base class and at the same time implements an interface?", "content": "Case 1: I have an Interface Inter.java: A base class: A Derived class: Now I compile it: That means the overridden method abcd() in the class Use is from the implemented interface \"Inter\" and not from the base class \"Base\". Case 2: We have a file Test.java containing following codes: When we execute it we got: Since t.start() executed the method run(), that means method run() of the class Thread got overridden. But in the case 1 method abcd() of the interface \"Inter\" got overridden. In case 1: Whose method abcd() is overridden in class Use? Class Base or interface Inter? Error says we are overriding the abcd() of interface Inter. But in case 2: It seems that we are not overriding the method run of interface Ab. Because we can execute the run() method by calling t.start(). Which is only possible if we are overriding the run() of class Thread.", "abstract": ""}, "answers": [{"id": 49780628, "score": 0, "vote": 0, "content": "In the Inter interface, void abcd(); is the definition of an abstract method. All abstract methods are inherently public. From {Defining an Interface}, All abstract, default, and static methods in an interface are implicitly public, so you can omit the public modifier. So, while Inter said that abcd() was public, the actual implementation in Use is saying that the implementation of abcd() is package-private, which is a weaker access privilege. This should address your comment \"//intentionally not using public\".\nTraditionally, abcd() should also use the annotation @Override (although it is not a hard requirement). In your second example, Thread class provides a concrete implementation of run(). Given that A#run() is public, you have satisfied the requirement imposed by interface Ab regarding access specifiers. Then, A#run() went on to override Thread#run() - which is exactly how we would expect inheritance to behave.  To summarize, we just saw the difference between extends (extending or overriding class methods) and implements (contract that the given class provides an implementation for all the methods states in the interface). {This answer} goes into more depth about this and is an excellent read. Let me know if any part of this answer needs more clarity.", "abstract": ""}, {"id": 49780213, "score": 1, "vote": 0, "content": "The method in your class overrides the base class method and implements the interface, at the same time. Overriding a method is not exactly the same as implementing an interface : Implementations and overrides of a method can always extend its visibility, but not decrease it. This means : Methods in an interface are always public, even if the \"public\" modifier is not specified in the interface. Hence, their implementations must also be public => that's the error you get in your case 1 As a side note, in your case 2, you are using threads wrong. Do not subclass Thread. Instead, create a class implementing the Runnable or Callable interface, and submit it to a thread pool (see classes in java.util.concurrent, or for a quick test use java 8's ForkJoinPool.commonPool().submit(myTask).", "abstract": ""}, {"id": 49779819, "score": 0, "vote": 0, "content": "Both. Method overriding depends on the name and signature of the method not where it is defined. If defined on more than one ancestor, it overrides both.\nNote: If defined as public in one and protected in another, it'll become public.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/268929/in-java-how-do-i-call-a-base-classs-method-from-the-overriding-method-in-a-der", "keywords": [], "tags": ["java", "inheritance", "methods", "polymorphism"], "question": {"id": 268929, "title": "In Java, how do I call a base class&#39;s method from the overriding method in a derived class?", "content": "I have two Java classes: B, which extends another class A, as follows : I would like to call the A.myMethod() from B.myMethod(). I am coming from the C++ world, and I don't know how to do this basic thing in Java.", "abstract": ""}, "answers": [{"id": 20717767, "score": 2, "vote": 0, "content": "", "abstract": ""}, {"id": 268946, "score": 21, "vote": 0, "content": "super.MyMethod() should be called inside the MyMethod() of the class B. So it should be as follows", "abstract": ""}, {"id": 268940, "score": 145, "vote": 0, "content": "Just call it using super.", "abstract": ""}, {"id": 37280137, "score": 3, "vote": 0, "content": "See, here you are overriding one of the method of the base class hence if you like to call base class method from inherited class then you have to use super keyword in the same method of the inherited class.", "abstract": ""}, {"id": 36887310, "score": 1, "vote": 0, "content": "If u r using these methods for initialization then use constructors of class A and pass super keyword inside the constructor of class B. Or if  you want to call a method of super class from the subclass method then you have to use super keyword inside the subclass method  like : \nsuper.myMethod();", "abstract": ""}, {"id": 23112447, "score": 7, "vote": 0, "content": "I am pretty sure that you can do it using Java Reflection mechanism. It is not as straightforward as using super but it gives you more power.", "abstract": ""}, {"id": 20717843, "score": 3, "vote": 0, "content": "", "abstract": ""}, {"id": 8134798, "score": 21, "vote": 0, "content": "Answer is as follows:", "abstract": ""}, {"id": 7427979, "score": 4, "vote": 0, "content": "call the base methods with super keyword and pass the respective params.", "abstract": ""}, {"id": 268941, "score": 4, "vote": 0, "content": "Use the super keyword.", "abstract": ""}, {"id": 268939, "score": 153, "vote": 0, "content": "The keyword you're looking for is super. See this guide, for instance.", "abstract": ""}, {"id": 268937, "score": 8, "vote": 0, "content": "call super.myMethod();", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44819707/call-a-base-class-method-using-a-derived-class-object-outside-the-derived-class", "keywords": [], "tags": ["python", "inheritance", "super"], "question": {"id": 44819707, "title": "call a base class method using a derived class object outside the derived class", "content": "i have seen many posts that describe how to call base class function is called inside a derived class function using the super keyword.I want to call a base class overloaded function globally using a derived class object.", "abstract": ""}, "answers": [{"id": 44819837, "score": 1, "vote": 0, "content": "Input: Output: Edit: As mentionned in comment below, in Python 2.7+ you need to declare class a(object) for this to work. This comes from a historical evolution of classes in Python, with this solution being functional for \"new-style\" classes only, i.e. for classes inheriting from object. In Python 3.x however, all classes are \"new-style\" by default, meaning you don't have to perform this small addition.", "abstract": ""}, {"id": 44820354, "score": 1, "vote": 0, "content": "If you really want to call the 'base' function that works on old-style classes (classes that don't extend object) you can do it like: Or if you don't know the base/parent class, you can 'extract' it from the instance itself: But save yourself some trouble and just extend your base classes from object so you can use the super() notation instead of doing bases acrobatics.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/15299686/calling-derived-class-method-using-base-class-object", "keywords": [], "tags": ["java"], "question": {"id": 15299686, "title": "calling derived class method using base class object", "content": "I have 6 classes as shown in figure below.\nNow, class A has an object of class B as a private variable defined. Also class A methods calls many methods from class B, for example B.method1().\nNow, class A_Base1 is which is derived from class A, needs to call methods from the derived class B_Base1; for example B1.method2(). And also methods of class A_Base2 needs to call methods from class B_Base2; for example B2.method3(). Now in class A I define the variable as -  private B bObject Now in method of A_Base1, I cannot cannot call the methods like bObject.method2() since its a base class object. I need suggestions on -  Is it possible to call derived class object methods using base class object?\nOr do I need to re-design this scenario in some other good way? ", "abstract": ""}, "answers": [{"id": 15299859, "score": 3, "vote": 0, "content": "Using inheritance like this imo only makes sense if the Bx.methodX() do something that means she same to the different Ax. And in that case, you should name them that way: and then you only need A to call doWhatAMeans() and the A1 and A2 only need to be injected the appopriate instances of Bx. On the other hand, if doWhatAMeans does not make sense because the methodX do different things that mean different things to Ax, then you need to rethink your object model, probably the parallel structures A,A1,A2 and B,B1,B2 are wrong then.", "abstract": ""}, {"id": 15299777, "score": 0, "vote": 0, "content": "since A is a parent of A_Base1 (I'm assuming extended) you can make the function call that Accesses B public (or protected) and then A_Base1 or A_Base2 can use the same function A does to call into B.", "abstract": ""}, {"id": 15299746, "score": 3, "vote": 0, "content": "you could always cast. suppose your class A provides this method: then in A_Base1 you could do something like: this, however, is a VERY bad design. if your A_Base1 class needs an instance of B_Base1 it should be handed such an instance directly at construction time: and then you can use that", "abstract": ""}]}]