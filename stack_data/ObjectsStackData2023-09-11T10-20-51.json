[{"link": "https://stackoverflow.com/questions/306313/is-operator-behaves-unexpectedly-with-integers", "keywords": [], "tags": ["python", "int", "operators", "identity", "python-internals"], "question": {"id": 306313, "title": "&quot;is&quot; operator behaves unexpectedly with integers", "content": "Why does the following behave unexpectedly in Python? I am using Python 2.5.2. Trying some different versions of Python, it appears that Python 2.3.3 shows the above behaviour between 99 and 100. Based on the above, I can hypothesize that Python is internally implemented such that \"small\" integers are stored in a different way than larger integers and the is operator can tell the difference. Why the leaky abstraction? What is a better way of comparing two arbitrary objects to see whether they are the same when I don't know in advance whether they are numbers or not?", "abstract": ""}, "answers": [{"id": 306353, "score": 456, "vote": 0, "content": "Take a look at this: Here's what I found in the documentation for \"Plain Integer Objects\": The current implementation keeps an array of integer objects for all integers between -5 and 256. When you create an int in that range you actually just get back a reference to the existing object. So, integers 256 are identical, but 257 are not. This is a CPython implementation detail, and not guaranteed for other Python implementations.", "abstract": ""}, {"id": 34964030, "score": 77, "vote": 0, "content": "I'm late but, you want some source with your answer? I'll try and word this in an introductory manner so more folks can follow along. A good thing about CPython is that you can actually see the source for this. I'm going to use links for the 3.5 release, but finding the corresponding 2.x ones is trivial. In CPython, the C-API function that handles creating a new int object is PyLong_FromLong(long v). The description for this function is: The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-) (My italics) Don't know about you but I see this and think: Let's find that array! If you haven't fiddled with the C code implementing CPython you should; everything is pretty organized and readable. For our case, we need to look in the Objects subdirectory of the main source code directory tree. PyLong_FromLong deals with long objects so it shouldn't be hard to deduce that we need to peek inside longobject.c. After looking inside you might think things are chaotic; they are, but fear not, the function we're looking for is chilling at line 230 waiting for us to check it out. It's a smallish function so the main body (excluding declarations) is easily pasted here: Now, we're no C master-code-haxxorz but we're also not dumb, we can see that CHECK_SMALL_INT(ival); peeking at us all seductively; we can understand it has something to do with this. Let's check it out: So it's a macro that calls function get_small_int if the value ival satisfies the condition: So what are NSMALLNEGINTS and NSMALLPOSINTS? Macros! Here they are: So our condition is if (-5 <= ival && ival < 257) call get_small_int. Next let's look at get_small_int in all its glory (well, we'll just look at its body because that's where the interesting things are): Okay, declare a PyObject, assert that the previous condition holds and execute the assignment: small_ints looks a lot like that array we've been searching for, and it is! We could've just read the damn documentation and we would've know all along!: So yup, this is our guy. When you want to create a new int in the range [NSMALLNEGINTS, NSMALLPOSINTS) you'll just get back a reference to an already existing object that has been preallocated. Since the reference refers to the same object, issuing id() directly or checking for identity with is on it will return exactly the same thing. During initialization in _PyLong_Init Python will gladly enter in a for loop to do this for you: Check out the source to read the loop body! I hope my explanation has made you C things clearly now (pun obviously intented). This is actually easier to explain, and I have attempted to do so already; it's due to the fact that Python will execute this interactive statement as a single block: During complilation of this statement, CPython will see that you have two matching literals and will use the same PyLongObject representing 257. You can see this if you do the compilation yourself and examine its contents: When CPython does the operation, it's now just going to load the exact same object: So is will return True.", "abstract": ""}, {"id": 49472348, "score": 17, "vote": 0, "content": "There's another issue that isn't pointed out in any of the existing answers. Python is allowed to merge any two immutable values, and pre-created small int values are not the only way this can happen. A Python implementation is never guaranteed to do this, but they all do it for more than just small ints. For one thing, there are some other pre-created values, such as the empty tuple, str, and bytes, and some short strings (in CPython 3.6, it's the 256 single-character Latin-1 strings). For example: But also, even non-pre-created values can be identical. Consider these examples: And this isn't limited to int values: Obviously, CPython doesn't come with a pre-created float value for 42.23e100. So, what's going on here? The CPython compiler will merge constant values of some known-immutable types like int, float, str, bytes,  in the same compilation unit. For a module, the whole module is a compilation unit, but at the interactive interpreter, each statement is a separate compilation unit. Since c and d are defined in separate statements, their values aren't merged. Since e and f are defined in the same statement, their values are merged. You can see what's going on by disassembling the bytecode. Try defining a function that does e, f = 128, 128 and then calling dis.dis on it, and you'll see that there's a single constant value (128, 128) You may notice that the compiler has stored 128 as a constant even though it's not actually used by the bytecode, which gives you an idea of how little optimization CPython's compiler does. Which means that (non-empty) tuples actually don't end up merged: Put that in a function, dis it, and look at the co_consts\u2014there's a 1 and a 2, two (1, 2) tuples that share the same 1 and 2 but are not identical, and a ((1, 2), (1, 2)) tuple that has the two distinct equal tuples. There's one more optimization that CPython does: string interning. Unlike compiler constant folding, this isn't restricted to source code literals: On the other hand, it is limited to the str type, and to strings of internal storage kind \"ascii compact\", \"compact\", or \"legacy ready\", and in many cases only \"ascii compact\" will get interned. At any rate, the rules for what values must be, might be, or cannot be distinct vary from implementation to implementation, and between versions of the same implementation, and maybe even between runs of the same code on the same copy of the same implementation. It can be worth learning the rules for one specific Python for the fun of it. But it's not worth relying on them in your code. The only safe rule is: Or, in other words, only use is to test for the documented singletons (like None) or that are only created in one place in the code (like the _sentinel = object() idiom).", "abstract": ""}, {"id": 57641343, "score": 5, "vote": 0, "content": "What\u2019s New In Python 3.8: Changes in Python behavior: The compiler now produces a SyntaxWarning when identity checks (is and\n  is not) are used with certain types of literals (e.g. strings, ints).\n  These can often work by accident in CPython, but are not guaranteed by\n  the language spec. The warning advises users to use equality tests (==\n  and !=) instead.", "abstract": ""}, {"id": 28864111, "score": 158, "vote": 0, "content": "In summary - let me emphasize: Do not use is to compare integers. This isn't behavior you should have any expectations about. Instead, use == and != to compare for equality and inequality, respectively. For example: To know this, you need to know the following. First, what does is do? It is a comparison operator. From the documentation: The operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. x is not y yields the\n  inverse truth value. And so the following are equivalent.  From the documentation: id\n  Return the \u201cidentity\u201d of an object. This is an integer (or long\n  integer) which is guaranteed to be unique and constant for this object\n  during its lifetime. Two objects with non-overlapping lifetimes may\n  have the same id() value. Note that the fact that the id of an object in CPython (the reference implementation of Python) is the location in memory is an implementation detail. Other implementations of Python (such as Jython or IronPython) could easily have a different implementation for id. So what is the use-case for is?  PEP8 describes: Comparisons to singletons like None should always be done with is or\n  is not, never the equality operators. You ask, and state, the following question (with code): Why does the following behave unexpectedly in Python? It is not an expected result. Why is it expected? It only means that the integers valued at 256 referenced by both a and b are the same instance of integer. Integers are immutable in Python, thus they cannot change. This should have no impact on any code. It should not be expected. It is merely an implementation detail.  But perhaps we should be glad that there is not a new separate instance in memory every time we state a value equals 256.  Looks like we now have two separate instances of integers with the value of 257 in memory. Since integers are immutable, this wastes memory. Let's hope we're not wasting a lot of it. We're probably not. But this behavior is not guaranteed. Well, this looks like your particular implementation of Python is trying to be smart and not creating redundantly valued integers in memory unless it has to. You seem to indicate you are using the referent implementation of Python, which is CPython. Good for CPython.  It might be even better if CPython could do this globally, if it could do so cheaply (as there would a cost in the lookup), perhaps another implementation might.  But as for impact on code, you should not care if an integer is a particular instance of an integer. You should only care what the value of that instance is, and you would use the normal comparison operators for that, i.e. ==. is checks that the id of two objects are the same. In CPython, the id is the location in memory, but it could be some other uniquely identifying number in another implementation. To restate this with code: is the same as This can be a very fast check relative to say, checking if two very long strings are equal in value. But since it applies to the uniqueness of the object, we thus have limited use-cases for it. In fact, we mostly want to use it to check for None, which is a singleton (a sole instance existing in one place in memory). We might create other singletons if there is potential to conflate them, which we might check with is, but these are relatively rare. Here's an example (will work in Python 2 and 3) e.g. Which prints: And so we see, with is and a sentinel, we are able to differentiate between when bar is called with no arguments and when it is called with None. These are the primary use-cases for is - do not use it to test for equality of integers, strings, tuples, or other things like these.", "abstract": ""}, {"id": 306603, "score": 39, "vote": 0, "content": "As you can check in source file intobject.c, Python caches small integers for efficiency. Every time you create a reference to a small integer, you are referring the cached small integer, not a new object. 257 is not an small integer, so it is calculated as a different object. It is better to use == for that purpose.", "abstract": ""}, {"id": 306377, "score": 63, "vote": 0, "content": "It depends on whether you're looking to see if 2 things are equal, or the same object.  is checks to see if they are the same object, not just equal. The small ints are probably pointing to the same memory location for space efficiency  You should use == to compare equality of arbitrary objects. You can specify the behavior with the __eq__, and __ne__ attributes.", "abstract": ""}, {"id": 306347, "score": 22, "vote": 0, "content": "I think your hypotheses is correct. Experiment with id (identity of object): It appears that numbers <= 255 are treated as literals and anything above is treated differently!", "abstract": ""}, {"id": 15522094, "score": 9, "vote": 0, "content": "is is the identity equality operator (functioning like id(a) == id(b)); it's just that two equal numbers aren't necessarily the same object. For performance reasons some small integers happen to be memoized so they will tend to be the same (this can be done since they are immutable). PHP's === operator, on the other hand, is described as checking equality and type: x == y and type(x) == type(y) as per Paulo Freitas' comment. This will suffice for common numbers, but differ from is for classes that define __eq__ in an absurd manner: PHP apparently allows the same thing for \"built-in\" classes (which I take to mean implemented at C level, not in PHP). A slightly less absurd use might be a timer object, which has a different value every time it's used as a number. Quite why you'd want to emulate Visual Basic's Now instead of showing that it is an evaluation with time.time() I don't know. Greg Hewgill (OP) made one clarifying comment \"My goal is to compare object identity, rather than equality of value. Except for numbers, where I want to treat object identity the same as equality of value.\" This would have yet another answer, as we have to categorize things as numbers or not, to select whether we compare with == or is. CPython defines the number protocol, including PyNumber_Check, but this is not accessible from Python itself. We could try to use isinstance with all the number types we know of, but this would inevitably be incomplete. The types module contains a StringTypes list but no NumberTypes. Since Python 2.6, the built in number classes have a base class numbers.Number, but it has the same problem: By the way, NumPy will produce separate instances of low numbers. I don't actually know an answer to this variant of the question. I suppose one could theoretically use ctypes to call PyNumber_Check, but even that function has been debated, and it's certainly not portable. We'll just have to be less particular about what we test for now. In the end, this issue stems from Python not originally having a type tree with predicates like Scheme's number?, or Haskell's type class Num. is checks object identity, not value equality. PHP has a colorful history as well, where === apparently behaves as is only on objects in PHP5, but not PHP4. Such are the growing pains of moving across languages (including versions of one).", "abstract": ""}, {"id": 33130014, "score": 5, "vote": 0, "content": "It also happens with strings: Now everything seems fine. That's expected too. Now that's unexpected.", "abstract": ""}, {"id": 307594, "score": 15, "vote": 0, "content": "For immutable value objects, like ints, strings or datetimes, object identity is not especially useful. It's better to think about equality. Identity is essentially an implementation detail for value objects - since they're immutable, there's no effective difference between having multiple refs to the same object or multiple objects.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is", "keywords": [], "tags": ["python", "reference", "equality", "semantics"], "question": {"id": 132988, "title": "Is there a difference between &quot;==&quot; and &quot;is&quot;?", "content": "My Google-fu has failed me. In Python, are the following two tests for equality equivalent? Does this hold true for objects where you would be comparing instances (a list say)? Okay, so this kind of answers my question: So == tests value where is tests to see if they are the same object?", "abstract": ""}, "answers": [{"id": 133024, "score": 1135, "vote": 0, "content": "is will return True if two variables point to the same object (in memory), == if the objects referred to by the variables are equal. In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work: The same holds true for string literals: Please see this question as well.", "abstract": ""}, {"id": 48566846, "score": 5, "vote": 0, "content": "As the other people in this post answer the question in details the difference between == and is for comparing Objects or variables, I would emphasize mainly the comparison between is and == for strings which can give different results and I would urge programmers to carefully use them. For string comparison, make sure to use == instead of is: Out: But in the below example == and is will get different results: Out: Conclusion and Analysis: Use is carefully to compare between strings.\nSince is for comparing objects and since in Python 3+ every variable such as string interpret as an object, let's see what happened in above paragraphs. In python there is id function that shows a unique constant of an object during its lifetime. This id is using in back-end of Python interpreter to compare two objects using is keyword. But", "abstract": ""}, {"id": 133017, "score": 48, "vote": 0, "content": "== determines if the values are equal, while is determines if they are the exact same object.", "abstract": ""}, {"id": 48120163, "score": 61, "vote": 0, "content": "Yes, they have a very important difference. ==: check for equality - the semantics are that equivalent objects (that aren't necessarily the same object) will test as equal. As the documentation says: The operators <, >, ==, >=, <=, and != compare the values of two objects. is: check for identity - the semantics are that the object (as held in memory) is the object. Again, the documentation says: The operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. Object identity is\n  determined using the id() function. x is not y yields the inverse\n  truth value. Thus, the check for identity is the same as checking for the equality of the IDs of the objects. That is, is the same as: where id is the builtin function that returns an integer that \"is guaranteed to be unique among simultaneously existing objects\" (see help(id)) and where a and b are any arbitrary objects. You should use these comparisons for their semantics. Use is to check identity and == to check equality. So in general, we use is to check for identity. This is usually useful when we are checking for an object that should only exist once in memory, referred to as a \"singleton\" in the documentation. Use cases for is include: Usual use cases for == include: The general use case, again, for ==, is the object you want may not be the same object, instead it may be an equivalent one PEP 8, the official Python style guide for the standard library also mentions two use-cases for is: Comparisons to singletons like None should always be done with is or\n  is not, never the equality operators. Also, beware of writing if x when you really mean if x is not None --\n  e.g. when testing whether a variable or argument that defaults to None\n  was set to some other value. The other value might have a type (such\n  as a container) that could be false in a boolean context! If is is true, equality can usually be inferred - logically, if an object is itself, then it should test as equivalent to itself.  In most cases this logic is true, but it relies on the implementation of the __eq__ special method. As the docs say,  The default behavior for equality comparison (== and !=) is based on\n  the identity of the objects. Hence, equality comparison of instances\n  with the same identity results in equality, and equality comparison of\n  instances with different identities results in inequality. A\n  motivation for this default behavior is the desire that all objects\n  should be reflexive (i.e. x is y implies x == y). and in the interests of consistency, recommends: Equality comparison should be reflexive. In other words, identical\n  objects should compare equal: x is y implies x == y We can see that this is the default behavior for custom objects: The contrapositive is also usually true - if somethings test as not equal, you can usually infer that they are not the same object.  Since tests for equality can be customized, this inference does not always hold true for all types. A notable exception is nan - it always tests as not equal to itself: Checking for identity can be much a much quicker check than checking for equality (which might require recursively checking members).  But it cannot be substituted for equality where you may find more than one object as equivalent. Note that comparing equality of lists and tuples will assume that identity of objects are equal (because this is a fast check). This can create contradictions if the logic is inconsistent - as it is for nan: The question is attempting to use is to compare integers. You shouldn't assume that an instance of an integer is the same instance as one obtained by another reference. This story explains why. A commenter had code that relied on the fact that small integers (-5 to 256 inclusive) are singletons in Python, instead of checking for equality. Wow, this can lead to some insidious bugs. I had some code that checked if a is b, which worked as I wanted because a and b are typically small numbers. The bug only happened today, after six months in production, because a and b were finally large enough to not be cached. \u2013 gwg It worked in development. It may have passed some unittests.  And it worked in production - until the code checked for an integer larger than 256, at which point it failed in production.  This is a production failure that could have been caught in code review or possibly with a style-checker. Let me emphasize: do not use is to compare integers.", "abstract": ""}, {"id": 51584206, "score": 5, "vote": 0, "content": "In a nutshell, is checks whether two references point to the same object or not.== checks whether two objects have the same value or not.", "abstract": ""}, {"id": 134631, "score": 21, "vote": 0, "content": "They are completely different.  is checks for object identity, while == checks for equality (a notion that depends on the two operands' types). It is only a lucky coincidence that \"is\" seems to work correctly with small integers (e.g. 5 == 4+1).  That is because CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons. This behavior is totally implementation-dependent and not guaranteed to be preserved under all manner of minor transformative operations. For example, Python 3.5 also makes short strings singletons, but slicing them disrupts this behavior:", "abstract": ""}, {"id": 49146910, "score": 3, "vote": 0, "content": "Most of them already answered to the point. Just as an additional note (based on my understanding and experimenting but not from a documented source), the statement  == if the objects referred to by the variables are equal from above answers should be read as  == if the objects referred to by the variables are equal and objects belonging to the same type/class . I arrived at this conclusion based on the below test: Here the contents of the list and tuple are same but the type/class are different. ", "abstract": ""}, {"id": 48350377, "score": 26, "vote": 0, "content": "== and is are different comparison! As others already said: In Python names refer to objects, for example in this case value1 and value2 refer to an int instance storing the value 1000:  Because value2 refers to the same object is and == will give True: In the following example the names value1 and value2 refer to different int instances, even if both store the same integer:  Because the same value (integer) is stored == will be True, that's why it's often called \"value comparison\". However is will return False because these are different objects: Generally is is a much faster comparison. That's why CPython caches (or maybe reuses would be the better term) certain objects like small integers, some strings, etc. But this should be treated as implementation detail that could (even if unlikely) change at any point without warning. You should only use is if you: want to check if two objects are really the same object (not just the same \"value\"). One example can be if you use a singleton object as constant. want to compare a value to a Python constant. The constants in Python are: In every other case you should use == to check for equality. There is some aspect to == that hasn't been mentioned already in the other answers: It's part of Pythons \"Data model\". That means its behavior can be customized using the __eq__ method. For example: This is just an artificial example to illustrate that the method is really called: Note that by default (if no other implementation of __eq__ can be found in the class or the superclasses) __eq__ uses is: So it's actually important to implement __eq__ if you want \"more\" than just reference-comparison for custom classes! On the other hand you cannot customize is checks. It will always compare just if you have the same reference. Because __eq__ can be re-implemented or overridden, it's not limited to return True or False. It could return anything (but in most cases it should return a boolean!). For example with NumPy arrays the == will return an array: But is checks will always return True or False! 1 As Aaron Hall mentioned in the comments: Generally you shouldn't do any is True or is False checks because one normally uses these \"checks\" in a context that implicitly converts the condition to a boolean (for example in an if statement). So doing the is True comparison and the implicit boolean cast is doing more work than just doing the boolean cast - and you limit yourself to booleans (which isn't considered pythonic). Like PEP8 mentions: Don't compare boolean values to True or False using ==.", "abstract": ""}, {"id": 1085652, "score": 5, "vote": 0, "content": "Have a look at Stack Overflow question Python's \u201cis\u201d operator behaves unexpectedly with integers. What it mostly boils down to is that \"is\" checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).", "abstract": ""}, {"id": 133022, "score": 12, "vote": 0, "content": "https://docs.python.org/library/stdtypes.html#comparisons is tests for identity\n== tests for equality Each (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec though", "abstract": ""}, {"id": 133035, "score": 7, "vote": 0, "content": "Your answer is correct. The is operator compares the identity of two objects.  The == operator compares the values of two objects. An object's identity never changes once it has been created; you may think of it as the object's address in memory. You can control comparison behaviour of object values by defining a __cmp__ method or a rich comparison method like __eq__.", "abstract": ""}, {"id": 1085656, "score": 397, "vote": 0, "content": "There is a simple rule of thumb to tell you when to use == or is. In general, when you are comparing something to a simple type, you are usually checking for value equality, so you should use ==. For example, the intention of your example is probably to check whether x has a value equal to 2 (==), not whether x is literally referring to the same object as 2. Something else to note: because of the way the CPython reference implementation works, you'll get unexpected and inconsistent results if you mistakenly use is to compare for reference equality on integers: That's pretty much what we expected: a and b have the same value, but are distinct entities. But what about this? This is inconsistent with the earlier result. What's going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here's an example demonstrating this: This is another obvious reason not to use is: the behavior is left up to implementations when you're erroneously using it for value equality.", "abstract": ""}, {"id": 1086066, "score": 3, "vote": 0, "content": "As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I'd just like to categorise what you would do the rest of the time: There is one and only one instance of NoneType i.e. None is a singleton. Consequently foo == None and foo is None mean the same. However the is test is faster and the Pythonic convention is to use foo is None. If you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for foo is bar. True and False are also (now) singletons, but there is no use-case for foo == True and no use case for foo is True. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66993528/in-to-test-for-identity", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 66993528, "title": "IN to test for identity", "content": "Is there a builtin way to do the following in python to test not for equality but for identity: Is there a way to do this with map or something a bit more compact? Along the lines of: With a list comprehension I could do something like:", "abstract": ""}, "answers": [{"id": 66993605, "score": 2, "vote": 0, "content": "You can compare the ids: According to the is operator's documentation: The operators is and is not test for an object\u2019s identity:\nx is y is true if and only if x and y are the same object. An\nObject\u2019s identity is determined using the id() function. emphasis mine Small caveat: Two objects with non-overlapping lifetimes may have the same id()\nvalue. So for example:", "abstract": ""}, {"id": 66993674, "score": 2, "vote": 0, "content": "For a general purpose utility, you can use operator.is_ to make a partial function: You can do the same with just a lambda of course: And of course, any map can be expressed as a generator:", "abstract": ""}, {"id": 66993577, "score": 1, "vote": 0, "content": "You can use any():", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/57335770/why-does-is-operator-behave-differently-then-expected-in-idi-is-idj", "keywords": [], "tags": ["python"], "question": {"id": 57335770, "title": "Why does &quot;is&quot; operator behave differently then expected, in `id(i) is id(j)`?", "content": "I know that the operators is and is not test for object identity: x is y is true if and only if x and y are the same object I initialize two variables i and j with the same value 10, and when I am comparing the id of both variable with is operator it gives me a False\n  even though the id(i) and id(j) are the same. I need a clarification, Here is my code", "abstract": ""}, "answers": [{"id": 57335795, "score": 1, "vote": 0, "content": "The is check is True if and only if the id()s are equal--if they are the same object in memory. (The id() builtin gets a unique integer identifier for the object, which is based on its memory address in CPython). It is improper to use an is check on integers to compare their values. CPython does re-use integer objects in a small range instead of making new ones as an optimization, but this is an implementation detail that you should not rely upon. For integer objects outside of that range, they may be separate objects in memory, even if they are equal in value. For example,", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52268343/id-vs-is-operator-is-it-safe-to-compare-ids-does-the-same-id-mean-the", "keywords": [], "tags": ["python", "identity", "identity-operator"], "question": {"id": 52268343, "title": "id() vs `is` operator. Is it safe to compare `id`s? Does the same `id` mean the same object?", "content": "How much can I rely on the object's id() and its uniqueness in practice? E.g.: (Written as a proposed canonical in response to Canonicals for Python: are objects with the same id() the same object, `is` operator, unbound method objects)", "abstract": ""}, "answers": [{"id": 52268344, "score": 10, "vote": 0, "content": "According to the id() documentation, an id is only guaranteed to be unique As such, comparing ids is not safe unless you also somehow ensure that both objects whose ids are taken are still alive at the time of comparison (and are associated with the same Python interpreter instance, but you need to really try to make that become false). Which is exactly what is does -- which makes comparing ids redundant. If you cannot use the is syntax for whatever reason, there's always operator.is_. Now, whether an object is still alive at the time of comparison is not always obvious (and sometimes is grossly non-obvious): Accessing some attributes (e.g. bound methods of an object) creates a new object each time. So, the result's id may or may not be the same on each attribute access. Example: If an object is created as a result of calculating an expression and not saved anywhere, it's immediately discarded,1 and any object created after that can take up its id. This is even true within the same code line. E.g. the result of id(create_foo()) == id(create_bar()) is undefined. Example: Due to the above safety requirements when comparing ids, saving an id instead of the object is not very useful because you have to save a reference to the object itself anyway -- to ensure that it stays alive. Neither is there any performance gain: is implementation is as simple as comparing pointers. Finally, as an internal optimization (and implementation detail, so this may differ between implementations and releases), CPython reuses some often-used simple objects of immutable types. As of this writing, that includes small integers and some strings. So even if you got them from different places, their ids might coincide. This does not (technically) violate the above id() documentation's uniqueness promises: the reused object stays alive through all the reuses. This is also not a big deal because whether two variables point to the same object or not is only practical to know if the object is mutable: if two variables point to the same mutable object, mutating one will (unexpectedly) change the other, too. Immutable types don't have that problem, so for them, it doesn't matter if two variables point to two identical objects or to the same one. 1Sometimes, this is called \"unnamed expression\".", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/50881693/uncommon-behaviour-of-is-operator-in-python", "keywords": [], "tags": ["python"], "question": {"id": 50881693, "title": "Uncommon behaviour of IS operator in python", "content": "From some of the answers on Stackoverflow, I came to know that from -5 to 256 same memory location is referenced thus we get true for: Now comes the twist (see this line before marking duplicate): This is completely understood, but now if I do: Why?", "abstract": ""}, "answers": [{"id": 50882535, "score": 8, "vote": 0, "content": "What you're seeing is an optimization in the compiler in CPython (which compiles your source code into the bytecode that the interpreter runs). Whenever the same immutable constant value is used in several different places within the a chunk of code that is being compiled in one step, the compiler will try to use a reference to same object for each place. So if you do multiple assignments on the same line in an interactive session, you'll get two references to the same object, but you won't if you use two separate lines: Another place this optimization comes up is in the body of a function. The whole function body will be compiled together, so any constants used anywhere in the function can be combined, even if they're on separate lines: While it's interesting to investigate optimizations like this one, you should never rely upon this behavior in your normal code. Different Python interpreters, and even different versions of CPython may do these optimizations differently or not at all. If your code depends on a specific optimization, it may be completely broken for somebody else who tries to run it on their own system. As an example, the two assignments on the same line I show in my first code block above doesn't result in two references to the same object when I do it in the interactive shell inside Spyder (my preferred IDE). I have no idea why that specific situation doesn't work the same way it does in a conventional interactive shell, but the different behavior is my fault, since my code relies upon implementation-specific behavior.", "abstract": ""}, {"id": 50881808, "score": 2, "vote": 0, "content": "After discussion and testing in various versions, the final conclusions can be drawn. Python will interpret and compile instructions in blocks. Depending on the syntax used, Python version, Operating System, distribution, different results may be achieved depending on what instructions Python takes in one block. The general rules are: (from official documentation) The current implementation keeps an array of integer objects for all\n  integers between -5 and 256 Therefore: The part below returns False in Python 3.6.3 |Anaconda custom (64-bit)| (default, Oct 17 2017, 23:26:12) [MSC v.1900 64 bit (AMD64)] But As it is evident, whatever Python takes in \"one block\" is non deterministic and can be swayed depending on how it is written, single line or not, as well as the version, operating system and distribution used.", "abstract": ""}, {"id": 50881926, "score": 2, "vote": 0, "content": "From python2 docs: The operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. x is not y yields the\n  inverse truth value. [6] From python3 docs: The operators is and is not test for object identity: x is y is true\n  if and only if x and y are the same object. Object identity is\n  determined using the id() function. x is not y yields the inverse\n  truth value. [4] So basically the key to understand those tests you've run on the repl console is by using\naccordingly the id() function, here's an example that will show you what's going on behind the curtains: That said, usually a good way to understand what's going on behind the curtains with these type of snippets is by using either dis.dis or dis.disco, let's take a look for instance what this snippet would look like: the output would be: As we can see in this case the asm output doesn't tell us very much, we can see than lines 3-4 are basically the \"same\" instructions than line 5. So my recommendation would be once again to use id() smartly so you'll know what's is will compare. In case you want to know exactly the type of optimizations cpython is doing I'm afraid you'd need to dig out in its source code", "abstract": ""}, {"id": 50881888, "score": 2, "vote": 0, "content": "Generally speaking, numbers outside the range -5 to 256 will not necessarily have the optimization applied to numbers within that range. However, Python is free to apply other optimizations as appropriate. In your cause, you're seeing that the same literal value used multiple times on one line is stored in a single memory location no matter how many times it's used on that line. Here are some other examples of this behavior:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/49268124/does-the-in-operator-use-or-is-for-comparisons", "keywords": [], "tags": ["python", "python-2.7", "containment"], "question": {"id": 49268124, "title": "Does the &#39;in&#39; operator use &quot;==&quot; or &quot;is&quot; for comparisons?", "content": "In a Python expression like str in [str1, str2, str3] or 1 in [1, 2, 3], does the in operator use == or is to compare the first object with the objects in the list?", "abstract": ""}, "answers": [{"id": 49268184, "score": 11, "vote": 0, "content": "It depends on the object how in is executed; it is not the in operator that makes the comparison, it is the object.__contains__ method that does the work. For the Python standard container types (list, tuple, set, dict, etc.) both identity and equality are used. See the Membership test operations section of the Expressions reference documentation: For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression x in y is equivalent to any(x is e or x == e for e in y). is is faster to test for, and objects having the same identity implies they are also equal. Custom types are free to implement whatever test they want to do in their __contains__ method. Next, if no __contains__ method is defined, but there is a __iter__ method or a __getitem__ method, then an iterative search is preformed where the values produced are tested for both identity and equality again. See the above linked documentation for details; the documentation is not that explicit about the identity test but the implementation still uses identity because using it is a performance boost. You can see this when you use float('nan'), which is never equal to itself or anything else: float('nan') is an exception to the normal expectation that identity implies equality; see What is the rationale for all comparisons returning false for IEEE754 NaN values? for why that is.", "abstract": ""}, {"id": 49268125, "score": 0, "vote": 0, "content": "It seems to use ==. With the following test: Any links to official documentation about this would be appreciated! My Google-fu has failed me thus far.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11166748/identity-versus-equality-for-none-in-python", "keywords": [], "tags": ["python", "coding-style"], "question": {"id": 11166748, "title": "identity versus equality for None in Python", "content": "Various Python guides say to use x is None instead of x == None. Why is that? Equality is used for comparing values, so it seems natural to ask if x has the value None, denoted with == and not is. Can someone explain why is is the preferred form and show an example where the two do not give the same answer?   Thanks.", "abstract": ""}, "answers": [{"id": 11166757, "score": 14, "vote": 0, "content": "The reason people use is is because there is no advantage to using ==.  It is possible to write objects that compare equal to None, but it is uncommon. Output: The is operator is also faster, but I don't consider this fact important. ", "abstract": ""}, {"id": 11173393, "score": 3, "vote": 0, "content": "PEP 8 says:\n\"Comparisons to singletons like None should always be done with 'is' or 'is not', never the equality operators.\" Here is a quite good explanation why: http://jaredgrubb.blogspot.com/2009/04/python-is-none-vs-none.html", "abstract": ""}, {"id": 11167217, "score": 11, "vote": 0, "content": "The is keyword tests identity. It is not a comparison operator like ==. Using is does more than test whether two arguments have the same value and/or the same internal structure: namely, it tests whether the two actually refer to the same object in memory. There are numerous implications to this, one of them being that is cannot be overloaded, and another being that behavior differs between mutable and immutable types. For example, consider the following: Here, because lists are mutable, they cannot share a location in memory, and consequently is and == yield discrepant results. On the other hand, strings are immutable, and therefore their memory may be pooled in some cases. Basically, is can only reliably be used for simple, immutable types, or in instances when multiple names point to exactly the same object in memory (such as the use of l3 in the above example), and its use indicates a desire to test identity rather than value. I would expect is to be slightly faster than == because it doesn't perform method lookup, but I could be mistaken. Of course, for complex container objects like lists or dicts, is should be much faster than == (O(1) vs. O(n), presumably). That said, the speed issue is mostly a moot point, as the two should not be regarded as interchangeable.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/21199809/purpose-of-overloading-identity-operator", "keywords": [], "tags": ["python", "oop", "comparison-operators", "object-identity"], "question": {"id": 21199809, "title": "Purpose of overloading identity operator", "content": "Why isn't it possible in Python to overload the identity comparison operator? Every other comparison operator is possible to customize, so why not identity comparison?", "abstract": ""}, "answers": [{"id": 21240809, "score": 1, "vote": 0, "content": "Programming languages that support objects with mutable state typically provide an operator that can test whether two objects are, in fact, the same object.  \"Same,\" in this case, means that the objects are actually the same object (e.g., the same chunk of bytes in memory (or however the compiler designers choose to represent objects).  For many types of data structures, though, there are other types of equivalence relations that might be more salient for the programmer.  For instance, given a List interface, the programmer might only care about whether two lists contain equivalent elements in the same order.  This only really matters in the case that there is some way in which two Lists with equivalent elements can be distinguished.  Because many programming languages support mutable state, operations that mutate the state of an object are just such a way in which such objects could be distinguished. For instance, given an mutable implementation of lists we might have: In a functional programming language that doesn't have mutable state, or even in a language that does have mutable state, but in which we use functional styles, we wouldn't destructively modify a list like this, but rather the add operation would return a new list (probably sharing structure with the others).  In such a case, it would be possible to have only one list for any sequence of elements, so we could have: The fact that  stays the same throughout can be useful in reasoning about the behavior of programs.   When we're programming in a object-oriented fashion, object identity is an important concept, and is really one of the primitives of the language, just like boolean operators, or numeric comparison.  If it can be overridden, a whole class of optimizations cannot be performed, and you could introduce some pretty hard to track down bugs.  For instance, consider the (perhaps contrived example): If you could override same as, then you might not frob both x and y, because same as could return true even though x and y aren't the same object. In languages where object identity can be important, there needs to be a object identity operator that cannot be overridden. It's also typically useful to introduce an equality operator that can be overridden in some way so that it's easy to check whether two objects are equivalent in some useful way (and this will be specific to the type of object). It's worth noting that in many languages, the equality operator's default implementation is object identity.  This can be nice because object identity is typically much quicker to test than other, more complex, equality relations.", "abstract": ""}, {"id": 21200391, "score": 2, "vote": 0, "content": "You can't override 'is' because it tests whether two objects are the same object by comparing their memory addresses (i.e. pointer comparison).", "abstract": ""}, {"id": 21199821, "score": 1, "vote": 0, "content": "Simply put, because the purpose of the identity operator is to test identity.  Identity means \"what the object really is\".  The whole point of the operator is to be able to test if two objects \"really are\" the same object, not whether they \"want to be\" considered the same according to their own rules.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/19899935/is-there-a-time-when-the-is-operator-can-return-false-with-two-similar-strings", "keywords": [], "tags": ["python", "string", "comparison"], "question": {"id": 19899935, "title": "is there a time when the `is` operator can return false with two similar strings in Python?", "content": "I had some code that I was editing to make it more understandable at a glance and I thought I should change all the char==\"|\" to char is \"|\". I know that it looks like I'm dumbing it down too much but it does look better. Anyway, I decided to pycheck one last time and I got this warning:   For the life of me, I can't imagine a situation when \"|\" is \"|\" will return False unless you start venturing into multibyte character encodings, CJK characters and the like, if I'm not wrong. Is there some other situation that I've missed?", "abstract": ""}, "answers": [{"id": 19900464, "score": 1, "vote": 0, "content": "I am interpreting the question here as \"Where do I actually use 'is' to check things?\". The \"is\" check is typically used when a default named argument to a function is None and you want to see if something was given to the function. None is always None. If they give 0 or [] or '', those things evaluate as a boolean to False. returns And so checking the bool of the variable won't give you the desired behavior if the user of your function wants the function to carry on like it normally would for such an argument. The None acts like a sentinel to check if the function got an argument that was intentionally provided. This check is of particular utility when you assign the variable to a mutable empty container object.  e.g.: So is the same as checking Which, if evaluates as True, they are the same object, because they both point to the same place in memory. As others have pointed out, don't use is to check for equality because implementation may vary, and semantically, you don't care if it is the same object, you care whether or not the two items are equivalent.", "abstract": ""}, {"id": 19899966, "score": 13, "vote": 0, "content": "== will check if values on both the sides are equal, but is will check if both the variables are pointing to the same reference. So, they both are for entirely different purposes. For example, Output on my machine since a and b are pointing to the same String data (strings are immutable in Python), python optimizes to use the same object. That is why is and == both are returning True. where as Output on my machine Though a and b have the same data (equal), in the memory they are stored in different places (different references or two different objects). So, never use is operator to check for equality.", "abstract": ""}, {"id": 19900073, "score": 7, "vote": 0, "content": "In CPython, all the single character strings are interned and should always have the same id for the same string(character) This is just an implementation detail and shouldn't be relied on. There are a few places where you might want to check the identity of two strings is the same, but your use case is not one of them", "abstract": ""}]}]