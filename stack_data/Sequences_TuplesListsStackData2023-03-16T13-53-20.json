[{"link": "https://stackoverflow.com/questions/72899/how-do-i-sort-a-list-of-dictionaries-by-a-value-of-the-dictionary", "keywords": [], "tags": ["python", "list", "sorting", "dictionary", "data-structures"], "question": {"id": 72899, "title": "How do I sort a list of dictionaries by a value of the dictionary?", "content": "How do I sort a list of dictionaries by a specific key's value? Given: When sorted by name, it should become:", "abstract": ""}, "answers": [{"id": 75367181, "score": 1, "vote": 0, "content": "You can use the following:", "abstract": ""}, {"id": 45094029, "score": 26, "vote": 0, "content": "Sometime we need to use lower() for case-insensitive sorting. For example,", "abstract": ""}, {"id": 72939809, "score": 0, "vote": 0, "content": "sorting by multiple columns, while in descending order on some of them:\nthe cmps array is global to the cmp function, containing field names and inv == -1 for desc 1 for asc", "abstract": ""}, {"id": 73050, "score": 3493, "vote": 0, "content": "The sorted() function takes a key= parameter Alternatively, you can use operator.itemgetter instead of defining the function yourself For completeness, add reverse=True to sort in descending order", "abstract": ""}, {"id": 69072597, "score": 1, "vote": 0, "content": "As indicated by @Claudiu to @monojohnny in comment section of this answer, given: to sort the list of dictionaries by key 'age', 'name'\n(like in SQL statement ORDER BY age, name), you can use: or, likewise print(newlist) [{'name': 'Bart', 'age': 10},  {'name': 'Milhouse', 'age': 10},\n{'name': 'Homer', 'age': 39}]", "abstract": ""}, {"id": 73044, "score": 110, "vote": 0, "content": "my_list will now be what you want. Or better: Since Python 2.4, there's a key argument is both more efficient and neater: ...the lambda is, IMO, easier to understand than operator.itemgetter, but your mileage may vary.", "abstract": ""}, {"id": 59802559, "score": 10, "vote": 0, "content": "If performance is a concern, I would use operator.itemgetter instead of lambda as built-in functions perform faster than hand-crafted functions. The itemgetter function seems to perform approximately 20% faster than lambda based on my testing. From https://wiki.python.org/moin/PythonSpeed: Likewise, the builtin functions run faster than hand-built equivalents. For example, map(operator.add, v1, v2) is faster than map(lambda x,y: x+y, v1, v2). Here is a comparison of sorting speed using lambda vs itemgetter. Both techniques sort the list in the same order (verified by execution of the final statement in the code block), but the first one is a little faster.", "abstract": ""}, {"id": 58179903, "score": 11, "vote": 0, "content": "I have been a big fan of a filter with lambda. However, it is not best option if you consider time complexity. 1000000 loops, best of 3: 0.736 \u00b5sec per loop 1000000 loops, best of 3: 0.438 \u00b5sec per loop", "abstract": ""}, {"id": 23102554, "score": 12, "vote": 0, "content": "Let's say I have a dictionary D with the elements below. To sort, just use the key argument in sorted to pass a custom function as below: Check this out.", "abstract": ""}, {"id": 28094888, "score": 16, "vote": 0, "content": "Here is the alternative general solution - it sorts elements of a dict by keys and values. The advantage of it - no need to specify keys, and it would still work if some keys are missing in some of dictionaries.", "abstract": ""}, {"id": 16772049, "score": 26, "vote": 0, "content": "Using the Schwartzian transform from Perl, do gives More on the Perl Schwartzian transform: In computer science, the Schwartzian transform is a Perl programming\nidiom used to improve the efficiency of sorting a list of items. This\nidiom is appropriate for comparison-based sorting when the ordering is\nactually based on the ordering of a certain property (the key) of the\nelements, where computing that property is an intensive operation that\nshould be performed a minimal number of times. The Schwartzian\nTransform is notable in that it does not use named temporary arrays.", "abstract": ""}, {"id": 2858683, "score": 73, "vote": 0, "content": "If you want to sort the list by multiple keys, you can do the following: It is rather hackish, since it relies on converting the values into a single string representation for comparison, but it works as expected for numbers including negative ones (although you will need to format your string appropriately with zero paddings if you are using numbers).", "abstract": ""}, {"id": 39281050, "score": 19, "vote": 0, "content": "Using the Pandas package is another method, though its runtime at large scale is much slower than the more traditional methods proposed by others: Here are some benchmark values for a tiny list and a large (100k+) list of dicts:", "abstract": ""}, {"id": 47892332, "score": 13, "vote": 0, "content": "If you do not need the original list of dictionaries, you could modify it in-place with sort() method using a custom key function. Key function: The list to be sorted: Sorting it in-place: If you need the original list, call the sorted() function passing it the list and the key function, then assign the returned sorted list to a new variable: Printing data_one and new_data.", "abstract": ""}, {"id": 42855105, "score": 49, "vote": 0, "content": "", "abstract": ""}, {"id": 73465, "score": 232, "vote": 0, "content": "To sort the list of dictionaries by key='name': To sort the list of dictionaries by key='age':", "abstract": ""}, {"id": 73186, "score": 28, "vote": 0, "content": "You could use a custom comparison function, or you could pass in a function that calculates a custom sort key. That's usually more efficient as the key is only calculated once per item, while the comparison function would be called many more times. You could do it this way: But the standard library contains a generic routine for getting items of arbitrary objects: itemgetter. So try this instead:", "abstract": ""}, {"id": 73098, "score": 42, "vote": 0, "content": "'key' is used to sort by an arbitrary value and 'itemgetter' sets that value to each item's 'name' attribute.", "abstract": ""}, {"id": 73019, "score": 31, "vote": 0, "content": "I guess you've meant: This would be sorted like this:", "abstract": ""}, {"id": 72950, "score": 23, "vote": 0, "content": "You have to implement your own comparison function that will compare the dictionaries by values of name keys. See Sorting Mini-HOW TO from PythonInfo Wiki", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/75177279/what-is-the-rationale-for-using-x-sort-reverse-true-and-not-x-sort-reverse", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 75177279, "title": "what is the rationale for using X.sort.(reverse=True) and not X.sort.reverse()", "content": "I have a list called X that I want to sort alphabetically in descending order\nand i want to know the rationale of \"reverse = True\" I would have written the following: But I see that it doesn't work and I want to know what it means to assign true to reverse", "abstract": ""}, "answers": [{"id": 75187834, "score": 0, "vote": 0, "content": "Python has a rule on methods. Either: Mutating methods never return the original object largely as a stylistic choice by Guido van Rossum (the original creator of Python); if a mutated object is returned, he wanted there to be no confusion over whether it was the original object (mutated in-place) or new mutated copy. Doing many different things on a single line was also something he wanted to discourage; without reverse=True, the cleaner way to write it would be: as two lines each doing one unique thing. That general rule is the case for all objects, not just list, but list.sort/list.reverse explicitly document this rationale: To remind users that [list.sort] operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). For the specific case of list.sort, using reverse=True provides a couple benefits: Admittedly, the Python standard sorting algorithm (Timsort) (in place by the time reverse=True was added), optimizes for runs of data sorted in either direction (forward or reverse), so repeated sort-then-reverse would still perform well, but even so, it's costly and pointless to rearrange all the elements of the input only to swap them back again at the end. Sure, in a hypothetical design Python could have made bound list.sort methods a more complex object with methods of its own that tweaked the behavior, making X.sort.reverse() exactly equal to X.sort(reverse=True) (both would sort in reverse order directly without sorting in forward order, then reversing), but no other built-in type in Python does anything like that (bound methods can be called, and that's it, they don't provide extensible objects that can be tweaked). For that matter, I'm not aware of many other languages that allow anything similar (I wouldn't put it past some pure-functional languages, but Python is not pure-functional). Supporting this would complicate a lot of stuff (e.g. you can't just have a common interface for methods, you have to custom-design the descriptors and the objects they return to make new objects with methods of their own; that's a lot of work relative to the existing CPython design that basically just requires a C function definition, plus a one-liner macro mapping the string \"sort\" to that function for the purposes of method lookup, with the process of creating bound methods handled by a single uniform code path for every C-implemented method) and would introduce questions about consistency (should you also allow X.reverse.sort() to mean the same thing as X.sort.reverse()? If not, why not?), violate expectations from tons of other methods which use keyword arguments to make slight tweaks in behavior, and not provide any meaningful benefit. In a language without keyword arguments, sure, this might be useful (mylist.sort(True) or mylist.sort(False, lambda x: x[0]) for forward order with a key would be ugly), but with keyword arguments, X.sort(reverse=True) is not meaningfully worse than X.sort.reverse(), and unlike the latter, it doesn't create confusion between bound methods and full-fledged objects with methods of their own. As an historical note, prior to the introduction of TimSort in 2.3, Python used an unstable samplesort algorithm (with no optimizations for partially ordered data), and only supported a cmp argument (a function that accepted two values and returned a negative, 0, or positive number to indicate if the first argument was less than, equal to, or greater than the second). It was only when 2.4 introduced the key argument (to allow Python to do the far more efficient decorate-sort-undecorate, aka Schwartzian Transform under the hood for you) that the reverse argument was added alongside. When cmp was the only way to customize the comparison, you'd just write it to tweak the sort order yourself as needed, but with key functions, where you compute/extract new objects (typically simple built-ins like int, str, or tuples thereof), you could only say what to compare on, not how to compare that data; it's fairly common to want to sort on the key in reverse order, and if that had required writing a cmp function as well, just to flip the sort order, it would have eliminated most of the benefits of key functions (specifically, that they are called before sorting exactly once per input, where cmp functions must be called, on average, log n times per element). The newly stable sort also meant that, in the event you needed some comparisons to operate in reverse, and some in forward order (and you couldn't just invert values; int can be negated, but str cannot be), you could call sort repeatedly, from least important criteria to most, and the subsequent sorts will preserve the original order of elements that compare equal for that stage (and therefore the ordering imposed by the prior sorts). It's not great when you need to do this, but it's better than also having to add explicit reverse calls on top of all the multiple sort calls.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44749903/how-do-i-implement-a-schwartzian-transform-in-python", "keywords": [], "tags": ["python", "sorting"], "question": {"id": 44749903, "title": "How do I implement a Schwartzian Transform in Python?", "content": "In Perl I sometimes use the Schwartzian Transform to efficiently sort complex arrays: How to implement this transform in Python?", "abstract": ""}, "answers": [{"id": 74964521, "score": 0, "vote": 0, "content": "While there should normally be no reason not to use the key argument for the sorted function or list.sort method, you can of course do without it, by creating a list of pairs (called tmp below) where the first item is the sort key and the second item is the original item. Due to lexicographical sorting, sorting this list will sort by the key first. Then you can take the items in the desired order from the sorted tmp list of pairs. Note that usually this would be written with list comprehensions instead of calling .append in a loop, but the purpose of this answer is to illustrate the underlying algorithm in a way most likely to be understood by beginners.", "abstract": ""}, {"id": 44749939, "score": 5, "vote": 0, "content": "You don't need to.  Python has this feature built in, and in fact Python 3 removed C-style custom comparisons because this is so much better in the vast majority of cases. To sort by word length: Or, because len is already an unary function: This also works with the built-in sorted function. If you want to sort on multiple criteria, you can take advantage of the fact that tuples sort lexicographically:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6913512/how-to-sort-an-array-of-objects-by-multiple-fields", "keywords": [], "tags": ["javascript", "arrays", "sorting"], "question": {"id": 6913512, "title": "How to sort an array of objects by multiple fields?", "content": "From this original question, how would I apply a sort on multiple fields? Using this slightly adapted structure, how would I sort city (ascending) & then price (descending)? I liked the fact than an answer was given which provided a general approach.  Where I plan to use this code, I will have to sort dates as well as other things.  The ability to \"prime\" the object seemed handy, if not a little cumbersome. I've tried to build this answer into a nice generic example, but I'm not having much luck.", "abstract": ""}, "answers": [{"id": 74563527, "score": 2, "vote": 0, "content": "To make things simple, use these helper functions. You can sort by as many fields as you need. For each sort field, specify the property name, and then, optionally, specify -1 as the sort direction to sort descending instead of ascending. \n\nconst data = [\n  {\"h_id\":\"3\",\"city\":\"Dallas\",\"state\":\"TX\",\"zip\":\"75201\",\"price\":\"162500\"},\n  {\"h_id\":\"4\",\"city\":\"Bevery Hills\",\"state\":\"CA\",\"zip\":\"90210\",\"price\":\"319250\"},\n  {\"h_id\":\"6\",\"city\":\"Dallas\",\"state\":\"TX\",\"zip\":\"75000\",\"price\":\"556699\"},\n  {\"h_id\":\"5\",\"city\":\"New York\",\"state\":\"NY\",\"zip\":\"00010\",\"price\":\"962500\"},\n  {\"h_id\":\"7\",\"city\":\"New York\",\"state\":\"NY\",\"zip\":\"00010\",\"price\":\"800500\"}\n]\n\nconst sortLexically   = (p,d=1)=>(a,b)=>d * a[p].localeCompare(b[p])\nconst sortNumerically = (p,d=1)=>(a,b)=>d * (a[p]-b[p])\nconst sortBy          = sorts=>(a,b)=>sorts.reduce((r,s)=>r||s(a,b),0)\n\n// sort first by city, then by price descending\ndata.sort(sortBy([sortLexically('city'), sortNumerically('price', -1)]))\n\nconsole.log(data)\n\n\n", "abstract": ""}, {"id": 73237693, "score": 1, "vote": 0, "content": "Here, you can try the smaller and convenient way to sort by multiple fields! \n\nvar homes = [\n    { \"h_id\": \"3\", \"city\": \"Dallas\", \"state\": \"TX\", \"zip\": \"75201\", \"price\": \"162500\" },\n    { \"h_id\": \"4\", \"city\": \"Bevery Hills\", \"state\": \"CA\", \"zip\": \"90210\", \"price\": \"319250\" },\n    { \"h_id\": \"6\", \"city\": \"Dallas\", \"state\": \"TX\", \"zip\": \"75000\", \"price\": \"556699\" },\n    { \"h_id\": \"5\", \"city\": \"New York\", \"state\": \"NY\", \"zip\": \"00010\", \"price\": \"962500\" }\n];\n\nhomes.sort((a, b)=> {\n  if (a.city === b.city){\n    return a.price < b.price ? -1 : 1\n  } else {\n    return a.city < b.city ? -1 : 1\n  }\n})\n\nconsole.log(homes);\n\n\n", "abstract": ""}, {"id": 72649463, "score": 1, "vote": 0, "content": "A very intuitive functional solution can be crafted by adding 3 relatively simple helpers. Before we dive in, let's start with the usage: \n\nfunction usage(homes, { asc, desc, fallback }) {\n  homes.sort(fallback(\n    asc(home => home.city),\n    desc(home => parseInt(home.price, 10)),\n  ));\n  console.log(homes);\n}\n\nvar homes = [{\n  h_id:  \"3\",\n  city:  \"Dallas\",\n  state: \"TX\",\n  zip:   \"75201\",\n  price: \"162500\",\n}, {\n  h_id:  \"4\",\n  city:  \"Bevery Hills\",\n  state: \"CA\",\n  zip:   \"90210\",\n  price: \"319250\",\n}, {\n  h_id:  \"6\",\n  city:  \"Dallas\",\n  state: \"TX\",\n  zip:   \"75000\",\n  price: \"556699\",\n}, {\n  h_id:  \"5\",\n  city:  \"New York\",\n  state: \"NY\",\n  zip:   \"00010\",\n  price: \"962500\",\n}];\n\nconst SortHelpers = (function () {\n  const asc  = (fn) => (a, b) => (a = fn(a), b = fn(b), -(a < b) || +(a > b));\n  const desc = (fn) => (a, b) => asc(fn)(b, a);\n  const fallback = (...fns) => (a, b) => fns.reduce((diff, fn) => diff || fn(a, b), 0);\n  return { asc, desc, fallback };\n})();\n\nusage(homes, SortHelpers);\n\n\n If you scrolled down the snippet you probably already saw the helpers: Let me quickly explain what each of these functions does. asc creates a comparator function. The provided function fn is called for both the comparator arguments a and b. The results of the two function calls are then compared. -1 is returned if resultA < resultB, 1 is returned if resultA > resultB, or 0 otherwise. These return values correspond with an ascending order direction. It could also be written like this: desc is super simple, since it just calls asc but swaps the a and b arguments, resulting in descending order instead of ascending. fallback (there might be a better name for this) allows us to use multiple comparator functions with a single sort. Both asc and desc can be passed to sort by themself. There is however an issue if you want to combine multiple comparator functions. sort only accepts a single comparator function. fallback combines multiple comparator functions into a single comparator. The first comparator is called with arguments a and b, if the comparator returns the value 0 (meaning that the values are equal) then we fall back to the next comparator. This continues until a non-0 value is found, or until all comparators are called, in which case the return value is 0. You can provide your custom comparator functions to fallback() as well. Say you want to use localeCompare() instead of comparing strings with < and >. In such a case you can replace asc(home => home.city) with (a, b) => a.city.localeCompare(b.city). One thing to note is that values that can be undefined will always return false when comparing with < and >. So if a value can be missing you might want to sort by its presence first. Since comparing strings with localeCompare() is such a common thing to do, you could include this as part of asc().", "abstract": ""}, {"id": 70638681, "score": 2, "vote": 0, "content": "Adding a couple helper functions lets you solved this kind of problem generically and simply. sortByKey takes an array and a function which should return a list of items with which to compare each array entry. This takes advantage of the fact that javascript does smart comparison of arrays of simple values, with [2] < [2, 0] < [2, 1] < [10, 0]. \n\n// Two helpers:\nfunction cmp(a, b) {\n    if (a > b) {\n        return 1\n    } else if (a < b) {\n        return -1\n    } else {\n        return 0\n    }\n}\n\nfunction sortByKey(arr, key) {\n    arr.sort((a, b) => cmp(key(a), key(b)))\n}\n\n// A demonstration:\nlet arr = [{a:1, b:2}, {b:3, a:0}, {a:1, b:1}, {a:2, b:2}, {a:2, b:1}, {a:1, b:10}]\nsortByKey(arr, item => [item.a, item.b])\n\nconsole.log(JSON.stringify(arr))\n// '[{\"b\":3,\"a\":0},{\"a\":1,\"b\":1},{\"a\":1,\"b\":10},{\"a\":1,\"b\":2},{\"a\":2,\"b\":1},{\"a\":2,\"b\":2}]'\n\nsortByKey(arr, item => [item.b, item.a])\nconsole.log(JSON.stringify(arr))\n// '[{\"a\":1,\"b\":1},{\"a\":2,\"b\":1},{\"a\":1,\"b\":10},{\"a\":1,\"b\":2},{\"a\":2,\"b\":2},{\"b\":3,\"a\":0}]'\n\n\n I've lovingly stolen this idea from Python's list.sort function.", "abstract": ""}, {"id": 20554416, "score": 313, "vote": 0, "content": "for a non-generic, simple solution to your exact problem:", "abstract": ""}, {"id": 71545078, "score": 6, "vote": 0, "content": "why complicate? just sort it twice! this works perfectly:\n(just make sure to reverse the importance order from least to most):", "abstract": ""}, {"id": 70505610, "score": 1, "vote": 0, "content": "You can use lodash orderBy function  lodash It takes two params array of fields, and array of directions ('asc','desc')", "abstract": ""}, {"id": 30446887, "score": 88, "vote": 0, "content": "Here is a simple functional generic approach. Specify sort order using array. Prepend minus to specify descending order. Edit: in ES6 it's even shorter! \n\n\"use strict\";\nconst fieldSorter = (fields) => (a, b) => fields.map(o => {\n    let dir = 1;\n    if (o[0] === '-') { dir = -1; o=o.substring(1); }\n    return a[o] > b[o] ? dir : a[o] < b[o] ? -(dir) : 0;\n}).reduce((p, n) => p ? p : n, 0);\n\nconst homes = [{\"h_id\":\"3\", \"city\":\"Dallas\", \"state\":\"TX\",\"zip\":\"75201\",\"price\":162500},     {\"h_id\":\"4\",\"city\":\"Bevery Hills\", \"state\":\"CA\", \"zip\":\"90210\", \"price\":319250},{\"h_id\":\"6\", \"city\":\"Dallas\", \"state\":\"TX\", \"zip\":\"75000\", \"price\":556699},{\"h_id\":\"5\", \"city\":\"New York\", \"state\":\"NY\", \"zip\":\"00010\", \"price\":962500}];\nconst sortedHomes = homes.sort(fieldSorter(['state', '-price']));\n\ndocument.write('<pre>' + JSON.stringify(sortedHomes, null, '\\t') + '</pre>')\n\n\n", "abstract": ""}, {"id": 69425906, "score": 2, "vote": 0, "content": "simply follow the list of your sorting criteria this code will always remain readable and understandable even if you have 36 sorting criteria to encase The solution proposed here by Nina is certainly very elegant, but it implies knowing that a value of zero corresponds to a value of false in Boolean logic, and that Boolean tests can return something other than true / false in JavaScript (here are numeric values) which will always be confusing for a beginner. Also think about who will need to maintain your code. Maybe it would be you: imagine yourself spending your days raking for days the code of another and having a pernicious bug ... and you are exhausted from reading these thousands of lines full of tips \n\nconst homes = \n  [ { h_id: '3', city: 'Dallas',       state: 'TX', zip: '75201', price: '162500' } \n  , { h_id: '4', city: 'Bevery Hills', state: 'CA', zip: '90210', price: '319250' } \n  , { h_id: '6', city: 'Dallas',       state: 'TX', zip: '75000', price: '556699' } \n  , { h_id: '5', city: 'New York',     state: 'NY', zip: '00010', price: '962500' } \n  ]\n  \nconst fSort = (a,b) =>\n  {\n  let Dx = a.city.localeCompare(b.city)              // 1st criteria\n  if (Dx===0) Dx = Number(b.price) - Number(a.price) // 2nd\n\n  // if (Dx===0) Dx = ... // 3rd\n  // if (Dx===0) Dx = ... // 4th....\n  return Dx\n  }\n\nconsole.log( homes.sort(fSort))\n\n\n", "abstract": ""}, {"id": 69316780, "score": 1, "vote": 0, "content": "", "abstract": ""}, {"id": 55620991, "score": 11, "vote": 0, "content": "A dynamic way to do that with MULTIPLE keys:  Use: ", "abstract": ""}, {"id": 48958358, "score": 20, "vote": 0, "content": "Here's an extensible way to sort by multiple fields. Notes", "abstract": ""}, {"id": 63968639, "score": -6, "vote": 0, "content": "Simplest Way to sort array of object by multiple fields: Output:\n\"Bevery Hills\"\n\"Dallas\"\n\"Dallas\"\n\"Dallas\"\n\"New York\"", "abstract": ""}, {"id": 46256174, "score": 366, "vote": 0, "content": "You could use a chained sorting approach by taking the delta of values until it reaches a value not equal to zero. \n\nvar data = [{ h_id: \"3\", city: \"Dallas\", state: \"TX\", zip: \"75201\", price: \"162500\" }, { h_id: \"4\", city: \"Bevery Hills\", state: \"CA\", zip: \"90210\", price: \"319250\" }, { h_id: \"6\", city: \"Dallas\", state: \"TX\", zip: \"75000\", price: \"556699\" }, { h_id: \"5\", city: \"New York\", state: \"NY\", zip: \"00010\", price: \"962500\" }];\r\n\r\ndata.sort(function (a, b) {\r\n    return a.city.localeCompare(b.city) || b.price - a.price;\r\n});\r\n\r\nconsole.log(data);\n.as-console-wrapper { max-height: 100% !important; top: 0; }\n\n\n Or, using es6, simply:", "abstract": ""}, {"id": 56841633, "score": 0, "vote": 0, "content": "This is a recursive algorithm to sort by multiple fields while having the chance to format values before comparison. If a and b are equal it will just try the next field until none is available.", "abstract": ""}, {"id": 56194061, "score": 3, "vote": 0, "content": "Just another option. Consider to use the following utility function: Example of usage (in your case): It should be noted that this function can be even more generalized in order to be able to use nested properties like 'address.city' or 'style.size.width' etc.", "abstract": ""}, {"id": 56192318, "score": 8, "vote": 0, "content": "Here's a generic multidimensional sort, allowing for reversing and/or mapping on each level. Written in Typescript. For Javascript, check out this JSFiddle Sorting a people array by last name, then first name: Sort language codes by their name, not their language code (see map), then by descending version (see reverse).", "abstract": ""}, {"id": 55990011, "score": 0, "vote": 0, "content": "I was looking for something similar and ended up with this: First we have one or more sorting functions, always returning either 0, 1 or -1: You can create more functions for each other property you want to sort on. Then I have a function that combines these sorting functions into one: This can be used to combine the above sorting functions in a readable way: When a sorting function returns 0 the next sorting function will be called for further sorting.", "abstract": ""}, {"id": 55058380, "score": 0, "vote": 0, "content": "Here is mine for your reference, with example:", "abstract": ""}, {"id": 54835118, "score": 0, "vote": 0, "content": "I think this may be the easiest way to do it. https://coderwall.com/p/ebqhca/javascript-sort-by-two-fields It's really simple and I tried it with 3 different key value pairs and it worked great. Here is a simple example, look at the link for more details", "abstract": ""}, {"id": 48696437, "score": -1, "vote": 0, "content": "How about this simple solution:\n Based on this question javascript sort array by multiple (number) fields", "abstract": ""}, {"id": 48637997, "score": 0, "vote": 0, "content": "Wow, there are some complex solutions here. So complex I decided to come up with something simpler but also quite powerful. Here it is; And here is an example of how you use it. This will first sort by the precedence of the attributes, then by the value of the attributes.", "abstract": ""}, {"id": 47536415, "score": 0, "vote": 0, "content": "Adaptation of @chriskelly 's answer.  Most answers overlook that price will not sort properly if the value is in the ten thousands and lower or over a million. The resaon being JS sorts alphabetically. It was answered pretty well here, Why can't JavaScript sort \"5, 10, 1\" and here How to sort an array of integers correctly. Ultimately we have to do some evaluation if the field or node we're sorting by is an number. I am not saying that using parseInt() in this case is the correct answer, the sorted results are more important. \n\nvar homes = [{\r\n  \"h_id\": \"2\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75201\",\r\n  \"price\": \"62500\"\r\n}, {\r\n  \"h_id\": \"1\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75201\",\r\n  \"price\": \"62510\"\r\n}, {\r\n  \"h_id\": \"3\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75201\",\r\n  \"price\": \"162500\"\r\n}, {\r\n  \"h_id\": \"4\",\r\n  \"city\": \"Bevery Hills\",\r\n  \"state\": \"CA\",\r\n  \"zip\": \"90210\",\r\n  \"price\": \"319250\"\r\n}, {\r\n  \"h_id\": \"6\",\r\n  \"city\": \"Dallas\",\r\n  \"state\": \"TX\",\r\n  \"zip\": \"75000\",\r\n  \"price\": \"556699\"\r\n}, {\r\n  \"h_id\": \"5\",\r\n  \"city\": \"New York\",\r\n  \"state\": \"NY\",\r\n  \"zip\": \"00010\",\r\n  \"price\": \"962500\"\r\n}];\r\n\r\nhomes.sort(fieldSorter(['price']));\r\n// homes.sort(fieldSorter(['zip', '-state', 'price'])); // alternative\r\n\r\nfunction fieldSorter(fields) {\r\n  return function(a, b) {\r\n    return fields\r\n      .map(function(o) {\r\n        var dir = 1;\r\n        if (o[0] === '-') {\r\n          dir = -1;\r\n          o = o.substring(1);\r\n        }\r\n        if (!parseInt(a[o]) && !parseInt(b[o])) {\r\n          if (a[o] > b[o]) return dir;\r\n          if (a[o] < b[o]) return -(dir);\r\n          return 0;\r\n        } else {\r\n          return dir > 0 ? a[o] - b[o] : b[o] - a[o];\r\n        }\r\n      })\r\n      .reduce(function firstNonZeroValue(p, n) {\r\n        return p ? p : n;\r\n      }, 0);\r\n  };\r\n}\r\ndocument.getElementById(\"output\").innerHTML = '<pre>' + JSON.stringify(homes, null, '\\t') + '</pre>';\n<div id=\"output\">\r\n\r\n</div>\n\n\n A fiddle to test with", "abstract": ""}, {"id": 42611624, "score": 2, "vote": 0, "content": "Another way \n\nvar homes = [\r\n    {\"h_id\":\"3\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75201\",\r\n     \"price\":\"162500\"},\r\n    {\"h_id\":\"4\",\r\n     \"city\":\"Bevery Hills\",\r\n     \"state\":\"CA\",\r\n     \"zip\":\"90210\",\r\n     \"price\":\"319250\"},\r\n    {\"h_id\":\"6\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75000\",\r\n     \"price\":\"556699\"},\r\n    {\"h_id\":\"5\",\r\n     \"city\":\"New York\",\r\n     \"state\":\"NY\",\r\n     \"zip\":\"00010\",\r\n     \"price\":\"962500\"}\r\n    ];\r\nfunction sortBy(ar) {\r\n  return ar.sort((a, b) => a.city === b.city ?\r\n      b.price.toString().localeCompare(a.price) :\r\n      a.city.toString().localeCompare(b.city));\r\n}\r\nconsole.log(sortBy(homes));\n\n\n", "abstract": ""}, {"id": 42767569, "score": 1, "vote": 0, "content": "Using : \n\nvar homes = [\r\n    {\"h_id\":\"3\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75201\",\r\n     \"price\":\"162500\"},\r\n    {\"h_id\":\"4\",\r\n     \"city\":\"Bevery Hills\",\r\n     \"state\":\"CA\",\r\n     \"zip\":\"90210\",\r\n     \"price\":\"319250\"},\r\n    {\"h_id\":\"6\",\r\n     \"city\":\"Dallas\",\r\n     \"state\":\"TX\",\r\n     \"zip\":\"75000\",\r\n     \"price\":\"556699\"},\r\n    {\"h_id\":\"5\",\r\n     \"city\":\"New York\",\r\n     \"state\":\"NY\",\r\n     \"zip\":\"00010\",\r\n     \"price\":\"962500\"}\r\n    ];\r\nfunction sort(data, orderBy) {\r\n            orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];\r\n            return data.sort((a, b) => {\r\n                for (let i = 0, size = orderBy.length; i < size; i++) {\r\n                    const key = Object.keys(orderBy[i])[0],\r\n                        o = orderBy[i][key],\r\n                        valueA = a[key],\r\n                        valueB = b[key];\r\n                    if (!(valueA || valueB)) {\r\n                        console.error(\"the objects from the data passed does not have the key '\" + key + \"' passed on sort!\");\r\n                        return [];\r\n                    }\r\n                    if (+valueA === +valueA) {\r\n                        return o.toLowerCase() === 'desc' ? valueB - valueA : valueA - valueB;\r\n                    } else {\r\n                        if (valueA.localeCompare(valueB) > 0) {\r\n                            return o.toLowerCase() === 'desc' ? -1 : 1;\r\n                        } else if (valueA.localeCompare(valueB) < 0) {\r\n                            return o.toLowerCase() === 'desc' ? 1 : -1;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\nconsole.log(sort(homes, [{city : 'asc'}, {price: 'desc'}]));\n\n\n", "abstract": ""}, {"id": 32494726, "score": 3, "vote": 0, "content": "Here's my solution based on the Schwartzian transform idiom, hope you find it useful. Here's an example how to use it:", "abstract": ""}, {"id": 39729626, "score": 19, "vote": 0, "content": "This is a complete cheat but I think that it adds value to this question because it's basically a canned library function that you can use out-of-the box. If your code has access to lodash or a lodash compatible library like underscore then you can use the _.sortBy method. The snippet below is copied directly from the lodash documentation. The commented results in the examples looks like they return arrays of arrays but that's just showing the order and not the actual results which are an array of objects.", "abstract": ""}, {"id": 39657468, "score": 4, "vote": 0, "content": "I like SnowBurnt's approach but it needs a tweak to test for equivalence on city NOT a difference.", "abstract": ""}, {"id": 39306691, "score": 0, "vote": 0, "content": "How to use (put -(minus) sign before field if you want to sort in descending order particular field) Using above function you can sort any json array with multiple fields. No need to change function body at all", "abstract": ""}, {"id": 38037580, "score": 7, "vote": 0, "content": "Simpler one:", "abstract": ""}, {"id": 37949707, "score": -1, "vote": 0, "content": "Sorting on two date fields and a numeric field example: http://jsfiddle.net/hcWgf/57/", "abstract": ""}, {"id": 17265125, "score": 15, "vote": 0, "content": "The following function will allow you to sort an array of objects on one or multiple properties, either ascending (default) or descending on each property, and allow you to choose whether or not to perform case sensitive comparisons.  By default, this function performs case insensitive sorts. The first argument must be the array containing the objects.\nThe subsequent argument(s) must be a comma separated list of strings that reference the different object properties to sort by.  The last argument (which is optional) is a boolean to choose whether or not to perform case sensitive sorts - use true for case sensitive sorts. The function will sort each property/key in ascending order by default.  If you want a particular key to sort in descending order, then instead pass in an array in this format: ['property_name', true]. Here are some sample uses of the function followed by an explanation (where homes is an array containing the objects): objSort(homes, 'city') --> sort by city (ascending, case in-sensitive) objSort(homes, ['city', true]) --> sort by city (descending, case in-sensitive) objSort(homes, 'city', true) --> sort by city then price (ascending, case sensitive) objSort(homes, 'city', 'price') --> sort by city then price (both ascending, case in-sensitive) objSort(homes, 'city', ['price', true]) --> sort by city (ascending) then price (descending), case in-sensitive) And without further ado, here's the function: And here's some sample data:", "abstract": ""}, {"id": 30910572, "score": -1, "vote": 0, "content": "Here 'AffiliateDueDate' and 'Title' are columns, both are sorted in ascending order.", "abstract": ""}, {"id": 26000529, "score": 1, "vote": 0, "content": "Here is a generic version of @Snowburnt's solution: This is based on a sort routine I'm using.  I didn't test this specific code so it may have errors but you get the idea.  The idea is to sort based on the first field that indicates a difference and then stop and go to the next record.  So, if you're sorting by three fields and the first field in the compare is enough to determine the sort order of the two records being sorted then return that sort result and go to the next record.   I tested it (actually with a little more complex sort logic) on 5000 records and it did it in the blink of an eye.  If you're actually loading more than 1000 records to the client you should probably be using sever-side sorting and filtering. This code isn't handling case-sensitivity but I leave it to the reader to handle this trivial modification.", "abstract": ""}, {"id": 25561344, "score": -2, "vote": 0, "content": "", "abstract": ""}, {"id": 18045239, "score": 34, "vote": 0, "content": "I made a quite generic multi feature sorter today. You can have a look at thenBy.js here: https://github.com/Teun/thenBy.js It allows you to use the standard Array.sort, but with firstBy().thenBy().thenBy() style. It is way less code and complexity than the solutions posted above.", "abstract": ""}, {"id": 6913821, "score": 90, "vote": 0, "content": "A multi dimensional sorting method, based on this answer: Update: Here is an \"optimized\" version. It does a lot more preprocessing and creates a comparison function for each sorting option beforehand. It might need more more memory (as it stores a function for each sorting option, but it should preform a bit better as it does not have to determine the correct settings during the comparison. I have not done any profiling though. Example usage: DEMO Original function: DEMO", "abstract": ""}, {"id": 6914113, "score": 7, "vote": 0, "content": "Here's another one that's perhaps closer to your idea for the syntax Demo: http://jsfiddle.net/Nq4dk/2/ Edit: Just for fun, here's a variation that just takes an sql-like string, so you can do sortObjects(homes, \"city, price desc\")", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61683696/how-to-sort-hierarchical-data-represented-in-a-flat-list", "keywords": [], "tags": ["python", "sorting", "data-structures"], "question": {"id": 61683696, "title": "How to sort hierarchical data represented in a flat list?", "content": "I have a Python (version 2.7) list of objects that has an implied hierarchy. If one or more SubThings immediately follow a Thing, they belong with that Thing. I want to sort the Things by their value and when Things are moved for the sorting, I want their SubThings to move with them. All of these objects have values. Example input: I have working code for this in Python 2.7 but it's brute-force and feels inelegant - about 40 lines of code. First I create an intermediate data structure that groups Things with their SubThings, then I sort by Things' values, then I flatten the resulting structure. I have a feeling there is an elegant one or two (or three?)-liner for this. It even sounds like a classic opportunity for a Schwartzian Transform but I'm not making the \"Pythonic\" leap that easily groups SubThings with Things - maybe something with itertools.groupby()? For clarity: SubThings never occur without a parent Thing. Things may not have SubThings. I've simplified by leaving out the reality that the series of Things/SubThings can be preceded and followed by unrelated objects. It'd be awesome to see a solution that passes those through unsorted, i.e. in the position they were, but that's not as intellectually challenging to me.", "abstract": ""}, "answers": [{"id": 61685758, "score": 1, "vote": 0, "content": "You could use accumulate to propagate the original index of the parent \"Thing\" to all elements in its group.  Then tie the value of the parents to each group and then use a normal sort on these tuples to keep Subthings tied to their original parent while sorting both parents betwen each other and children under their parent.   Note that you will also need to keep track of which item is a parent so that parents keep appearing first within their group: This is all iterators and generators. There is no intermediate data structure (except internally during the sort).  The whole thing could be written on a single (monstrous) line but I tried to keep it understandable. As you suspected this is indeed a Schwartzian Transform so you can play with the tuple used in keys (decorate step) to get different sorting schemes. For example, if you only want to sort between the \"Thing\" groups but not the \"SubThing\" items within each group, replace (things[p],p,p<i,things[i]) with (things[p],p,i,things[i]) in the keys generator. If you only want to sort the \"SubThing\" items within each group without moving groups around, change it to (p,p<i,things[i]) [EDIT]  I just noticed that you are using Python 2.7 which I believe doesn't have the accumulate function in itertools.  If that is the case, you could write your own: I never used Python 2.7 so there may be some other differences that I am not aware of", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46860219/how-do-i-make-a-merge-sort-built-for-a-single-list-sort-a-list-of-list-inste", "keywords": [], "tags": ["python"], "question": {"id": 46860219, "title": "How do I make a merge sort, built for a single list, sort a &quot;list of list&quot; instead?", "content": "So, let say I have a list of lists like this: If I wanted to sort this by the middle number in each sublist, it would end up like this: How can I cause a merge sort that is built to sort a list like this: [1, 2, 3, 4] To sort a list of list and specify it to merge based on the middle number of each sublist? Is there a trick with python that will allow this to work? Only thing I have been able to find about this is using the built-in sorting function, which I do not want to do. Below is the merge sort I am implementing. It works like this  mergeSort(list_here) And it merges the list. However, I would like to use a trick to make python merge based on a list of the list instead with the middle index of each sublist being what is being compared. Thanks for any guidance. Below is the merge sort:", "abstract": ""}, "answers": [{"id": 46860549, "score": 1, "vote": 0, "content": "Here's a version of your code that can accept a key function, like the built-in sort and related functions do. I use max to create the \"sentinel\" value. This is rather inefficient, since max has to scan the whole list to find its maximum. Also, the built-in sort only calls the key function once for each item in the list it's sorting, whereas this code has to call it twice every time it makes a comparison. output As you can see, it works, but it would be better to change your merging algorithm to eliminate the sentinels so we don't need max.  We can also make it more efficient by performing a Schwartzian transform on the data so that the key function only needs to be called once per item, but that does make the code a little more complicated, and of course it also requires more RAM to hold the transformed data.", "abstract": ""}, {"id": 46860389, "score": 0, "vote": 0, "content": "If did understand you right, the following code is what you want: where l is your input list.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/42899405/sort-a-list-with-longest-items-first", "keywords": [], "tags": ["python", "python-3.x", "sorting", "lambda"], "question": {"id": 42899405, "title": "Sort a list with longest items first", "content": "I am using a lambda to modify the behaviour of sort. Sorting a list containing the elements A1,A2,A3,A,B1,B2,B3,B, the result is A,A1,A2,A3,B,B1,B2,B3. My expected sorted list would be A1,A2,A3,A,B1,B2,B3,B. I've already tried to include the len(item) for sorting, which didn't work. How to modify the lambda so that the sort result is instead? ", "abstract": ""}, "answers": [{"id": 42902140, "score": 0, "vote": 0, "content": "I love Tries, so just for fun, I wrote a Trie-based solution : This should work for any string of any length. Note that the result is just printed to screen, not written back in a new list. You didn't write much code, so I'll leave it as an exercise ;)", "abstract": ""}, {"id": 42900060, "score": 7, "vote": 0, "content": "Here is one way to do it: Traditionally, lexicographic sort order longer strings after their otherwise identical prefixes (i.e.  'abc' goes before 'abcd'). To meet your sort expectation, we first \"fix-up\" the shorter string by adding the remaining part of the longer string plus another character to make it the longer of the two: The functools.cmp_to_key() tool then converts the comparison function to a key function. This may seem like a lot of work, but the sort expectations are very much at odds with the built-in lexicographic sorting rules. FWIW, here's another way of writing it, that might or might not be considered clearer: The logic is:", "abstract": ""}, {"id": 42899432, "score": 1, "vote": 0, "content": "My first answer was: just negate the len criterion to reverse only on that criterion. But that doesn't work, because there's a conflict between alpha sort and length. Alpha sort puts small strings first. So length criterion doesn't work. You need to merge both criteria. There's no clear priority between each other. I found a way: first compute the max length of your strings, then return the chr(127) filled (the biggest char provided you're using only ASCII) version of the string as key so smallest strings are filled with big chars in the end: they always come last. result: BTW don't call your list list for obvious reasons.", "abstract": ""}, {"id": 42899718, "score": 0, "vote": 0, "content": "One could construct the key by taking: For example:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/15126863/advice-on-chosing-data-structure-for-complicated-sort", "keywords": [], "tags": ["algorithm", "perl", "sorting"], "question": {"id": 15126863, "title": "Advice on chosing data structure for complicated sort", "content": "I'm looking for some help writing some Perl code to sort a log file.  I'm a relative newbie to coding and perl in general! I need to write my code with just the core perl modules as much as possible, though if that proves impossible I'm open to CPAN modules. The log file contains a list logged of messages, that need to be re-arranged in order. Should be simple enough, but there are lots of gotchas, which is causing me trouble on how to design my data structures. The input file format is CSV and the output needs to be the same with the messages in timestamp order and concatenated messages grouped together with the first message part first. Gotchas It's probably best if I just put some example input data and then how it needs to come out. Input Data Output Data The things I have done so far is Now I'm stuck coming up with the best way to filter and sort the data efficiently. I've tried playing around with hashes and loading the file first into memory so I can sort on a particular message reference, but I'm not sure that will work with a large file. I then thought about reading it in line by line, but I could hit an issue where the second line contains the first part of a concatenated SMS, and we might not get the subsequent parts until the very end of the file, so I'm thinking maybe that also isn't a good idea. I also thought of a database, but I think it will be too complicated to setup on the system this needs to run. Another option is perhaps writing a package and storing the complex structure as an object? Perhaps I'm over complicating things? My brain is certainly going mushy! Anyway, any ideas or guidance would be much appreciated. Hopefully the above is clear, but please ask me if you have any questions. Thanks,\nWill", "abstract": ""}, "answers": [{"id": 15137402, "score": 2, "vote": 0, "content": "I don't think this problem us too complicated if decomposed correctly. As I see it, your sorting program will contain of the following stages: The Schwartzian is a common pattern when sorting in Perl. It speeds up sorts where the sorting index has to be extracted from the data that is to be actually sorted, by extracting this data once, and not at every comparision. It can also be described as decorate-sort-undecorate. An example: Sorting strings by length. Note that the naive implementation would actually be better in this case. It would be good to keep this pattern in mind for your task You already managed that. For each line, we output an array reference or similar with the following fields: For the CSV extraction, you should use Text::CSV, to calculate the epoch, you should look into DateTime We define a cache in forms of a hash that has message references as key, and a group as value. A group is an arrayref as the extracted format specified above, but may contain further lines in positions 5 and onward (i.e. each tagged line is a group). For each tagged line that is received, we do the following procedure: After no new lines are present, we pass each remaining value in the hash on to the next stage. The important thing to realize is that you don't have to keep all lines in memory here, but only incomplete groups. Interesting Perl functions are exists $hash{element} and delete $hash{element}. The delete may be important to save memory. We simply sort each element by timestamp. If the total data is too much for the system to handle, we can use a trick: However, this is time-expensive. Here, we only receive the sorted and grouped items. All we have to do is to output the contained lines in their correct order.", "abstract": ""}, {"id": 15127030, "score": 0, "vote": 0, "content": "I would do this in two phases: combining the message parts, and sorting. That should simplify the problem somewhat. To start, I would use an external sorting utility (the GNU sort tool, for example) to sort by message number. That will at least group all of the parts that have the same message number together. A simple sort <inputfile >outputfile will do what you need. All you're really interested in is getting all parts that start with, for example, 371,\"... next to each other. You can then write a Perl program to read the output and accumulate lines that have the same message number. When you see a different message number, filter the lines you've accumulated to assemble a message from the different parts. And write that record out to a file. You might want to write the output in a form that's more easily sorted. Perhaps by outputting the fields you're sorting on at the front of the record, zero-padded if necessary to simplify sorting. When that's complete, you have a file that contains one record per line and, if you constructed the records correctly, you can just do another sort <inputfile >outputfile to get the data in the order that you want. That also simplifies your programming quite a bit: you don't have to worry about writing a custom sort for the data. Instead, you write a relatively simple Perl program to transform the data so that's more easily sorted by the existing tools.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/5760733/perl-in-place-sort-lines-in-a-text-file", "keywords": [], "tags": ["python", "perl"], "question": {"id": 5760733, "title": "perl in-place sort lines in a text file", "content": "I wish to modify a text file by sorting each line based on a given key and save the old file as a backup.  The key is a numeric character contained in each line.   Is there a simple script to get this done, preferably in-place? Thanks!", "abstract": ""}, "answers": [{"id": 5761683, "score": 1, "vote": 0, "content": "Say your sort key is the run of digits at the beginning of each line, as in the following example. To sort one or more files named on the command line, you can use the code below. @ARGV contains the arguments from the command line. Running the program with no arguments produces a usage guide on the standard error. $^I holds the extension added to filenames when creating backups for in-place editing, which you can also enable with Perl's -i switch, covered in the perlrun documentation. -i[extension]\n  specifies that files processed by the <> construct are to be edited in-place. It does this by renaming the input file, opening the output file by the original name, and selecting that output file as the default for print statements. $/ is the input record separator. Setting it to the undefined value means you want subsequent calls to the readline operator to read through end-of-file. Performance will suffer with very large inputs. On each iteration of the while loop, the special variable $_ will hold the contents of the current file as a whole. To sort the lines, we first break them apart. Don't be intimidated by the print inside the loop. It's the Schwartzian Transform, a common technique in Perl even though it debuted to less-than-rave reviews. To understand what's happening, read it from the end to the beginning. In a more procedural style, you'd write the loop as Once you understand what's happening with the Schwartzian Transform, all the temporaries seem like undue clutter.", "abstract": ""}, {"id": 5761489, "score": 1, "vote": 0, "content": "There are in-place sorting algorithms with O(n log n) complexity such as Heapsort, but I don't see why you would want to use that rather than something simple such as the Unix sort command. Unless you have stringent performance requirements or huge datasets... but then, perl and python probably aren't the best tools for the job.", "abstract": ""}, {"id": 5761477, "score": 0, "vote": 0, "content": "There isn't a simple script to do this because what you're suggesting is actually fairly complex and inefficient. Unless your lines are all the exact same length in the file, it's almost impossible (or, incredibly silly).  If you absolutely can't do it in memory and want to write the code yourself, your best approach is probably a disk based merge sort. The example for how you would do it with tape drives should give you some guidance. ", "abstract": ""}]}]