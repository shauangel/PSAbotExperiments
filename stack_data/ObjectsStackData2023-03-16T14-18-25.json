[{"link": "https://stackoverflow.com/questions/72666230/wrapping-derived-class-method-from-base-class", "keywords": [], "tags": ["python", "oop", "metaclass", "python-class", "python-datamodel"], "question": {"id": 72666230, "title": "Wrapping derived class method from base class", "content": "Imagine I have a base and a derived class like so: I wish to wrap calls foo calls made by instances of B. Modifying any part of B is not allowed (I don\u2019t own B). What I have as of now: This works as expected, however I am concerned about this being inefficient memory-wise. o.foo is a <bound method A.__init__.<locals>.capture.<locals>.wrapper of <__main__.B object at 0x10523ffd0>>. It would seem that I would have to pay the cost of 2 closures for each instance I create. Is there a better way to do this? Perhaps a metaclass based approach?", "abstract": ""}, "answers": [{"id": 75367389, "score": 0, "vote": 0, "content": "Following @jsbueno answer Using types.MethodType(attr, self) is better than using since partial doesn't have a descriptor so the returned attribute is not bound to the class instance. just need to fix the return wrapper to", "abstract": ""}, {"id": 72666537, "score": 2, "vote": 0, "content": "Unless you are planning to have several thousands instances of these live at the same time, the resource usage of doing so should not concern you - it is rather small compared with other resources a running Python app will use. Just for comparison: asyncio coroutines and tasks are the kind of object which one can create thousands of in a process, and it is just \"ok\", will have a similar overhead. But since you have control of the base class for B there are several ways to do it, without resorting to \"monkey patching\" - which would be modifying B in place after it was created. That is often the only alternative when one has to modify a class for which they don't control the code. Wrapping the method either automatically, when it is retrieved from a B instance, in a lazy way, can spare even this - and sure can be more elegant than wrapping at the base class __init__: If you know beforehand the methods you have to wrap, and is sure they are implemented in subclasses of classes which you control, this can be made by crafting a specialized __getattribute__ method: this way, the method is wrapped only when it is about to get used. As for wrapping foo when B is created, that could give use even less resources - and while it could be done in a metaclass, from Python 3.6 on, the __init_subclass__  special method can handle it, with no need for a custom metaclass. However, this approach can be tricky if the code might further subclass B in a class C(B):  which will again override  foo: the wrapper could be called multiple times if the methods use super() calls to foo in the base classes. Avoiding the code in the wrapper to run more than once would require some complicated state handling (but it can be done with no surprises).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/75300287/how-to-add-method-to-base-class", "keywords": [], "tags": ["python", "class", "parent-child"], "question": {"id": 75300287, "title": "How to add method to base class?", "content": "I want to add __add__ and __radd__ to the python base class set. The code can be as simple as What is the pythonic implementation of this and how can I extend the base class without creating my own MySet class that takes set as a parent class? Can I just use set.__add__ = some_function_I_defined?", "abstract": ""}, "answers": [{"id": 75302708, "score": 0, "vote": 0, "content": "@chepner correctly answered my question without realizing it. I was trying to reimplement already existing functionality since I was not familiar with python sets. The act of joining two sets, 'taking their union' is implemented with the python __or__ and __ior__ methods. The operation I needed specifically was | and |=. In principle we should be able to set operations as chepner suggested with set.__add__ = set.__or__, but as chepner points out this results in an error: Thank you all.", "abstract": ""}, {"id": 75300706, "score": 1, "vote": 0, "content": "What you should do imho is subclass the built-in set class.\nIn Python (contrary to e.g. Ruby or JavaScript) monkey-patching a built-in is not allowed. So e.g. trying to add a non-existent method: is not going to work, you'd get AttributeError: 'list' object has no attribute 'my_new_method_added_in_runtime' You cannot also modify the existing methods of objects instantiated using those built-ins: will result in AttributeError: 'list' object attribute 'sort' is read-only And will result in:\nTypeError: can't set attributes of built-in/extension type 'list' All of the above is true for set as well an so on. You could try to look for some libraries to achieve that e.g. https://pypi.org/project/forbiddenfruit/0.1.0/, but it's strongly discouraged.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/805066/how-do-i-call-a-parent-classs-method-from-a-child-class-in-python", "keywords": [], "tags": ["python", "class", "oop", "object", "inheritance"], "question": {"id": 805066, "title": "How do I call a parent class&#39;s method from a child class in Python?", "content": "When creating a simple object hierarchy in Python, I'd like to be able to invoke methods of the parent class from a derived class.  In Perl and Java, there is a keyword for this (super).  In Perl, I might do this: In Python, it appears that I have to name the parent class explicitly from the child.\nIn the example above, I'd have to do something like Foo::frotz().   This doesn't seem right since this behavior makes it hard to make deep hierarchies.  If children need to know what class defined an inherited method, then all sorts of information pain is created.   Is this an actual limitation in python, a gap in my understanding or both?", "abstract": ""}, "answers": [{"id": 70714134, "score": 1, "vote": 0, "content": "If you want to call the method of any class, you can simply call Class.method on any instance of the class. If your inheritance is relatively clean, this will work on instances of a child class too:", "abstract": ""}, {"id": 805081, "score": 978, "vote": 0, "content": "Use the super() function: For Python < 3, you must explicitly opt in to using new-style classes and use:", "abstract": ""}, {"id": 53067078, "score": 4, "vote": 0, "content": "In this example cafec_param is a base class (parent class) and abc is a child class. abc calls the AWC method in the base class. Output", "abstract": ""}, {"id": 55391551, "score": 2, "vote": 0, "content": "", "abstract": ""}, {"id": 38587017, "score": 88, "vote": 0, "content": "Python 3 has a different and simpler syntax for calling parent method. If Foo class inherits from Bar, then from Bar.__init__ can be invoked from Foo via super().__init__():", "abstract": ""}, {"id": 52116743, "score": -1, "vote": 0, "content": "", "abstract": ""}, {"id": 45037536, "score": 74, "vote": 0, "content": "Many answers have explained how to call a method from the parent which has been overridden in the child. However  \"how do you call a parent class's method from child class?\" could also just mean: \"how do you call inherited methods?\"  You can call methods inherited from a parent class just as if they were methods of the child class, as long as they haven't been overwritten. e.g. in python 3: yes, this may be fairly obvious, but I feel that without pointing this out people may leave this thread with the impression you have to jump through ridiculous hoops just to access inherited methods in python. Especially as this question rates highly in searches for \"how to access a parent class's method in Python\", and the OP is written from the perspective of someone new to python. I found:\nhttps://docs.python.org/3/tutorial/classes.html#inheritance\nto be useful in understanding how you access inherited methods.", "abstract": ""}, {"id": 41783372, "score": 3, "vote": 0, "content": "In Python 2, I didn't have a lot luck with super().  I used the answer from \njimifiki on this SO thread how to refer to a parent method in python?.\nThen, I added my own little twist to it, which I think is an improvement in usability (Especially if you have long class names). Define the base class in one module: Then import the class into another modules as parent:", "abstract": ""}, {"id": 805082, "score": 162, "vote": 0, "content": "Python also has super as well:  super(type[, object-or-type]) Return a proxy object that delegates method calls to a parent or sibling class of type.\n  This is useful for accessing inherited methods that have been overridden in a class. \n  The search order is same as that used by getattr() except that the type itself is skipped. Example: ", "abstract": ""}, {"id": 34183634, "score": 9, "vote": 0, "content": "If you don't know how many arguments you might get, and want to pass them all through to the child as well: (From: Python - Cleanest way to override __init__ where an optional kwarg must be used after the super() call?)", "abstract": ""}, {"id": 27402103, "score": 5, "vote": 0, "content": "There is a super() in python also. Example for how a super class method is called from a sub class method This example is similar to the one explained above.However there is one difference that super doesn't have any arguments passed to it.This above code is executable in python 3.4 version. ", "abstract": ""}, {"id": 805091, "score": 90, "vote": 0, "content": "will be just fine, whether the immediate parent class defined frotz itself or inherited it.  super is only needed for proper support of multiple inheritance (and then it only works if every class uses it properly).  In general, AnyClass.whatever is going to look up whatever in AnyClass's ancestors if AnyClass doesn't define/override it, and this holds true for \"child class calling parent's method\" as for any other occurrence!", "abstract": ""}, {"id": 16057968, "score": 31, "vote": 0, "content": "Here is an example of using super():", "abstract": ""}, {"id": 8689564, "score": 9, "vote": 0, "content": "I would recommend using CLASS.__bases__\nsomething like this", "abstract": ""}, {"id": 6407157, "score": -26, "vote": 0, "content": "This is a more abstract method:", "abstract": ""}, {"id": 805085, "score": 14, "vote": 0, "content": "There's a super() in Python too. It's a bit wonky, because of Python's old- and new-style classes, but is quite commonly used e.g. in constructors:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/4747397/calling-base-class-method-in-python", "keywords": [], "tags": ["python", "class"], "question": {"id": 4747397, "title": "Calling base class method in Python", "content": "I have two classes A and B and A is base class of B. I read that all methods in Python are virtual.  So how do I call a method of the base because when I try to call it, the method of the derived class is called as expected?", "abstract": ""}, "answers": [{"id": 70353765, "score": 0, "vote": 0, "content": "Simple answer:", "abstract": ""}, {"id": 4747439, "score": 40, "vote": 0, "content": "Two ways: \n>>> A.print_it(x)\n'A'\n>>> super(B, x).print_it()\n'A'\n", "abstract": ""}, {"id": 4747427, "score": 56, "vote": 0, "content": "Using super:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70110533/type-hint-of-base-class-method-based-on-subclass", "keywords": [], "tags": ["python", "inheritance", "subclass", "type-hinting"], "question": {"id": 70110533, "title": "Type hint of Base class method based on Subclass", "content": "When creating a base class with a request method that will be exactly the same for all subclasses. There does not seem to be an easy way of having separate type-hints based on which subclass made the request. The example below is how I currently am solving this issue, but it seems as if there is a better way. Is there a better way of doing this, either by specifying Response type on the subclass or by just overriding the method signature and no the functionality? Something like (I know this does not work): I would assume that using something like Generic[T] and TypeVar() could be a way to go?", "abstract": ""}, "answers": [{"id": 70110872, "score": 0, "vote": 0, "content": "Perhaps typing.overload is what you seek. Now your FooRequest and BarRequest no longer need to supply their implementation of (or type hints for) make_request. If on the other hand your only goal is to type hint the IDE, you could: This would make the IDE accept but reject", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/67237473/calling-super-method-vs-baseclass-methodself", "keywords": [], "tags": ["python", "python-3.x", "class", "oop", "inheritance"], "question": {"id": 67237473, "title": "Calling super().method() vs. BaseClass.method(self)", "content": "There are two main ways for a derived class to call a base class's methods. Base.method(self): or super().method(): Suppose I now do this: As far as I know, both Base.method(self) and super().method() do the same thing. Both will call Base.method with a reference to obj. In particular, super() doesn't do the legwork to instantiate an object of type Base. Instead, it creates a new object of type super and grafts the instance attributes from obj onto it, then it dynamically looks up the right attribute from Base when you try to get it from the super object. The super() method has the advantage of minimizing the work you need to do when you change the base for a derived class. On the other hand, Base.method uses less magic and may be simpler and clearer when a class inherits from multiple base classes. Most of the discussions I've seen recommend calling super(), but is this an established standard among Python coders? Or are both of these methods widely used in practice? For example, answers to this stackoverflow question go both ways, but generally use the super() method. On the other hand, the Python textbook I am teaching from this semester only shows the Base.method approach.", "abstract": ""}, "answers": [{"id": 67237936, "score": 2, "vote": 0, "content": "Using super() implies the idea that whatever follows should be delegated to the base class, no matter what it is. It's about the semantics of the statement. Referring explicitly to Base on the other hand conveys the idea that Base was chosen explicitly for some reason (perhaps unknown to the reader), which might have its applications too. Apart from that however there is a very practical reason for using super(), namely cooperative multiple inheritance. Suppose you've designed the following class hierarchy: Now you can use both Foo and Bar and everything works as expected. However these two classes won't work together in a multiple inheritance schema: That last call to test skips over Bar's implementation since Foo didn't specify that it wants to delegate to the next class in method resolution order but instead explicitly specified Base. Using super() resolves this issue:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55721635/can-i-call-base-class-method-in-my-setup-function", "keywords": [], "tags": ["python"], "question": {"id": 55721635, "title": "can I call base class method in my setup function", "content": "I am writing python script for the first time\nHere is a basic question Can I call base class method directly in this way in my setUp function?\nAlso if I am inheriting more than one base class , and super.setup() executes which both ? if so which one first ?", "abstract": ""}, "answers": [{"id": 55721921, "score": 0, "vote": 0, "content": "Yes, doing super().setUp() is the right way of calling the parent method class. Now, regarding the multiple inheritance and the method calling. Python will actually call only the method of one class. When you do multiple inheritance, Python will create a 'Multiple-Resolution Order', that is the order in which python check the parent class for the method. Once it found the method in a parent it will  stop looking for the method (this normally happens, because the inheritance hierarchy may be big). In your example, you resolution order would be: You can check it by running TestLolSupv.mro(). If you want to have control of the order the objects are being called, I would suggest using delegation instead. And also, if you are using inheritance to have access to parent class method, delegation would be better. Normally, inheritance is worth when the parent class calls a child class method, because this means you are building an abstraction. Here is some info about multiple inheritance in python.", "abstract": ""}, {"id": 55721900, "score": 1, "vote": 0, "content": "super.setup() will search for setup method in all parent classes, starting from left to right, till it finds it and executes the first found method. for example will print the answer as \"A\". if the parent classes have inherited from other classes, then they will be searched in that order. example now for E the setup in A will be executed, and for F setup in B will be executed.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55695067/how-to-protect-function-from-base-class-in-python", "keywords": [], "tags": ["python", "python-3.x", "overriding", "subclassing"], "question": {"id": 55695067, "title": "How to protect function from base class in Python?", "content": "I am currently learning the Template Method pattern in python. I am wondering if there is any way to protect some of the functions from the base class so that the subclass cannot overwrite? As below, the _primitive_operation_3 from the subclass overwrites the same function from the base class. And if methods from base class cannot be prevented being overwritten, how can I put something in place to give an automatic alert/warning indicating that a particular method from the base class has been overwritten?", "abstract": ""}, "answers": [{"id": 55695110, "score": 1, "vote": 0, "content": "You can't prevent subclasses from using the same names, no. You can protect names against accidental shadowing, however, by giving the name a double underscore prefix: The Python compiler will replace all references to that name, within methods of a class, to add the classname as a prefix. Here, that's AbstractClass, so the actual name becomes _AbstractClass__primitive_operation_3, but you because the compiler rewrites all references, you transparently keep using __primitive_operation_3 in your code. Any __primitive_operation_3 names on a subclass would get renamed with a different prefix, simply because they are defined on a class with a different name. This feature is explicitly aimed at base classes that want to allow subclasses to use a wide range of names in their definitions. See the Reserved classes of identifiers section in the lexical analysis reference documentation: __* Class-private names. Names in this category, when used within the context of a class definition, are re-written to use a mangled form to help avoid name clashes between \u201cprivate\u201d attributes of base and derived classes. and the Identifiers section of the expressions documentation: Private name mangling: When an identifier that textually occurs in a class definition begins with two or more underscore characters and does not end in two or more underscores, it is considered a private name of that class. Private names are transformed to a longer form before code is generated for them. The transformation inserts the class name, with leading underscores removed and a single underscore inserted, in front of the name. For example, the identifier __spam occurring in a class named Ham will be transformed to _Ham__spam. This transformation is independent of the syntactical context in which the identifier is used. If the transformed name is extremely long (longer than 255 characters), implementation defined truncation may happen. If the class name consists only of underscores, no transformation is done. Subclasses can still override the name, but have to explicitly include the same prefix. Note that you can't use this mechanism to avoid special methods (with leading and trailing __ double underscores, e.g. __init__ or __len__) from being overridden in a subclass. Clear project documentation is paramount if subclasses of your base class can't override specific methods without taking care to call the base implementation. At best you can detect if a subclass is overriding a method by checking for missing side effects (which is how the standard library has protected Thread.__init__ overriding or you can check if self.methodname.__func__ is ClassObject.methodname is true still before calling the method.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/45000947/calling-base-class-method-after-child-class-init-from-base-class-init", "keywords": [], "tags": ["python", "python-3.x", "class", "constructor"], "question": {"id": 45000947, "title": "Calling base class method after child class __init__ from base class __init__?", "content": "This is a feature I miss in several languages and wonder if anyone has any idea how it can be done in Python. The idea is that I have a base class: and a derived class: As can be seen above, I have a rebound function which I want called after the Child.__init__ has done its job. And I want this done for all inherited classes, so it would be great if it was performed by the base class, so I do not have to retype that line in every child class. It would be nice if the language had a function like __finally__, operating similar to how it operates with exceptions. That is, it should run after all __init__-functions (of all derived classes) have been run, that would be great. So the call order would be something like: And then object construction is finished. This is also kind of similar to unit testing with setup, run and teardown functions.", "abstract": ""}, "answers": [{"id": 46120342, "score": 7, "vote": 0, "content": "You can do this with a metaclass like that: By overwriting Metaclass.__call__ you can hook after all __init__ ( and __new__) methods of the class-tree have run an before the instance is returned. This is the place to call your rebind function. To understand the call order i added some print statements. The output will look like this: If you want to read on and get deeper into details I can recommend following great article: https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/", "abstract": ""}, {"id": 45036907, "score": 0, "vote": 0, "content": "If you want a \"rebind\" function to be invoked after each instance of a type which inherits from Base is instantiated, then I would say this \"rebind\" function can live outside the Base class(or any class inheriting from it).  You can have a factory function that gives you the object you need when you invoke it(for example give_me_a_processed_child_object()). This factory function basically instantiates an object and does something to it before it returns it to you. Putting logic in __init__ is not a good idea because it obscures logic and intention. When you write kid = Child(), you don't expect many things to happen in the background, especially things that act on the instance of Child that you just created. What you expect is a fresh instance of Child. A factory function, however, transparently does something to an object and returns it to you. This way you know you're getting an already processed instance.  Finally, you wanted to avoid adding \"rebind\" methods to your Child classes which you now you can since all that logic can be placed in your factory function.", "abstract": ""}, {"id": 45001548, "score": 2, "vote": 0, "content": "I may still not fully understand, but this seems to do what I (think) you want: Output:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/23778163/how-to-execute-baseclass-method-before-it-gets-overridden-by-derivedclass-method", "keywords": [], "tags": ["python", "oop", "inheritance"], "question": {"id": 23778163, "title": "How to execute BaseClass method before it gets overridden by DerivedClass method in Python", "content": "I am almost sure that there is a proper term for what I want to do but since I'm not familiar with it, I will try to describe the whole idea explicitly. So what I have is a collection of classes that all inherit from one base class. All the classes consist almost entirely of different methods that are relevant within each class only. However, there are several methods that share similar name, general functionality and also some logic but their implementation is still mostly different. So what I want to know is whether it's possible to create a method in a base class that will execute some logic that is similar to all the methods but still continue the execution in the class specific method. Hopefully that makes sense but I will try to give a basic example of what I want. So consider a base class that looks something like that: And an example of a derived class: So what I'd like to achieve is that the LOGIC_SHARED part in base class access method to be executed when calling the access method of any App class before executing the LOGIC_SPECIFIC part which is(as it says) specific for each access method of all derived classes.  If that makes any difference, the LOGIC_SHARED mostly consists of logging and maintenance tasks. Hope that is clear enough and the idea makes sense. NOTE 1:\nThere are class specific parameters which are being used in the LOGIC_SHARED section. NOTE 2:\nIt is important to implement that behavior using only Python built-in functions and modules. NOTE 3:\nThe LOGIC_SHARED part looks something like that: So, there are plenty of specific class instance attributes that I use and I'm not sure how to use these attributes from the base class.", "abstract": ""}, "answers": [{"id": 24276792, "score": 1, "vote": 0, "content": "May this simple approach can help. and the test result:", "abstract": ""}, {"id": 24267668, "score": 0, "vote": 0, "content": "Adding a combine function we can combine two functions and execute them one after other as bellow Output Bellow it need not be single level hierarchy it can have any number of levels or nested", "abstract": ""}, {"id": 24252776, "score": 1, "vote": 0, "content": "I personally prefer Jonathon Reinhart's answer, but seeing as you seem to want more options, here's two more. I would probably never use the metaclass one, as cool as it is, but I might consider the second one with decorators. This method uses a metaclass for the base class that will force the base class's access method to be called first, without having a separate private function, and without having to explicitly call super or anything like that. End result: no extra work/code goes into inheriting classes. Plus, it works like maaaagiiiiic </spongebob> Below is the code that will do this. Here http://dbgr.cc/W you can step through the code live and see how it works : This uses a metaclass to replace OtherClass's access function with a function that wraps a call to BaseClass's access function and a call to OtherClass's access function. See the best explanation of metaclasses here https://stackoverflow.com/a/6581949. Stepping through the code should really help you understand the order of things. This functionality could also easily be put into a decorator, as shown below. Again, a steppable/debuggable/runnable version of the code below can be found here http://dbgr.cc/0 The decorator above retrieves the BaseClass' function of the same name, and calls that first before calling the OtherClass' function.", "abstract": ""}, {"id": 24169841, "score": 4, "vote": 0, "content": "The easiest method to do what you want is to simply call the parent's class access method inside the child's access method. However, your shared functionality is mostly logging and maintenance. Unless there is a pressing reason to put this inside the parent class, you may want to consider is to refactor the shared functionality into a decorator function. This is particularly useful if you want to reuse similar logging and maintenance functionality for a range of methods inside your class. You can read more about function decorators here: http://www.artima.com/weblogs/viewpost.jsp?thread=240808, or here on Stack Overflow: How to make a chain of function decorators?. Remember than in python, functions are first class objects. That means that you can take a function and pass it as a parameter to another function. A decorator function make use of this. The decorator function takes another function as a parameter (here called method) and then creates a new function (here called decorated_method) that takes the place of the original function.  Your App1 class then would look like this: This really is shorthand for this: I would find this more elegant than adding methods to the superclass to capture shared functionality.", "abstract": ""}, {"id": 24162197, "score": 1, "vote": 0, "content": "If I understand well this commment (How to execute BaseClass method before it gets overridden by DerivedClass method in Python) you want that additional arguments passed to the parent class used in derived class based on Jonathon Reinhart's answer it's how you could do", "abstract": ""}, {"id": 23778281, "score": 11, "vote": 0, "content": "Sure, just put the specific logic in its own \"private\" function, which can overridden by the derived classes, and leave access in the Base.", "abstract": ""}]}]