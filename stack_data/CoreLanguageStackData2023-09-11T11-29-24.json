[{"link": "https://stackoverflow.com/questions/76273800/why-do-my-previous-dictionaries-in-a-list-change-when-i-try-to-add-a-new-one", "keywords": [], "tags": ["python", "dictionary", "for-loop", "append", "key"], "question": {"id": 76273800, "title": "Why do my previous dictionaries in a list change when I try to add a new one?", "content": "I have a code that does the following:\nGoes through a list of dictionaries, fills up a \"temporary\" dictionary with each one's data, and then appends the \"temporary\" dictionary to an \"information\" list. However, I've noticed that every time the \"temporary\" dictionary changes, the overall \"information\" list changes as well. This is a test code that perfectly represents the issue that I'm having: When this is run, the \"info\" variable is different before and after the \"temporary loop\" despite the fact that it's the \"temp_dict\" variable that is changing. This is the output: I understand that the way to fix this would be to replace the \"temporary loop\" with this: But I would really like to understand why this is happening. The line above and the \"temporary loop\" should virtually be doing the same thing, so why is the \"info\" variable changing retroactively as the \"temp_dict\" variable does? Is there a way to prevent this besides my solution above?", "abstract": ""}, "answers": [{"id": 76273911, "score": 0, "vote": 0, "content": "The problem is that you create a single temp_dict outside of the loop and keep updating and appending that one dict to info. With each run of the temporary loop, you are changing the single dict that is referenced multiple times in the list. The solution is to create temp_dict in the loop. You also print \"Info after loop\" before adding the dict to info, missing the data you just built up in the inner loop. outputs To note, you can do this in fewer steps", "abstract": ""}, {"id": 76274065, "score": 0, "vote": 0, "content": "It is the case of referencing a variable instead copying it. If you are not aware of it, it is like your new variable points to the old variable instead of making an independent copy, so whenever you make changes in the old variable because the new variable just points to the old one if you print it, it will show the changes however you haven't made any changes in new variable explicitly, to avoid this you have to make an actual copy of the old variable, in other words, it is known as 'Deep Copy' and referencing is known as 'shallow copy' you can read on it, it is language independent concept so no matter which language you are using it there almost in every programming language. So here is a solution,\nimport the copy library and change last line to here copy.deepcopy returns an independent copy of temp_dict so now you can change the temp_dict without changing the dict present in info array", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73069075/why-updating-value-from-2-lists-behave-differently-one-of-the-item-in-list-is", "keywords": [], "tags": ["python", "list"], "question": {"id": 73069075, "title": "Why Updating value from 2 lists behave differently? (one of the item in list is a single-item list)", "content": "In the above code, updating x[3][0] in x is reflected in y (which is the list of x), but the update in x[1] = 12 is not reflected in y Why this is not getting updated in y?", "abstract": ""}, "answers": [{"id": 75569351, "score": 0, "vote": 0, "content": "They do not behave differently. Changes to x are never reflected in y. However, changes to the 1-element list are reflected both in x and in y: The reason why integers and lists are different, the reason why you don't see changes to integers reflected in y is because it's possible to make changes to a list, but it's not possible to make changes to int: In python, every type is either mutable or immutable. Lists are mutable; integers are immutable.", "abstract": ""}, {"id": 73071139, "score": 4, "vote": 0, "content": "A picture worth thousand words.  Here is the picture that is missing:\n(let's pretend forgetting all *terminology for a moment now) Credits to all posts.  Labor (of the wording & picturing) is mine. First thing first, when you try to use list constructor to create y: list(x) or [:]  it just produces a shallow copy (ie. the outermost container is duplicated, but the copy is filled with reference to the same item (as [18] shown in picture) So later if you update x's [18] it will update the reference point - that's why both lists see the change of 15.  But when you update other object, it directly change the integer object in the container x but not in y. Lesson learned - Copies are shallow by Default!  in Python.\n https://i.stack.imgur.com/Qy0U8.png", "abstract": ""}, {"id": 73071393, "score": 0, "vote": 0, "content": "By using list() you create a new reference (y) to the same addresses in memory that (x) is referring. Element 1 in x and y is an integer which is immutable. Once you use x[1]=12 basically you create a new object in memory for number 12 and x[1] will refer to that object. However, y[1] still refers to previous object (i.e. 3). Element 3 in in x and y is a list which is mutable. Once, you use x[3][0], it updates the same object in memory. So, both x and y reflect the change. I hope I could convey the concept.", "abstract": ""}, {"id": 73069219, "score": 0, "vote": 0, "content": "What is happening is a shallow copy. When you wrote y=list(x), this created a reference from y to x, and not an actual copy. What you need is a deep copy, a copy that creates a new list(including nested lists) instead of referencing the old one. .copy() won't work, because nested lists are still references even though the rest of the copied list is a separate list. Here is the code for a deep copy:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/240178/list-of-lists-changes-reflected-across-sublists-unexpectedly", "keywords": [], "tags": ["python", "list", "nested-lists", "mutable"], "question": {"id": 240178, "title": "List of lists changes reflected across sublists unexpectedly", "content": "I created a list of lists: Then, I changed one of the innermost values: Why did every first element of each sublist change to 5? See also: How do I clone a list so that it doesn't change unexpectedly after assignment? for workarounds for the problem List of dictionary stores only last appended value in every iteration for an analogous problem with a list of dicts How do I initialize a dictionary of empty lists in Python? for an analogous problem with a dict of lists\n", "abstract": ""}, "answers": [{"id": 240205, "score": 799, "vote": 0, "content": "When you write [x]*3 you get, essentially, the list [x, x, x]. That is, a list with 3 references to the same x. When you then modify this single x it is visible via all three references to it: To fix it, you need to make sure that you create a new list at each position. One way to do it is which will reevaluate [1]*4 each time instead of evaluating it once and making 3 references to 1 list. You might wonder why * can't make independent objects the way the list comprehension does. That's because the multiplication operator * operates on objects, without seeing expressions. When you use * to multiply [[1] * 4] by 3, * only sees the 1-element list [[1] * 4] evaluates to, not the [[1] * 4 expression text. * has no idea how to make copies of that element, no idea how to reevaluate [[1] * 4], and no idea you even want copies, and in general, there might not even be a way to copy the element. The only option * has is to make new references to the existing sublist instead of trying to make new sublists. Anything else would be inconsistent or require major redesigning of fundamental language design decisions. In contrast, a list comprehension reevaluates the element expression on every iteration. [[1] * 4 for n in range(3)] reevaluates [1] * 4 every time for the same reason [x**2 for x in range(3)] reevaluates x**2 every time. Every evaluation of [1] * 4 generates a new list, so the list comprehension does what you wanted. Incidentally, [1] * 4 also doesn't copy the elements of [1], but that doesn't matter, since integers are immutable. You can't do something like 1.value = 2 and turn a 1 into a 2.", "abstract": ""}, {"id": 62497944, "score": 7, "vote": 0, "content": "I am adding my answer to explain the same diagrammatically. The way you created the 2D, creates a shallow list Instead, if you want to update the elements of the list, you should use Explanation: One can create a list using: or In the first case all the indices of the array point to the same integer object  and when you assign a value to a particular index, a new int object is created, for example arr[4] = 5 creates  Now let us see what happens when we create a list of list, in this case, all the elements of our top list will point to the same list  And if you update the value of any index a new int object will be created. But since all the top-level list indexes are pointing at the same list, all the rows will look the same. And you will get the feeling that updating an element is updating all the elements in that column.  Credits: Thanks to Pranav Devarakonda for the easy explanation here", "abstract": ""}, {"id": 30898048, "score": 10, "vote": 0, "content": "Alongside the accepted answer that explained the problem correctly, instead of creating a list with duplicated elements using following code: Also, you can use itertools.repeat() to create an iterator object of repeated elements: P.S. If you're using NumPy and you only want to create an array of ones or zeroes you can use np.ones and np.zeros and/or for other numbers use np.repeat:", "abstract": ""}, {"id": 18454568, "score": 182, "vote": 0, "content": "Live visualization using Python Tutor: ", "abstract": ""}, {"id": 57426328, "score": 4, "vote": 0, "content": "@spelchekr from Python list multiplication: [[...]]*3 makes 3 lists which mirror each other when modified and I had the same question about\n\"Why does only the outer *3 create more references while the inner one doesn't? Why isn't it all 1s?\" Here is my explanation after trying the code above:", "abstract": ""}, {"id": 240215, "score": 74, "vote": 0, "content": "Actually, this is exactly what you would expect. Let's decompose what is happening here: You write This is equivalent to: This means lst is a list with 3 elements all pointing to lst1. This means the two following lines are equivalent: As lst[0] is nothing but lst1. To obtain the desired behavior, you can use a list comprehension: In this case, the expression is re-evaluated for each n, leading to a different list.", "abstract": ""}, {"id": 36823796, "score": 4, "vote": 0, "content": "Everyone is explaining what is happening. I'll suggest one way to solve it: And then you get:", "abstract": ""}, {"id": 30759580, "score": 5, "vote": 0, "content": "Let's rewrite your code in the following way: Then having this, run the following code to make everything more clear. What the code does is basically print the ids of the obtained objects, which Return[s] the \u201cidentity\u201d of an object and will help us identify them and analyse what happens: And you will get the following output: So now let's go step-by-step. You have x which is 1, and a single element list y containing x. Your first step is y * 4 which will get you a new list z, which is basically [x, x, x, x], i.e. it creates a new list which will have 4 elements, which are references to the initial x object. The next step is pretty similar. You basically do z * 3, which is [[x, x, x, x]] * 3 and returns [[x, x, x, x], [x, x, x, x], [x, x, x, x]], for the same reason as for the first step.", "abstract": ""}, {"id": 43246520, "score": 13, "vote": 0, "content": "my_list = [[1]*4] * 3 creates one list object [1,1,1,1] in memory and copies its reference 3 times over. This is equivalent to obj = [1,1,1,1]; my_list = [obj]*3. Any modification to obj will be reflected at three places, wherever obj is referenced in the list.\nThe right statement would be: or Important thing to note here is that the * operator is mostly used to create a list of literals. Although 1 is immutable, obj = [1]*4 will still create a list of 1 repeated 4 times over to form [1,1,1,1]. But if any reference to an immutable object is made, the object is overwritten with a new one. This means if we do obj[1] = 42, then obj will become [1,42,1,1] not [42,42,42,42] as some may assume. This can also be verified:", "abstract": ""}, {"id": 64958758, "score": 0, "vote": 0, "content": "Note that items in the sequence are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. Another example to explain this is using multi-dimensional arrays. You probably tried to make a multidimensional array like this: This looks correct if you print it: But when you assign a value, it shows up in multiple places: The reason is that replicating a list with\u00a0*\u00a0doesn\u2019t create copies, it only creates references to the existing objects. The\u00a03\u00a0creates a list containing 3 references to the same list of length two. Changes to one row will show in all rows, which is almost certainly not what you want.", "abstract": ""}, {"id": 65616429, "score": 0, "vote": 0, "content": "While the original question constructed the sublists with the multiplication operator, I'll add an example that uses the same list for the sublists. Adding this answer for completeness as this question is often used as a canonical for the issue The list in each dictionary value is the same object, trying to change one of the dictionaries values will be seen in all. The correct way to construct the dictionary would be to use a copy of the list for each value.", "abstract": ""}, {"id": 64489659, "score": 0, "vote": 0, "content": "I arrived here because I was looking to see how I could nest an arbitrary number of lists. There are a lot of explanations and specific examples above, but you can generalize N dimensional list of lists of lists of ... with the following recursive function: You make your first call to the function like this: where (3,5,2) is a tuple of the dimensions of the structure (similar to numpy shape argument), and 1.0 is the element you want the structure to be initialized with (works with None as well). Note that the init argument is only provided by the recursive call to carry forward the nested child lists output of above: set specific elements: resulting output: the non-typed nature of lists is demonstrated above", "abstract": ""}, {"id": 240202, "score": 49, "vote": 0, "content": "or even: Creates a list that references the internal [1,1,1,1] 3 times - not three copies of the inner list, so any time you modify the list (in any position), you'll see the change three times. It's the same as this example: where it's probably a little less surprising.", "abstract": ""}, {"id": 38866487, "score": 3, "vote": 0, "content": "Trying to explain it more descriptively, Operation 1: Operation 2: Noticed why doesn't modifying the first element of the first list didn't modify the second element of each list? That's because [0] * 2 really is a list of two numbers, and a reference to 0 cannot be modified. If you want to create clone copies, try Operation 3: another interesting way to create clone copies, Operation 4:", "abstract": ""}, {"id": 38397772, "score": 2, "vote": 0, "content": "By using the inbuilt list function you can do like this", "abstract": ""}, {"id": 37804636, "score": 5, "vote": 0, "content": "In simple words this is happening because in python everything works by reference, so when you create a list of list that way you basically end up with such problems. To solve your issue you can do either one of them:\n1. Use numpy array documentation for numpy.empty\n2. Append the list as you get to a list.\n3. You can also use dictionary if you want  ", "abstract": ""}, {"id": 36452923, "score": 9, "vote": 0, "content": "Python containers contain references to other objects. See this example: In this b is a list that contains one item that is a reference to list a. The list a is mutable. The multiplication of a list by an integer is equivalent to adding the list to itself multiple times (see common sequence operations). So continuing with the example: We can see that the list c now contains two references to list a which is equivalent to c = b * 2. Python FAQ also contains explanation of this behavior: How do I create a multidimensional list?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73251454/why-when-change-a-dictionary-from-a-list-of-dictionaries-the-list-also-changes", "keywords": [], "tags": ["python", "python-3.x", "list", "dictionary"], "question": {"id": 73251454, "title": "Why when change a dictionary from a list of dictionaries, the list also changes in Python?", "content": "A code example: Why y is also changed when I change x? Does this logic also exist in other operations in Python? A list of values don't have this phenomenon:", "abstract": ""}, "answers": [{"id": 73270426, "score": 0, "vote": 0, "content": "If you know the concept of \"Call by value vs call by reference\", your question has the same answer. I try to explain the difference between primitive value and reference in your two examples. At first, you are creating an empty list [] and saving its memory address in the variable y. After that, you create a dictionary {'num':1} and save the memory address of that dictionary in the variable x. Then by running the y.append(x) statement, you are saving the saved dictionary address from x as a new element in the dictionary that is referenced by y. So there is just one dictionary in the memory, but its address is saved in both variable x and the first element of the list that is referenced by y. Never mind that when you are referencing the dictionary you use the address that is stored in the variable x or in the first element of the list, you'll get the same result. So, there is no difference betweenx['num']=2 and y[0]['num']=2 and make the same result. In your second code, you make a copy of the value 1 stored in the variable x as the first value of the list that is referenced by y. Copying the value doesn't have any similarity with copying the address, and when you change the 1 value stored in the variable x to 2, it doesn't make any changes in the 1 value that is stored in the first element of the array that is referenced by y.", "abstract": ""}, {"id": 73251656, "score": 1, "vote": 0, "content": "Because when you append x to y, y[0] and x still refer to the same object, you can check that by doing: You can see that both object share the same memory address. If you want both to be different you need to do:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70403857/why-does-a-change-in-nested-list-doesnt-affect-the-first-layers-and-only-the-su", "keywords": [], "tags": ["python", "python-3.x", "list", "python-3.8"], "question": {"id": 70403857, "title": "Why does a change in nested list doesn&#39;t affect the first layers and only the subsequent layers?", "content": "I just wanted to know how do we get the following output. The given below is a Python code: Output is: Why x[1]=12 didn't make any changes in the list y? But why x[3][0]=15 changed the element in list y? Can you give a detailed and simple explanation to this? Why???", "abstract": ""}, "answers": [{"id": 70403919, "score": 2, "vote": 0, "content": "Imagine each element is a variable: you copy that as y so you have when you do x[3][0] = 15 you are changing the first element of d. notice that d is still the variable d, you changed its content but it's still the same d in both lists. Now you change the second element of x but y is still EDIT: adding a non-code example to make it maybe more clear let's say x is a list with: when you copy x as y, you have: when you do x[2][0] = 1 you walk to where the notebook is and change the content, both x and y still tell you to go to that same notebook to know what's in there, you didn't change the 3rd paper, you followed its instruction and changed the content of the notebook when you do x[1] = 6, you are changing the second element of x with a new paper that says 6, but you didn't change the one in y because it's a different paper (a copy of the original)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70315542/why-does-the-original-list-change-when-i-change-the-copied-list-python", "keywords": [], "tags": ["python", "list"], "question": {"id": 70315542, "title": "Why does the original list change when I change the copied list (PYTHON)", "content": "So I have this simple code: If I want the final result of the variable list to be the following matrix: [[1,2],[3,4]], so the variable list1 should be the transposed matrix: [[1,3],[2,4]]. Somehow the result is this: [['1', '3'], ['3', '4']] [['1', '3'], ['3', '4']]. Please someone help me. Thanks and have a good weekend", "abstract": ""}, "answers": [{"id": 70315609, "score": 1, "vote": 0, "content": "you should use copy.deepcopy. If your list is a list of integers or floats, copy would suffice but since you have list of lists, you need to recursively copy the elements inside the lists. You can find more detailed answer here: What is the difference between shallow copy, deepcopy and normal assignment operation?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/53752520/value-in-list-changed-after-running-through-loop", "keywords": [], "tags": ["python", "list", "loops"], "question": {"id": 53752520, "title": "Value in list changed after running through loop", "content": "I\u00b4ve been cleaning some data recently and there is just one thing that struck me.\nSimple example: However, if I try the following, I obtain a different result: It seems rather odd to me that in test_list1, I was able to change the values in its sub-lists without actually referring to test_list1.\nWhy did the values in test_list1 change just by running the loop if I didn\u00b4t explicitly stated that test_list1[0][0] = 0 and so on?\nIn test_list2, it was not possible. Thanks in advance", "abstract": ""}, "answers": [{"id": 53752755, "score": 1, "vote": 0, "content": "Your question can be simplified to this: That is because when you do b = a with numbers, b is a copy of a, so you can edit them separately. But when you do this with a list, the two variables correspond to the same object. This is mostly done to improve efficiency (copying a list every time you do something like a = b would be very inefficient and often useless). So when you edit one, the other one is affected. In for x in test_list2:, x is a copy of an element of test_list2. But in for x in test_list1:, x directly correspond to an element (a list) of test_list2. For more details, you can read this article about mutable objects.", "abstract": ""}, {"id": 53752701, "score": 0, "vote": 0, "content": "I think the bottom line is that in your first loop, each instance of x is a list.  In your second loop, each instance of x is an integer.  In Python, lists are mutable, but ints are immutable. If you do a search online for \"python mutable vs immutable\", you can find a number of pages that describe what the difference is and why it leads to results like this.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44425143/why-did-the-value-of-x-change", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 44425143, "title": "why did the value of &quot;x&quot; change?", "content": "Here is my code: So the question is why did the value of x change if it has not received anything?", "abstract": ""}, "answers": [{"id": 44425173, "score": 1, "vote": 0, "content": "When you put: All x is doing is acting as a pointer to the list object in memory. When you do the above, you are saying I want y to point to the same list that x references in the memory. Any changes in place changes to y will also affect x. If you wish to have the reference y point to a different object in memory (with the same values as x,) you need to make a copy of x.  Now y and x will be pointing to different list objects in memory, but both objects will have the same values. Note that any mutable datatype in python shares this reference property, such as: sets, dictionaries, lists, byte arrays and also some classes. Look into the differences between mutable and immutable datatypes in python as this distinction is critical and will lead to undiagnosible bugs without knowledge on how python accesses different data types. EDIT!! Sorry, I did not notice x is made of a series of lists. You need to use deepcopy to copy the nested lists!", "abstract": ""}, {"id": 44425167, "score": 0, "vote": 0, "content": "When you write: You're literally saying that x equals y. This doesn't make a copy of x. Whatever you do to x will happen to y and vice versa. You need to make a copy of x if you want them to be independent. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/47101750/changing-instance-variable-in-python-also-changes-original-list", "keywords": [], "tags": ["python", "python-3.x", "object", "instance", "instance-variables"], "question": {"id": 47101750, "title": "Changing instance variable in Python also changes original list", "content": "Here is my code: Output is ([9], 10). Why does passing a list to an instance variable and then changing the instance variable also change the original list, but not the original integer?  How do you pass a list to an instance variable in Python, and then change the instance variable without affecting the original list?", "abstract": ""}, "answers": [{"id": 47101804, "score": 0, "vote": 0, "content": "The list is a mutable object; the assignment copies the reference, so that when you change the value of one element, you change the original object. An integer is not mutable; when you change the value, Python changes the reference to a new object with the new value.  self.y does not refer to the same object as y any more.", "abstract": ""}, {"id": 47101803, "score": 1, "vote": 0, "content": "I believe this is because lists are mutable, while integers are immutable. Once you make a change to a list, the same list is returned. Once you change an integer, a \"copy\" of the integer is returned. So func is changing the x, but creating a new y", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16774913/why-is-list-changing-with-no-reason", "keywords": [], "tags": ["python"], "question": {"id": 16774913, "title": "Why is list changing with no reason?", "content": "I passed the copy of a list to a function and for some reason the original list changed.I tried everything I could and this is totally illogical or I did something really wrong. I want to know why grid is actually changing.", "abstract": ""}, "answers": [{"id": 34665057, "score": 0, "vote": 0, "content": "You, my friend, are having trouble with namespaces.\nTry new_array = old_array[:].\nThis causes a slice in the array, but because there aren't any numbers before or after the colon, it's not cutting anything off, but still forcing a duplicate of the array. Names refer to objects.  Names are introduced by name binding\noperations. Each occurrence of a name in the program text refers to\nthe binding of that name established in the innermost function block\ncontaining the use. A block is a piece of Python program text that is executed as a\nunit. The following are blocks: a module, a function body, and a class\ndefinition. Each command typed interactively is a block.  A script\nfile (a file given as standard input to the interpreter or specified\nas a command line argument to the interpreter) is a code block.  A\nscript command (a command specified on the interpreter command line\nwith the '-c' option) is a code block.  The string argument passed\nto the built-in functions \"eval()\" and \"exec()\" is a code block. A code block is executed in an execution frame.  A frame contains\nsome administrative information (used for debugging) and determines\nwhere and how execution continues after the code block's execution has\ncompleted. A scope defines the visibility of a name within a block.  If a local\nvariable is defined in a block, its scope includes that block.  If the\ndefinition occurs in a function block, the scope extends to any blocks\ncontained within the defining one, unless a contained block introduces\na different binding for the name.  The scope of names defined in a\nclass block is limited to the class block; it does not extend to the\ncode blocks of methods -- this includes comprehensions and generator\nexpressions since they are implemented using a function scope.  This\nmeans that the following will fail: class A:\n       a = 42\n       b = list(a + i for i in range(10)) When a name is used in a code block, it is resolved using the nearest\nenclosing scope.  The set of all such scopes visible to a code block\nis called the block's environment. If a name is bound in a block, it is a local variable of that block,\nunless declared as \"nonlocal\".  If a name is bound at the module\nlevel, it is a global variable.  (The variables of the module code\nblock are local and global.)  If a variable is used in a code block\nbut not defined there, it is a free variable. When a name is not found at all, a \"NameError\" exception is raised.\nIf the name refers to a local variable that has not been bound, an\n\"UnboundLocalError\" exception is raised.  \"UnboundLocalError\" is a\nsubclass of \"NameError\". The following constructs bind names: formal parameters to functions,\n\"import\" statements, class and function definitions (these bind the\nclass or function name in the defining block), and targets that are\nidentifiers if occurring in an assignment, \"for\" loop header, or after\n\"as\" in a \"with\" statement or \"except\" clause. The \"import\" statement\nof the form \"from ... import *\" binds all names defined in the\nimported module, except those beginning with an underscore.  This form\nmay only be used at the module level. A target occurring in a \"del\" statement is also considered bound for\nthis purpose (though the actual semantics are to unbind the name). Each assignment or import statement occurs within a block defined by a\nclass or function definition or at the module level (the top-level\ncode block). If a name binding operation occurs anywhere within a code block, all\nuses of the name within the block are treated as references to the\ncurrent block.  This can lead to errors when a name is used within a\nblock before it is bound.  This rule is subtle.  Python lacks\ndeclarations and allows name binding operations to occur anywhere\nwithin a code block.  The local variables of a code block can be\ndetermined by scanning the entire text of the block for name binding\noperations. If the \"global\" statement occurs within a block, all uses of the name\nspecified in the statement refer to the binding of that name in the\ntop-level namespace.  Names are resolved in the top-level namespace by\nsearching the global namespace, i.e. the namespace of the module\ncontaining the code block, and the builtins namespace, the namespace\nof the module \"builtins\".  The global namespace is searched first.  If\nthe name is not found there, the builtins namespace is searched.  The\nglobal statement must precede all uses of the name. The builtins namespace associated with the execution of a code block\nis actually found by looking up the name \"builtins\" in its global\nnamespace; this should be a dictionary or a module (in the latter case\nthe module's dictionary is used).  By default, when in the \"main\"\nmodule, \"builtins\" is the built-in module \"builtins\"; when in any\nother module, \"builtins\" is an alias for the dictionary of the\n\"builtins\" module itself.  \"builtins\" can be set to a user-created\ndictionary to create a weak form of restricted execution. CPython implementation detail: Users should not touch\n\"builtins\"; it is strictly an implementation detail.  Users\nwanting to override values in the builtins namespace should \"import\"\nthe \"builtins\" module and modify its attributes appropriately. The namespace for a module is automatically created the first time a\nmodule is imported.  The main module for a script is always called\n\"main\". The \"global\" statement has the same scope as a name binding operation\nin the same block.  If the nearest enclosing scope for a free variable\ncontains a global statement, the free variable is treated as a global. A class definition is an executable statement that may use and define\nnames. These references follow the normal rules for name resolution.\nThe namespace of the class definition becomes the attribute dictionary\nof the class.  Names defined at the class scope are not visible in\nmethods. Interaction with dynamic features There are several cases where Python statements are illegal when used\nin conjunction with nested scopes that contain free variables. If a variable is referenced in an enclosing scope, it is illegal to\ndelete the name.  An error will be reported at compile time. If the wild card form of import --- \"import *\" --- is used in a\nfunction and the function contains or is a nested block with free\nvariables, the compiler will raise a \"SyntaxError\". The \"eval()\" and \"exec()\" functions do not have access to the full\nenvironment for resolving names.  Names may be resolved in the local\nand global namespaces of the caller.  Free variables are not resolved\nin the nearest enclosing namespace, but in the global namespace.  [1]\nThe \"exec()\" and \"eval()\" functions have optional arguments to\noverride the global and local namespace.  If only one namespace is\nspecified, it is used for both. Related help topics: global, nonlocal, ASSIGNMENT, DELETION,DYNAMICFEATURES", "abstract": ""}, {"id": 16775047, "score": 1, "vote": 0, "content": "Simple solution, use copy module instead of ad hoc copying: To answer your question, I think why comes down to following bit in your code: While your [:] copy only copies one level deep, the assignment is two levels deep.", "abstract": ""}, {"id": 16774981, "score": 10, "vote": 0, "content": "Your grid variable is a 2D array, i.e. a list of lists. When you do grid[:] you are making a new list of lists, but the elements themselves are still references to the same maze row. You want to do a deepcopy, e.g. the deepcopy function from the copy module.", "abstract": ""}]}]