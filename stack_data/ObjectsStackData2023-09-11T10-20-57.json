[{"link": "https://stackoverflow.com/questions/31214446/immutable-classes-and-subclasses", "keywords": [], "tags": ["java"], "question": {"id": 31214446, "title": "Immutable Classes and Subclasses", "content": "I'm trying to learn about mutable/immutable classes and I came across this post Part of the answer provided was:  If you want to enforce immutability, you cannot have subclasses. See\n  for example java.lang.String, which is a final class for this reason:\n  To prevent people from subclassing String to make it mutable. Alright, I understand it, but, how would you handle this issue. Let's say you were given the task of creating 3 Employee classes, Accountant, ITDepartment, and QualityAssurance. Now, you could create an abstract class called Employee with common methods that would be shared by all (employee ID, name, salary etc..), however, your classes are no longer immutable. Using Java, How then would you solve this problem ? Would you create the 3 classes, make them final, and don't implement an abstract method? (So, no subclassing whatsoever) or would you use an interface, and provide only the getters?  ", "abstract": ""}, "answers": [{"id": 76724889, "score": 0, "vote": 0, "content": "I think with Java 17 and \"Sealed Classes and Interfaces\" feature it became a bit more easier to follow immutability while using inheritance. Now we can just restrict classes which may extend the parent class to ones that we are trusted to. Let me show an example based on the suggested entities and the feature (pay attention on MutabilityBreaker which is not compiled due to the restriction of Employee class):", "abstract": ""}, {"id": 31215021, "score": 7, "vote": 0, "content": "If you want to enforce immutability, you cannot have subclasses. This is almost true, but not entirely.  To restate it: If you want to enforce immutability, you must ensure that all sub-classes are immutable. The problem with allowing subclassing is that normally anyone who can author a class can subclass any public non-final class. But all subclasses must invoke one of their super-class's constructors.  Package-private constructors can only be invoked by subclasses in the same package. If you seal packages so that you control which classes are in your package, you can constrain subclassing.  First define a class you want to subclass: Since all sub-classes have to have access to the super-constructor, you can ensure all the sub-classes in the package you define follow immutable discipline. To apply this to your example,", "abstract": ""}, {"id": 31215834, "score": 2, "vote": 0, "content": "java.lang.String is special, very special - it's a basic type used everywhere. In particular, java security framework heavily depends on Strings, therefore it is critical that everybody sees the same content of a String, i.e. a String must be immutable (even under unsafe publication!) (Unfortunately a lot of people blindly apply those strict requirements of String to their own classes, often unjustified)  Even so, it's not really a big deal if String can be subclassed, as long as all methods in String are final, so that a subclass cannot mess with what a String is supposed to be like. If I'm accepting a String, and you give me a subclass of String, I don't care what you do in the subclass; as long as the content and the behavior of the String superclass is not tempered with.  Of course, being such a basic type, it's wise to mark String as final to avoid all confusions.  In your use case, you can just have an abstract Employee, and make sure all subclasses are implemented as immutable. Any Employee object, at runtime, must belong to a concrete subclass, which is immutable. If, you cannot control who subclasses Employee, and you suspect that they are either morons that don't know what they are doing, or villains that  intend to cause troubles, you can at least protect the part in Employee so that subclasses cannot mess it up. For example, the name of an Employee is immutable no matter what subclass does - However, such defensive design is often unjustified in most applications by most programmers.  We don't have to be so paranoid. 99% of coding are cooperative. No big deal if someone really need to override something, let them. 99% of us are not writing some core APIs like String or Collection. A lot of Bloch's advices, unfortunately, are based on that kind of use cases. The advices are not really helpful to most programmers, especially new ones, churning out in-house apps.", "abstract": ""}, {"id": 31214896, "score": 2, "vote": 0, "content": "It's worth thinking why immutability is desirable - usually it's because you have data which you need to assume is not going to change.\nOne approach to do this is to make a final Employee class with a non-final member containing the details specific to the subclasses: This isn't technically immutable (since an implementer could write a mutable implementation of DepartmentalDetails) but it does encapsulate the mutability, so it gives the same benefits while allowing some extensibility.\n(This is related to this is the concept of composition vs inheritance, although I don't believe this pattern is how that is normally used.) One other possibility I think is worth considering - you could make the three subclasses as you suggest, make them all final, and stick a big comment on the abstract class saying all implementations should be immutable.  It's not bulletproof, but on a small development project the complexity saving is likely to be worth the tiny risk.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/54707731/this-class-inherits-from-a-class-marked-as-immutable-and-therefore-should-be-i", "keywords": [], "tags": ["visual-studio", "flutter"], "question": {"id": 54707731, "title": "This class inherits from a class marked as @immutable, and therefore should be immutable (all instance fields must be final)", "content": "Getting the below issue, and not able to solve it, Can anyone help me in solving this. This class inherits from a class marked as @immutable, and therefore should be immutable (all instance fields must be final). dart(must_be_immutable)  Thanks.", "abstract": ""}, "answers": [{"id": 76299913, "score": 0, "vote": 0, "content": "In case that it is possible you can make your field static. This will also solve your issue. A static field is independent of any class. As long as you don't try to pass it in the constructor and it is not private, it should be fine. I you must have a private field then, I would go with the accepted answer.", "abstract": ""}, {"id": 74370232, "score": 0, "vote": 0, "content": "The problem is you cannot make the class immutable with out making all its properties 'final'. Sometimes we have to make a property not required and have to remove final. In this case your class never be immutable. You can simply ignore the warning. this will not harm your performance.", "abstract": ""}, {"id": 73348521, "score": 1, "vote": 0, "content": "Maybe this will be helpful to someone else: I am new to Flutter and I ran into this issue recently. I couldn't set my variables as final, though, because I needed to be able to change the values of the variables. I found out that in my case I needed to use a StatefulWidget instead of a StatelessWidget.", "abstract": ""}, {"id": 62843397, "score": 63, "vote": 0, "content": "This issue occurs when all the class variables are not declared as final. You can either make them final or for ignoring this warning you can add the following comment above the class declaration:", "abstract": ""}, {"id": 54707789, "score": 35, "vote": 0, "content": "All fields in a class extending StatelessWidget should be final. From the documentations. StatelessWidget class. A widget that does not require mutable state. https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html", "abstract": ""}, {"id": 71332795, "score": 0, "vote": 0, "content": "Simply add this line top of the warning:", "abstract": ""}, {"id": 69737333, "score": 2, "vote": 0, "content": "Any an immutable class add after it \"final\" to next line of flutter code, this will solve your problem, For example:-", "abstract": ""}, {"id": 62559839, "score": 3, "vote": 0, "content": "Use That way", "abstract": ""}, {"id": 61571094, "score": 13, "vote": 0, "content": "Make sure that all your instances variable in class are marked as final and the object is also marked as final. In class Inside widget that you in,", "abstract": ""}, {"id": 56944907, "score": 2, "vote": 0, "content": "From flutter doc: The following is a skeleton of a stateless widget subclass called GreenFrog.\n  Normally, widgets have more constructor arguments, each of which corresponds to a final property. Just like this", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/203475/how-do-i-identify-immutable-objects-in-java", "keywords": [], "tags": ["java", "functional-programming", "immutability"], "question": {"id": 203475, "title": "How do I identify immutable objects in Java", "content": "In my code, I am creating a collection of objects which will be accessed by various threads in a fashion that is only safe if the objects are immutable. When an attempt is made to insert a new object into my collection, I want to test to see if it is immutable (if not, I'll throw an exception). One thing I can do is to check a few well-known immutable types: This actually gets me 90% of the way, but sometimes my users will want to create simple immutable types of their own: Is there some way (perhaps using reflection) that I could reliably detect whether a class is immutable? False positives (thinking it's immutable when it isn't) are not acceptable but false negatives (thinking it's mutable when it isn't) are. Edited to add: Thanks for the insightful and helpful answers. As some of the answers pointed out, I neglected to define my security objectives. The threat here is clueless developers -- this is a piece of framework code that will be used by large numbers of people who know next-to-nothing about threading and won't be reading the documentation. I do NOT need to defend against malicious developers -- anyone clever enough to mutate a String or perform other shenanigans will also be smart enough to know it's not safe in this case. Static analysis of the codebase IS an option, so long as it is automated, but code reviews cannot be counted on because there is no guarantee every review will have threading-savvy reviewers.", "abstract": ""}, "answers": [{"id": 28112166, "score": 0, "vote": 0, "content": "I appreciate and admire the amount of work Grundlefleck has put into his mutability detector, but I think it is a bit of an overkill.  You can write a simple but practically very adequate (that is, pragmatic) detector as follows: (note: this is a copy of my comment here: https://stackoverflow.com/a/28111150/773113) First of all, you are not going to be just writing a method which determines whether a class is immutable; instead, you will need to write an immutability detector class, because it is going to have to maintain some state.  The state of the detector will be the detected immutability of all classes which it has examined so far. This is not only useful for performance, but it is actually necessary because a class may contain a circular reference, which would cause a simplistic immutability detector to fall into infinite recursion. The immutability of a class has four possible values: Unknown, Mutable, Immutable, and Calculating. You will probably want to have a map which associates each class that you have encountered so far to an immutability value.  Of course, Unknown does not actually need to be implemented, since it will be the implied state of any class which is not yet in the map. So, when you begin examining a class, you associate it with a Calculating value in the map, and when you are done, you replace Calculating with either Immutable or Mutable. For each class, you only need to check the field members, not the code.  The idea of checking bytecode is rather misguided. First of all, you should not check whether a class is final; The finality of a class does not affect its immutability.  Instead, a method which expects an immutable parameter should first of all invoke the immutability detector to assert the immutability of the class of the actual object that was passed. This test can be omitted if the type of the parameter is a final class, so finality is good for performance, but strictly speaking not necessary.  Also, as you will see further down, a field whose type is of a non-final class will cause the declaring class to be considered as mutable, but still, that's a problem of the declaring class, not the problem of the non-final immutable member class. It is perfectly fine to have a tall hierarchy of immutable classes, in which all the non-leaf nodes must of course be non-final. You should not check whether a field is private;  it is perfectly fine for a class to have a public field, and the visibility of the field does not affect the immutability of the declaring class in any way, shape, or form.  You only need to check whether the field is final and its type is immutable. When examining a class, what you want to do first of all is to recurse to determine the immutability of its super class.  If the super is mutable, then the descendant is by definition mutable too. Then, you only need to check the declared fields of the class, not all fields. If a field is non-final, then your class is mutable. If a field is final, but the type of the field is mutable, then your class is mutable. (Arrays are by definition mutable.) If a field is final, and the type of the field is Calculating, then ignore it and proceed to the next field.  If all fields are either immutable or Calculating, then your class is immutable. If the type of the field is an interface, or an abstract class, or a non-final class, then it is to be considered as mutable, since you have absolutely no control over what the actual implementation may do. This might seem like an insurmountable problem, because it means that wrapping a modifiable collection inside an UnmodifiableCollection will still fail the immutability test, but it is actually fine, and it can be handled with the following workaround. Some classes may contain non-final fields and still be effectively immutable.  An example of this is the String class.  Other classes which fall into this category are classes which contain non-final members purely for performance monitoring purposes (invocation counters, etc.), classes which implement popsicle immutability (look it up), and classes which contain members that are interfaces which are known to not cause any side effects. Also, if a class contains bona fide mutable fields but promises not to take them into account when computing hashCode() and equals(), then the class is of course unsafe when it comes to multi-threading, but it can still be considered as immutable for the purpose of using it as a key in a map. So, all these cases can be handled in one of two ways: Manually adding classes (and interfaces) to your immutability detector.  If you know that a certain class is effectively immutable despite the fact that the immutability test for it fails, you can manually add an entry to your detector which associates it with Immutable.  This way, the detector will never attempt to check whether it is immutable, it will always just say 'yes, it is.' Introducing an @ImmutabilityOverride annotation.  Your immutability detector can check for the presence of this annotation on a field, and if present, it may treat the field as immutable despite the fact that the field may be non-final or its type may be mutable. The detector may also check for the presence of this annotation on the class, thus treating the class as immutable without even bothering to check its fields. I hope this helps future generations. EDIT in 2023 I ended up writing a library called Bathyscaphe that implements all of the above. Although indeed a lot more simple than MutabilityDetector, it ended up being far more complicated than I imagined, so I would strongly recommend that you use this library instead of attempting to implement the above by yourself. Bathyscaphe can be found here: https://github.com/mikenakis/Bathyscaphe In my opinion, static analysis tools such as MutabilityDetector (see Grundlefleck's answer) can be useful at certain times and under certain scenarios, but they do not (and cannot) provide a complete solution to the problem at all times. A complete solution requires runtime checking as I explain on my blog here: https://blog.michael.gr/2022/05/bathyscaphe.html, and that's why I have written Bathyscaphe. To address the concern expressed by Martin Probst in his answer to this question, Bathyscaphe will also help you check for thread-safety, although this branch of checks relies heavily on annotations that you add to your code, so naturally, Bathyscaphe will only give correct answers if the annotations are correct. But it is still better than coding in the dark.", "abstract": ""}, {"id": 203639, "score": 4, "vote": 0, "content": "This could be another hint: If the class has no setters then it cannot be mutated, granted the parameters it was created with are either \"primitive\" types or not mutable themselves. Also no methods could be overridden, all fields are final and private, I'll try to code something tomorrow for you, but  Simon's code using reflection looks pretty good. In the mean time try to grab a copy of the \"Effective Java\" book by Josh Block, it has an Item related to this topic. While is does not for sure say how to detect an immutable class, it shows how to create a good one. The item is called: \"Favor immutability\" Updated link: https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997", "abstract": ""}, {"id": 204015, "score": 31, "vote": 0, "content": "Use the Immutable annotation from Java Concurrency in Practice. The tool FindBugs can then help in detecting classes which are mutable but shouldn't be.", "abstract": ""}, {"id": 14931051, "score": 3, "vote": 0, "content": "You can use AOP and @Immutable annotation from jcabi-aspects:", "abstract": ""}, {"id": 23955278, "score": 1, "vote": 0, "content": "To my knowledge, there is no way to identify immutable objects that is 100% correct. However, I have written a library to get you closer. It performs analysis of bytecode of a class to determine if it is immutable or not, and can execute at runtime. It is on the strict side, so it also allows whitelisting known immutable classes. You can check it out at: www.mutabilitydetector.org It allows you to write code like this in your application: It is free and open source under the Apache 2.0 license.", "abstract": ""}, {"id": 6843336, "score": 1, "vote": 0, "content": "Try this:", "abstract": ""}, {"id": 612042, "score": 0, "vote": 0, "content": "Something which works for a high percentage of builtin classes is test for instanceof Comparable. For the classes which are not immutable like Date, they are often treated as immutable in most cases.", "abstract": ""}, {"id": 203571, "score": 31, "vote": 0, "content": "There is no reliable way to detect if a class is immutable. This is because there are so many ways a property of a class might be altered and you can't detect all of them via reflection. The only way to get close to this is: Then you can check with the following code if the object you have is immutable: Update: As suggested in the comments, it could be extended to recurse on the superclass instead of checking for a certain class. It was also suggested to recursively use isImmutable in the isValidFieldType Method. This could probably work and I have also done some testing. But this is not trivial. You can't just check all field types with a call to isImmutable, because String already fails this test (its field hash is not final!). Also you are easily running into endless recursions, causing StackOverflowErrors ;) Other problems might be caused by generics, where you also have to check their types for immutablity. I think with some work, these potential problems might be solved somehow. But then, you have to ask yourself first if it really is worth it (also performance wise).", "abstract": ""}, {"id": 205428, "score": 3, "vote": 0, "content": "why do all the recommendations require the class to be final?  if you are using reflection to check the class of each object, and you can determine programmatically that that class is immutable (immutable, final fields), then you don't need to require that the class itself is final.", "abstract": ""}, {"id": 203961, "score": 4, "vote": 0, "content": "In my code, I am creating a collection of objects which will be accessed by various threads in a fashion that is only safe if the objects are immutable. Not a direct answer to your question, but keep in mind that objects that are immutable are not automatically guaranteed to be thread safe (sadly). Code needs to be side-effect free to be thread safe, and that's quite a bit more difficult. Suppose you have this class: Then the foolAround() method might include some non-thread safe operations, which will blow up your app. And it's not possible to test for this using reflection, as the actual reference can only be found in the method body, not in the fields or exposed interface. Other than that, the others are correct: you can scan for all declared fields of the class, check if every one of them is final and also an immutable class, and you're done. I  don't think methods being final is a requirement. Also, be careful about recursively checking dependent fields for immutability, you might end up with circles: Classes A and B are perfectly immutable (and possibly even usable through some reflection hacks), but naive recursive code will go into an endless loop checking A, then B, then A again, onwards to B, ... You can fix that with a 'seen' map that disallows cycles, or with some really clever code that decides classes are immutable if all their dependees are immutable only depending on themselves, but that's going to be really complicated...", "abstract": ""}, {"id": 203797, "score": 2, "vote": 0, "content": "Like the other answerers already said, IMHO there is no reliable way to find out if an object is really immutable. I would just introduce an interface \"Immutable\" to check against when appending. This works as a hint that only immutable objects should be inserted for whatever reason you're doing it.", "abstract": ""}, {"id": 203500, "score": 8, "vote": 0, "content": "Basically no.  You could build a giant white-list of accepted classes but I think the less crazy way would be to just write in the documentation for the collection that everything that goes is this collection must be immutable. Edit: Other people have suggested having an immutable annotation. This is fine, but you need the documentation as well. Otherwise people will just think \"if I put this annotation on my class I can store it in the collection\" and will just chuck it on anything, immutable and mutable classes alike. In fact, I would be wary of having an immutable annotation just in case people think that annotation makes their class immutable.", "abstract": ""}, {"id": 203506, "score": 3, "vote": 0, "content": "You Can Ask your clients to add metadata (annotations) and check them at runtime with reflection, like this: Metadata: Client Code: Then by using reflection on the class, check if it has the annotation (I would paste the code but its boilerplate and can be found easily online)", "abstract": ""}, {"id": 203504, "score": 9, "vote": 0, "content": "At my company we've defined an Attribute called @Immutable.  If you choose to attach that to a class, it means you promise you're immutable. It works for documentation, and in your case it would work as a filter. Of course you're still depending on the author keeping his word about being immutable, but since the author explicitly added the annotation it's a reasonable assumption.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/26691935/overriding-a-stored-property-in-swift", "keywords": [], "tags": ["inheritance", "swift", "properties", "overriding"], "question": {"id": 26691935, "title": "Overriding a stored property in Swift", "content": "I noticed that the compiler won't let me override a stored property with another stored value (which seems odd): However, I'm allowed to do this with a computed property: Why am I not allowed to give it another value? Why is overriding with a stored property an abomination and doing it with a computed one kosher? What where they thinking?", "abstract": ""}, "answers": [{"id": 61374973, "score": 7, "vote": 0, "content": "Swift Overriding a stored property Swift does not allow you to override stored property. Instead of this you can use computed property It is more clear when compare with Java, where a class field can not be overrode and does not support polymorphism because is defined in compile time(run efficiently). It is called a variable hiding[About] It is not recommended to use this technics because it is hard to read/support [Swift property]", "abstract": ""}, {"id": 26692026, "score": 102, "vote": 0, "content": "Why am I not allowed to just give it another value? You are definitely allowed to give an inherited property a different value. You can do it if you initialize the property in a constructor that takes that initial value, and pass a different value from the derived class: Overriding a property is not the same as giving it a new value - it is more like giving a class a different property. In fact, that is what happens when you override a computed property: the code that computes the property in the base class is replaced by code that computes the override for that property in the derived class. [Is it] possible to override the actual stored property, i.e. lightSaberColor that has some other behavior? Apart from observers, stored properties do not have behavior, so there is really nothing there to override. Giving the property a different value is possible through the mechanism described above. This does exactly what the example in the question is trying to achieve, with a different syntax.", "abstract": ""}, {"id": 70832527, "score": 1, "vote": 0, "content": "", "abstract": ""}, {"id": 70504478, "score": 0, "vote": 0, "content": "I use this approach:", "abstract": ""}, {"id": 69154524, "score": 1, "vote": 0, "content": "additional to above examples,", "abstract": ""}, {"id": 26692041, "score": 24, "vote": 0, "content": "You probably want to assign another value to the property:", "abstract": ""}, {"id": 67920241, "score": -1, "vote": 0, "content": "You can use this method to update the values You don't need to override variables. You can change the value of the variable.", "abstract": ""}, {"id": 59137003, "score": 11, "vote": 0, "content": "If you attempt to do that in Swift 5 you will be greeted by a  Cannot override immutable 'let' property 'lightSaberColor' with the getter of a 'var' Your best bet is to declare it as a computed property.  This works as we are just overriding the get {} function", "abstract": ""}, {"id": 41568323, "score": 64, "vote": 0, "content": "For me, your example does not work in Swift 3.0.1. I entered in the playground this code: Throws error at compile time in Xcode: cannot override immutable 'let' property 'lightsaberColor' with the getter of a 'var' No, you can not change the type of stored property. The Liskov Substitution Principle forces you to allow that a subclass is used in a place where the superclass is wanted. But if you change it to var and therefore add the set in the computed property, you can override the stored property with a computed property of the same type. This is possible because it can make sense to switch from stored property to computed property. But override a stored var property with a stored var property does not make sense, because you can only change the value of the property. You can, however, not override a stored property with a stored property at all. I would not say Sith are Jedi :-P. Therefore it is clear that this can not work.", "abstract": ""}, {"id": 54444242, "score": 3, "vote": 0, "content": "I had the same problem to set a constant for a view controller. As I'm using interface builder to manage the view, I cannot use init(), so my workaround was similar to other answers, except I used a read-only computed variable on both base and inherited classes.", "abstract": ""}, {"id": 53200374, "score": 7, "vote": 0, "content": "In Swift, this is unfortunately not possible to do. The best alternative is the following:", "abstract": ""}, {"id": 52822446, "score": 1, "vote": 0, "content": "You also can use a function to override. It's not direct answer, but can enrich this topic) Class A  Class B: A", "abstract": ""}, {"id": 44854617, "score": 10, "vote": 0, "content": "For Swift 4, from Apple's documentation: You can override an inherited instance or type property to provide\n  your own custom getter and setter for that property, or to add\n  property observers to enable the overriding property to observe when\n  the underlying property value changes.", "abstract": ""}, {"id": 42803015, "score": 27, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16061030/must-all-properties-of-an-immutable-object-be-final", "keywords": [], "tags": ["java", "immutability", "final", "java-memory-model"], "question": {"id": 16061030, "title": "Must all properties of an immutable object be final?", "content": "Must immutable objects have all properties be final? I would say they don't. But I don't know whether I am right or not.", "abstract": ""}, "answers": [{"id": 54356252, "score": 0, "vote": 0, "content": "Not necessary, you can achieve same functionality by making member as non-final but private and not modifying them except in constructor. Don't provide setter method for them and if it is a mutable object, then don't ever leak any reference for that member.  Remember making a reference variable final, only ensures that it will not be reassigned a different value, but you can still change individual properties of an object, pointed by that reference variable. This is one of the key points.", "abstract": ""}, {"id": 38525348, "score": 2, "vote": 0, "content": "String class is Immutable but property hash is not final  Well it is possible but with some rules/restrictions and that is access to mutable properties/fields must provide same result every time we access it. In String class hashcode actually calculated on the final array of characters which is not going to change if String has constructed. Therefore immutable class can contain mutable fields/properties but it has to make sure that access to field/property will produce the same result every time it is accessed. To answer your question it is not mandatory to have all the fields final in a immutable class. For further reading visit here [blog] : http://javaunturnedtopics.blogspot.in/2016/07/string-is-immutable-and-property-hash.html", "abstract": ""}, {"id": 16190130, "score": 2, "vote": 0, "content": "No. For example, see the implementation of java.lang.String. Strings are immutable in Java, but the field hash is not final (it is lazily computed the first time hashCode is called and then cached). But this works because hash can take on only one nondefault value that is the same every time it is computed.", "abstract": ""}, {"id": 16061174, "score": 14, "vote": 0, "content": "You can easily guarantee immutability by encapsulation alone, so it's not necessary: However, you also must guarantee it by encapsulation in some cases, so it's not sufficient: It's not a bad idea to do so to catch some trivial errors, and to demonstrate your intent clearly, but \"all fields are final\" and \"the class is immutable\" are not equivalent statements.", "abstract": ""}, {"id": 16061087, "score": 58, "vote": 0, "content": "The main difference between an immutable object (all properties final) and an effectively immutable object (properties aren't final but can't be changed) is safe publication. You can safely publish an immutable object in a multi threaded context without having to worry about adding synchronization, thanks to the guarantees provided by the Java Memory Model for final fields: final fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. final fields must be used correctly to provide a guarantee of immutability.  As a side note, it also enables to enforce immutability (if you try to mutate those fields in a future version of your class because you have forgotten it should be immutable, it won't compile). Clarifications Example of unsafe publication: This program could in theory print What???. If i were final, that would not be a legal outcome.", "abstract": ""}, {"id": 16061166, "score": 5, "vote": 0, "content": "Simply declaring an object as final does not make it inherently immutable. Take for example this class:", "abstract": ""}, {"id": 16061103, "score": 5, "vote": 0, "content": "Immutable objects MUST not be modified in any way after their creation. final of course helps to achieve that. You guarantee that they will not ever be changed. BUT what if you have an array inside your object that is final? Of course the reference is not changable, but the elements are. Look here at almost the same question I gave also: Link", "abstract": ""}, {"id": 16061065, "score": 6, "vote": 0, "content": "Immutable = not changeable. So making properties final is a good idea. If not all properties of an object are protected from being changed I wouldn't say the object is immutable. BUT an object is also immutable if it doesn't provide any setters for it's private properties.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/28410386/in-immutable-class-why-fields-are-marked-as-private", "keywords": [], "tags": ["java", "oop", "field", "private", "immutability"], "question": {"id": 28410386, "title": "In immutable class why fields are marked as private?", "content": "What is the benefit of making fields private while creating an immutable class? I have seen why while creating immutable class, fields are declared as private? but I didn't get understand anything from this post. Can anybody please explain me the same?", "abstract": ""}, "answers": [{"id": 28411003, "score": 12, "vote": 0, "content": "The best way to explain is with an example: Here we have a properly encapsulated, immutable class.  Nothing can change the state (modulo nasty reflective tricks). Now lets JUST change the access on the field: Note we are still making the defensive copy in getState ... as before ... but now someone can do this: ... and our supposedly immutable object's state has changed. That is ONE reason why it is a good idea to keep the fields private.  (Obviously, this only applies to field whose types are mutable reference types.) A SECOND reason is encapsulation.  Declaring fields as private hides implementation details, which reduces the risk of unwanted cross-coupling.  If I don't do this, then I (or some other programmer) might be tempted to write code that depends on the internals of Immutable.  That is going to lead to problems if I need to change them; e.g. changing the type of state to String.  Problems as in \"lots more code to check / change\". A THIRD reason is that non-private (and particularly public) fields can be an impediment to subclassing.  If I declare a field as public then, the I can't undeclare it in a subclass.  If I want to hide the field or modify the behavior of the field in a subclass (by overriding) ... I can't.  By contrast, if the field is private and access is via instance methods, I can override those methods in subclasses.  Or I can choose to not use the field at all.", "abstract": ""}, {"id": 28410546, "score": 3, "vote": 0, "content": "The only reason for making final fields private is binary compatibility, and this actually holds true irrespective of whether the containing class is immutable or not. A class C is said to offer binary compatibility to classes X and Y\n  that use class C if class C can be refactored without having to\n  recompile classes X and Y. You only need to worry about binary compatibility if you are developing a library to be used by software that is written by others and therefore you have no control over.  If you are in this situation, then you pretty much have to use full encapsulation, which means that you have to make all fields private and only access them via getters. However, in the vast majority of cases, what we are developing is top-layer, self-contained application software, not libraries to be used by others.  So, in the vast majority of cases, there is no good reason to make final fields of immutable classes private, it is just a widely held misconception.  In a top-layer, self-contained application scenario you can always refactor everything and your IDE will accordingly refactor all references, so immutable classes do not need encapsulation. Some of the answers suggest that if a field is not private, and it points to a mutable object, then someone might go and modify that mutable object, which is of course correct, but then we go into the philosophical question of what really is an immutable object.  Can an object still be called immutable if it contains mutable objects?  Is the mutability of an object dependent on the mutability of objects that it contains? My rule is as follows:  There are two kinds of fields: contained and referenced, which can otherwise be thought of as owned and unowned. As an example, think of an Employee class: the name of the employee is contained/owned by the class, since each employee has their very own name.  However, the Employee class may also contain a reference to a Department class, and of course each employee does not have their very own department, so the department is a referenced/unowned field. A contained/owned field like Employee.name must of course be final and immutable in order for the owning class (Employee) to be immutable. Such a field does not need to be private, unless we are aiming for binary compatibility.   A referenced/unowned field like Employee.department also needs to be final if the referring class (Employee) is to be immutable, but it does not have to be immutable, and its immutability does not affect the immutability of the referring class. Even in this case, (and unless we are aiming at binary compatibility,) a referenced/unowned field generally does not need to be private, because there is still no issue of encapsulation: we are not going to be making a defensive copy of an employee department, that would be nonsensical. So, unless we are aiming for binary compatibility, then both in the case of contained/owned immutable fields and referenced/unowned fields (which can be either mutable or immutable,) the fields can stay public final and everything will be fine.", "abstract": ""}, {"id": 28412084, "score": 0, "vote": 0, "content": "If you'll use public field other objects will be able to change state of your \"almost-immutable\" object which will break encapsulation and make it a mutable object.", "abstract": ""}, {"id": 28410471, "score": 1, "vote": 0, "content": "An object that is referred to by a public final reference-type field can still be modified through that field. (What you can't do is change the field to refer to a different object.) To disallow unwanted modifications, you need to make the field private.", "abstract": ""}, {"id": 28410575, "score": 1, "vote": 0, "content": "Suppose you have list, and you made this list as final it's reference not modified at all. But this list is easily accessible to outer classes and they are easily modify it's contents.  so prevent that we have to add private access specifier. ", "abstract": ""}, {"id": 28410438, "score": 0, "vote": 0, "content": "Non-private fields may still be read-accessed - and if that field is an object, mutable operations on that object may be invoked. Making the fields private will prevent this possibility.", "abstract": ""}, {"id": 28410437, "score": 0, "vote": 0, "content": "public fields can be accessed from any class anywhere and modified. But making fields private and final and using constructor injection / defensive copies, you ensure that the class is completely immutable.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/17603412/how-can-serialisation-deserialisation-break-immutability", "keywords": [], "tags": ["java"], "question": {"id": 17603412, "title": "How can serialisation/deserialisation break immutability?", "content": "I was asked this question in an interview. The interviewer wanted to know how to make an object immutable. and then he asked what if I serialise this object - will it break immutability? If yes, how do I prevent it? Can anyone please help me understand this?", "abstract": ""}, "answers": [{"id": 56852294, "score": 0, "vote": 0, "content": "You can prevent from serialization or cloning with the help of SecurityManager in java }", "abstract": ""}, {"id": 17604213, "score": 5, "vote": 0, "content": "You should read Effective Java written by Joshua Bloch. There is whole chapter about security issues connected with serialization and advices how to design your class properly. In few words: you should learn about readObject and readResolve methods. More detailed answer:\nYes serialization can break immutability. Let's assume you have class Period (it's example from Joshua's book): It looks great. It's immutable (you can't change start and end after initialization), elegant, small, threadsafe etc. But... You have to remember that serialization is another way of creating objects (and it is not using constructors). Objects are build from byte stream.  Consider scenario when someone (attacker) change your serialization byte array. If he does such thing he could break your condition about start < end. Moreover there is possibility that attacker will put in stream (passed to deserialization method) reference to his Date object (which is mutable and Period class immutability will be completely destructed). The best defense is not using serialization if you don't have to.\nIf you have to serialize your class use Serialization Proxy pattern. Edit (at kurzbot request):\nIf you want to use Serialization Proxy you have to add static inner class inside Period. This class objects will be used for serialization instead of Period class objects. In Period class write two new methods: First method replace default serialized Period object with SerializationProxy object. Second guarantee that attacker won't use standard readObject method. You should write writeObject method for SerializationProxy so you can use: In that case you are using only public API and have certainty that Period class will remain immutably.", "abstract": ""}, {"id": 17605233, "score": 0, "vote": 0, "content": "The dirt-simple answer is The field foo will equals \"foo\" if the object is newly created, but will be null when deserialized (and without resorting to dirty tricks, you won't be able to assign it).", "abstract": ""}, {"id": 17604645, "score": 1, "vote": 0, "content": "As others have said, one could make the argument that serialization results in a brand new object, which is then immutable, so no, serialization doesn't break it, but I think there's a bigger picture to immutability we have to consider before answering that question. I think the real answer depends completely on the class being serialized, and the level of immutability required, but since the interviewer failed to give us source code, I will come up with my own.  I'd also like to point out that, as soon as people start talking about immutability, they start throwing around the final keyword - yes, that makes a reference immutable, but it's not the only way to achieve immutability.  Okay, let's look at some code: Is this class mutable because I implemented Serializable?  Is it mutable because I didn't use the final keyword?  No way - it's immutable in every practical sense of the word, because I'm not going to modify the source code (even if you ask me to nicely), but more importantly, it's immutable because no outside class can change the value of value, short of using Reflection to make it public and then modifying it.  By that token, I suppose you could run some intermediary hex editor and manually modify the value in RAM too, but that doesn't make it any more mutable than it was before.  Extending classes can't modify it either.  Sure, you can extend it and then override getValue() to return something different, but doing so will not have changed the underlying value. I know this might rub a lot of people the wrong way, but it's my opinion that immutability is often purely semantic - e.g. is it immutable to someone calling your code from an outside class, or is it immutable from someone using BusPirate on your motherboard? There are VERY good reasons to use final to help ensure immutability, but I think it's importance is vastly overstated in more than a few arguments.  Just because the JVM is allowed to do some magic under the hood to ensure Serialization works doesn't mean the level of immutability your application requires is somehow broken.", "abstract": ""}, {"id": 17603631, "score": 1, "vote": 0, "content": "Make it immutable by keeping all state information in a form where it can not be changed after the object is created.  Java does not allow perfect immutability in some cases. Serializable is something that you can do but it isn't perfect because there has to be a way to recreate an exact copy of an object when deserializing and it may not be sufficient to use the same constructors to deserialize and to create the object in the first place. That leaves a hole. Some things to do: Some other things to think about: The simple answer is that in most cases, just follow the two rules at the top of this answer and that will be good enough to handle your needs for immutability.", "abstract": ""}, {"id": 17603494, "score": 4, "vote": 0, "content": "When you serialize an object graph that has multiple references to the same object, the serializer notes this fact, so that the deserialized object graph has the same structure. For example, will print true, and if you serialized and deserialized twoArrays then you would get the same result instead of each element of the array being a different object as in You can exploit this support for reference sharing to craft bytes after a serialized entry to share a reference with a privately help object or array, and then mutate it. So an unserializable class can maintain invariants -- that a privately held object does not escape -- that a serializable class cannot maintain.", "abstract": ""}, {"id": 17603455, "score": 10, "vote": 0, "content": "An immutable object is one which cannot be changed once created.  You can create such an object by using private access modifiers, and the final keyword. If an immutable object was serialized, its raw bytes could be modified so that upon deserialization the object is no longer the same. This can't be prevented completely.  Encryption, checksums, and CRC's will help to prevent this though.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/13649584/immutable-class-object-private-constructor-factory-method", "keywords": [], "tags": ["java", "singleton", "immutability"], "question": {"id": 13649584, "title": "Immutable class/object, private Constructor, factory method", "content": "Having already read how to make a class Immutable by following steps  AM not sure I clearly understand the utility of private constructor and factory method in the context of immutability. If I make class final, basically am closing all paths of any other class extending it. How is the stated a more sophisticated approach I have seen private constructor,factory method in Singleton pattern which makes sense. But when we talk of object immutability, are we also restricting object construction/instantiation when we mention private constructor and static factory methods??", "abstract": ""}, "answers": [{"id": 50551996, "score": 3, "vote": 0, "content": "After thoroughly reading the below point Dont allow subclass to over ride methods. The simplest way to do this is to declare the class final. A more sophisticated approach is to make constructor private and construct instances in factory method. I think the point here is not  Making class final and private constructor. The point is  Either you make your class final or have a private constructor. Hope it helps!! source", "abstract": ""}, {"id": 14632919, "score": 0, "vote": 0, "content": "The idea behind the private constructor is that you want to hide the immutable implementation of the class data whilst allowing construction of a new instance with different data of the same internal type. For example Ignoring the semi stupidity of the example, if your requirements are that the class can be constructed from a string representing the temperature. The way it actually stores the temperature is subject to change and is an implementation detail. This class can be changed to use floats, strings, doubles, ints etc. This method maintains immutability whilst allowing flexibility on implementation. Obviously this becomes much more powerful when you are wrapping more complex objects such as collections, dictionaries etc.", "abstract": ""}, {"id": 13650403, "score": 2, "vote": 0, "content": "I think the big issue here is future refactoring. Suppose, in a later version, you find it would make something much simpler if you could split out some new special case of MyClass into a subclass, MySpecialClass. If MyClass were a mutable class with a public constructor, you could just do it and tell users of the new features to create a new MySpecialClass. Existing uses are not affected. If MyClass has a private constructor and a factory method, there is no problem. You declare MySpecialClass nested in MyClass, also with a private constructor. Add and/or modify the factory methods to choose which to create, but make sure existing calls go on working compatibly. What would you do if MyClass were immutable, and final, but had a public constructor?", "abstract": ""}, {"id": 13650463, "score": 1, "vote": 0, "content": "Some of my own findings from Effective Java Item 15, pasting relevant statements from the same \"Recall that\nto guarantee immutability, a class must not permit itself to be subclassed.\nTypically this is done by making the class final, but there is another, more flexible\nway to do it. The alternative to making an immutable class final is to make all of\nits constructors private or package-private, and to add public static factories in\nplace of the public constructors (Item 1). While this approach is not commonly used, it is often the best alternative. It is\nthe most flexible because it allows the use of multiple package-private implementation\nclasses. To its clients that reside outside its package, the immutable class is\neffectively final because it is impossible to extend a class that comes from another\npackage and that lacks a public or protected constructor. Besides allowing the\nflexibility of multiple implementation classes, this approach makes it possible to\ntune the performance of the class in subsequent releases by improving the objectcaching\ncapabilities of the static factories. \" static factory vs constructor advantages are then discussed", "abstract": ""}, {"id": 13650248, "score": 1, "vote": 0, "content": "IMMUTABILITY - Very helpful for concurrency as it avoids creation of various invariant that are possible in threading environment. FACTORY METHODS - Just a naming convention, as they are more verbose to read and easy to understand from their custom name. For example: copyOf() method would make more sense than creating a copy constructor. As said by Joshua Bloch in Effective Java PRIVATE CONSTRUCTORS - They have their own uses in patterns like Singleton, but have their own limitations.", "abstract": ""}, {"id": 13649871, "score": 4, "vote": 0, "content": "Firstly, there are several reasons why immutable class generally should not be overriden, you can find them here. That said, making a constructor private is just one way to prevent class from being overriden. Why? Because in sub-class, every constructor (implicitly) calls super(), a default constructor of base class. But if you make this constructor private, sub-class cannot call it and thus cannot override the base class. This approach is very suitable when you want to control the total number of instances of particular class, for example in case of singletons.", "abstract": ""}, {"id": 13649772, "score": 0, "vote": 0, "content": "That is because with private constructor we can not make a subclass of it, and thus restricting all paths of any other class extending it. It is sophisticated because it has its own limitations/complications like in singleton pattern.", "abstract": ""}, {"id": 13649769, "score": 1, "vote": 0, "content": "Yeah, you are right. It does not make any sense to make constructor private. By doing this, we are restricting the instance creation, which is not a desired scenario for immutability. In example mentioned in sun site does not make constructor private\nhttp://docs.oracle.com/javase/tutorial/essential/concurrency/syncrgb.html", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11320970/immutable-subclasses", "keywords": [], "tags": ["java", "immutability"], "question": {"id": 11320970, "title": "Immutable subclasses", "content": "I'm currently developping a multithreaded framework. To avoid side effects, I would like to require that all data manipulated by the framewok has to be immutable. So does a way exist in Java to specify I want all subclasses of a given class or all classes implementing a given interface to be immutable?", "abstract": ""}, "answers": [{"id": 11335866, "score": 1, "vote": 0, "content": "To make a class truly immmutable, all members of the class must be immutable and the class itself must be final. This ensures the object cannot be changed from within the class or outside of the class. To make members inside the class immutable, this means more than just making them final. For example strings is final but can still be changed because items can be added and removed from the list. In this case, you could wrap it in an unmodifiable collection. Even this is not perfect though because the objects in your list could be mutable (Strings are not obviously, but your list might have mutable objects in them where you could do list.get(index).mutator(...)) There is no silver bullet as to how to make an object immutable. If it provides any methods that mutate the object, then it cannot be immutable. As for making a class final, to achieve guaranteed immutability this necessary. Imagine the case, There is no guarantee that doSomething is actually dealing with an immutable instance but rather it could be dealing with a mutable subclass. As you can see, this would pose a problem for working with interfaces. There is no way to guarantee that an implementor of an interface is immutable. The @Immutable annotation does not guarantee immutability, but rather just states that the class is telling you it is immutable, but there is no good way to enforce that. If you are able to work in groovy the @Immutable annotation has some effect as it does a lot of these techniques above that I mentioned. http://groovy.codehaus.org/Immutable+AST+Macro", "abstract": ""}, {"id": 11335713, "score": 3, "vote": 0, "content": "I recommend looking into Mutability Detector. It performs static analysis to determine if a given class is immutable. It could be used to add something akin to a runtime assertion, i.e. you could choose to throw an exception if you are passed an instance of a mutable class. Note that it could analyse the actual, concrete class at runtime, including subclasses or implementations of an interface that you have defined. It is still a pre-1.0 release, and has issues with java.lang.String, but it could be usable. If it's close to what you're looking for, but doesn't quite do what you want, I recommend contacting the mailing list or filing a bug report, as I believe the project maintainer is quite a reasonable guy. Disclaimer: that maintainer is me ;-)", "abstract": ""}, {"id": 11320990, "score": 2, "vote": 0, "content": "There is no way to require immutability of subclasses. You can make sure that subclasses of your classes do not mutate your state by not providing setters and keeping your instance variables private, but if subclasses declare their own instance variables, they have full control over them. As far as interfaces go, the only thing you can do is to not provide setters. However, implementations can provide setters of their own.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/753375/creating-immutable-objects-from-javabean", "keywords": [], "tags": ["java", "immutability", "javabeans"], "question": {"id": 753375, "title": "Creating immutable objects from javabean", "content": "I am involved in this project where we are building on good bit of legacy code. I have a particular situation about one big java bean object which has to be transferred over wire. So my first thought was to make it immutable and serializable to do the trick .At this point I am faced with a few difficult choices :- Ideally I want some way to\nautomatically generate an immutable,\nserializable version of this class.\nI dont have the scope to refactor or\nalter this class in any way and i\nwould really really hate to have to\ncopy paste the class with a\ndifferent name ? Assuming that i gave up on 1 i.e i\nactually chose to duplicate code of\nthe HUGE javabean class , i still\nwill be in the unsavoury situation\nof having to write a constructor\nwith some 20-25 parameters to make\nthis class immutable. what is a\nbetter way to make a class immutable\nother than constructor injection ? Thanks and Regards,", "abstract": ""}, "answers": [{"id": 2511720, "score": 1, "vote": 0, "content": "What about a simple read only interface cotaining the getters? If the bean class is your own, let it simpley implement the interface and use just the interface after creation. If you have no control over the bean class, you can also create a getter interface and implement it by creating a proxy for the getter interface with an invokation handler delegating all method calls to the bean.", "abstract": ""}, {"id": 2511673, "score": 4, "vote": 0, "content": "Joshua Bloch's \"Effective Java\" illustrates the Builder pattern, where simple Builder objects are used to construct a complex object with a long constructor argument list. I'd recommend it. http://www.drdobbs.com/java/208403883;jsessionid=PJWS41F5DJ4QRQE1GHRSKH4ATMY32JVN?pgno=2 ", "abstract": ""}, {"id": 756889, "score": 0, "vote": 0, "content": "A few ideas: Protected setters and factory methods\nYou can define beans with protected setter methods and in the same package, a factory class that takes all the parameters and calls those setters. The bean is immutable outside that package. To enforce this, be sure to seal your jar so end users cannot create new classes in the same package. Note: You can use my JavaDude Bean annotations to make the creation simpler:\nhttp://code.google.com/p/javadude/wiki/Annotations For example: Creating getters and a constructor in eclipse Eclipse has some nice tools to make this fast: Immutability Decorator Another idea is to define your bean with getters and setters (you can use the above technique but include setters), then you can create a wrapper class for it that only has the getters.", "abstract": ""}, {"id": 754220, "score": 0, "vote": 0, "content": "Step 1: Create a new class and give it instance variables with the exact same names as the instance variables of your 'big java bean object'.  That new class should not have setters (but getters only) to make it immutable. Step 2: Use Apache Commons BeanUtils.copyProperties to copy all the properties (i.e. instance variables) from your 'big java bean object' to your new object.", "abstract": ""}, {"id": 753508, "score": 1, "vote": 0, "content": "20-25 properties is not huge for a one off, particularly if you are using a half-decent editor. If you already have a mutable instance when constructing the immutable version, just pass that to the constructor. If you want to be really evil hacky, use java.beans to create a serialisable Map for the mutable class or subclass implementing Externalizable. Alternatively you could use java.beans XML serialisation (the XML than can be sent over Java serialisation...).", "abstract": ""}, {"id": 753457, "score": 4, "vote": 0, "content": "To make it truly immutable, you need to initialize the members at construction time.  One way (and I ain't sayin' it's pretty!) to do this and avoid a huge parameter list in the constructor is to have a mutable type that has the same properties. Set the the properties on the mutable type one at a time, through \"setters\", then pass the mutable object to the constructor of the immutable type as a single argument. The immutable object then copies the properties from the mutable source to it's own (final) members. You might also consider \"effective immutability\". That is, even though immutability is not enforced by the system, you use coding practices that clearly separate the initialization phase from the usage phase. After all, immutability is not required for serialization. You can take this a step further, creating an implementation-hiding wrapper for the interface that doesn't expose the properties of the implementation. The wrapper only implements the methods in the interface, by delegating to the \"real\" implementation. The setters and getters from the implementation are not present in the wrapper. This will stop clients from simply down-casting from the interface to the implementation class and manipulating the properties.", "abstract": ""}]}]