[{"link": "https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-represents-a-number-float-or-int", "keywords": [], "tags": ["python", "casting", "floating-point", "type-conversion"], "question": {"id": 354038, "title": "How do I check if a string represents a number (float or int)?", "content": "How do I check if a string represents a numeric value in Python? The above works, but it seems clunky. If what you are testing comes from user input, it is still a string even if it represents an int or a float. See How can I read inputs as numbers? for converting the input, and Asking the user for input until they give a valid response for ensuring that the input represents an int or float (or other requirements) before proceeding.", "abstract": ""}, "answers": [{"id": 75713058, "score": 0, "vote": 0, "content": "My short answer is:\nmay be duplicated one, sorry for that\n...\ndef is_float(s):\nif s.isdigit():\nreturn False\ntry:\nfloat(s)\nreturn True\nexcept Exception as e:\nreturn False", "abstract": ""}, {"id": 23639915, "score": 295, "vote": 0, "content": "TL;DR The best solution is s.replace('.','',1).isdigit() I did some benchmarks comparing the different approaches If the string is not a number, the except-block is quite slow. But more importantly, the try-except method is the only approach that handles scientific notations correctly. Float notation \".1234\" is not supported by: is_number_regex scientific1 = '1.000000e+50'\nscientific2 = '1e50' print('Scientific notation \"1.000000e+50\" is not supported by:')\nfor f in funcs:\nif not f(scientific1):\nprint('\\t -', f.name) print('Scientific notation \"1e50\" is not supported by:')\nfor f in funcs:\nif not f(scientific2):\nprint('\\t -', f.name) Scientific notation \"1.000000e+50\" is not supported by: where the following functions were tested ", "abstract": ""}, {"id": 74580030, "score": 1, "vote": 0, "content": "There are already good answers in this post. I wanted to give a slightly different perspective. Instead of searching for a digit, number or float we could do a negative search for an alphabet. i.e. we could ask the program to look if it is not alphabet. It will work well if you are sure that your string is a well formed number (Condition 1 and Condition 2 below). However it will fail if the string is not a well formed number by mistake. In such a case it will return a number match even if the string was not a valid number. To take care of this situation, there are many rule based methods must be there. However at this moment, regex comes to my mind. Below are three cases. Please note regex can be much better since I am not a regex expert. Below there are two lists: one for valid numbers and one for invalid numbers. Valid numbers must be picked up while the invalid numbers must not be. == Condition 1: String is guranteed to be a valid number but 'inf' is not picked == == Condition 2: String is guranteed to be a valid number and  'inf' is picked == == Condition 3: String is not guranteed to be a valid number ==", "abstract": ""}, {"id": 354073, "score": 1739, "vote": 0, "content": "For non-negative (unsigned) integers only, use isdigit(): Documentation for isdigit(): Python2, Python3 For Python 2 Unicode strings:\nisnumeric().", "abstract": ""}, {"id": 70597776, "score": 0, "vote": 0, "content": "One fast and simple option is to check the data type: Or if you want to test if the values os a string are numeric: tests:", "abstract": ""}, {"id": 68780861, "score": 1, "vote": 0, "content": "I know I'm late to the party, but figured out a solution which wasn't here:\nThis solution follows the EAFP principle in Python Explanation: If the value in the string is a float and I first try to parse it as an int, it will throw a ValueError. So, I catch that error and parse the value as float and return.", "abstract": ""}, {"id": 68410683, "score": 0, "vote": 0, "content": "For my very simple and very common use-case: is this human written string with keyboard a number? I read through most answers, and ended up with: It will return False for (+-)NaN and (+-)inf. You can check it out here: https://trinket.io/python/ce32c0e54e", "abstract": ""}, {"id": 66309594, "score": 0, "vote": 0, "content": "Sorry for the Zombie thread post - just wanted to round out the code for completeness... Gimme any number: +42.42e-42j Is it a number? True", "abstract": ""}, {"id": 48729739, "score": 32, "vote": 0, "content": "This answer provides step by step guide having function with examples to find the string is: You may use str.isdigit() to check whether given string is positive integer. Sample Results: str.isdigit() returns False if the string is a negative number or a float number. For example: If you want to also check for the negative integers and float, then you may write a custom function to check for it as: Sample Run: The above functions will return True for the \"NAN\" (Not a number) string because for Python it is valid float representing it is not a number. For example: In order to check whether the number is \"NaN\", you may use math.isnan() as: Or if you don't want to import additional library to check this, then you may simply check it via comparing it with itself using ==. Python returns False when nan float is compared with itself. For example: Hence, above function is_number can be updated to return False for \"NaN\" as: Sample Run: PS: Each operation for each check depending on the type of number comes with additional overhead. Choose the version of is_number function which fits your requirement.", "abstract": ""}, {"id": 65164407, "score": 8, "vote": 0, "content": "In a most general case for a float, one would like to take care of integers and decimals. Let's take the string \"1.1\" as an example. I would try one of the following: 1.>  isnumeric() 2.>  isdigit() 3.>  isdecimal() Speed: \u25ba All the aforementioned methods have similar speeds.", "abstract": ""}, {"id": 61239204, "score": 7, "vote": 0, "content": "str.isnumeric() Return True if all characters in the string are numeric characters,\n  and there is at least one character, False otherwise. Numeric\n  characters include digit characters, and all characters that have the\n  Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE\n  FIFTH. Formally, numeric characters are those with the property value\n  Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric. str.isdecimal() Return True if all characters in the string are decimal characters and\n  there is at least one character, False otherwise. Decimal characters\n  are those that can be used to form numbers in base 10, e.g. U+0660,\n  ARABIC-INDIC DIGIT ZERO. Formally a decimal character is a character\n  in the Unicode General Category \u201cNd\u201d. Both available for string types from Python 3.0. ", "abstract": ""}, {"id": 61014322, "score": 1, "vote": 0, "content": "", "abstract": ""}, {"id": 56084922, "score": 5, "vote": 0, "content": "I think your solution is fine, but there is a correct regexp implementation. There does seem to be a lot of regexp hate towards these answers which I think is unjustified, regexps can be reasonably clean and correct and fast.  It really depends on what you're trying to do.  The original question was how can you \"check if a string can be represented as a number (float)\" (as per your title).  Presumably you would want to use the numeric/float value once you've checked that it's valid, in which case your try/except makes a lot of sense.  But if, for some reason, you just want to validate that a string is a number then a regex also works fine, but it's hard to get correct.  I think most of the regex answers so far, for example, do not properly parse strings without an integer part (such as \".7\") which is a float as far as python is concerned.  And that's slightly tricky to check for in a single regex where the fractional portion is not required.  I've included two regex to show this. It does raise the interesting question as to what a \"number\" is.  Do you include \"inf\" which is valid as a float in python?  Or do you include numbers that are \"numbers\" but maybe can't be represented in python (such as numbers that are larger than the float max). There's also ambiguities in how you parse numbers.  For example, what about \"--20\"?  Is this a \"number\"?  Is this a legal way to represent \"20\"?  Python will let you do \"var = --20\" and set it to 20 (though really this is because it treats it as an expression), but float(\"--20\") does not work. Anyways, without more info, here's a regex that I believe covers all the ints and floats as python parses them. Some example test values: Running the benchmarking code in @ron-reiter's answer shows that this regex is actually faster than the normal regex and is much faster at handling bad values than the exception, which makes some sense.  Results:", "abstract": ""}, {"id": 57516860, "score": 1, "vote": 0, "content": "User helper function: then ", "abstract": ""}, {"id": 354130, "score": 772, "vote": 0, "content": "Which, not only is ugly and slow I'd dispute both. A regex or other string parsing method would be uglier and slower.   I'm not sure that anything much could be faster than the above.  It calls the function and returns.  Try/Catch doesn't introduce much overhead because the most common exception is caught without an extensive search of stack frames. The issue is that any numeric conversion function has two kinds of results C (as an example) hacks around this a number of ways.  Python lays it out clearly and explicitly. I think your code for doing this is perfect.", "abstract": ""}, {"id": 52676692, "score": 9, "vote": 0, "content": "The input may be as follows: a=\"50\"\nb=50\nc=50.1\nd=\"50.1\" The input of this function can be everything! Finds whether the given variable is numeric. Numeric strings consist of optional sign, any number of digits, optional decimal part and optional exponential part. Thus +0123.45e6 is a valid numeric value. Hexadecimal (e.g. 0xf4c3b00c) and binary (e.g. 0b10100111001) notation is not allowed. is_numeric function test: is_float function Finds whether the given variable is float. float strings consist of optional sign, any number of digits, ... test: what is ast? use str.isdigit() method detect int value: detect float:", "abstract": ""}, {"id": 53800165, "score": 2, "vote": 0, "content": "This code handles the exponents, floats, and integers, wihtout using regex.", "abstract": ""}, {"id": 51652091, "score": 2, "vote": 0, "content": "", "abstract": ""}, {"id": 14352314, "score": 9, "vote": 0, "content": "I wanted to see which method is fastest. Overall the best and most consistent results were given by the check_replace function. The fastest results were given by the check_exception function, but only if there was no exception fired - meaning its code is the most efficient, but the overhead of throwing an exception is quite large. Please note that checking for a successful cast is the only method which is accurate, for example, this works with check_exception but the other two test functions will return False for a valid float: Here is the benchmark code: Here are the results with Python 2.7.10 on a 2017 MacBook Pro 13: Here are the results with Python 3.6.5 on a 2017 MacBook Pro 13: Here are the results with PyPy 2.7.13 on a 2017 MacBook Pro 13:", "abstract": ""}, {"id": 49343274, "score": -2, "vote": 0, "content": "I have a similar problem. Instead of defining a isNumber function, I want to convert a list of strings to floats, something that in high-level terms would be: It is a given we can not really separate the float(s) from the isFloat(s) functions: these two results should be returned by the same function. \nAlso, if float(s) fails, the whole process fails, instead of just ignoring the faulty element. Plus, \"0\" is a valid number and should be included in the list. When filtering out bad elements, be certain not to exclude 0. Therefore, the above comprehension must be modified somehow to: I propose a solution inspired in the Nullable numerical types of C#. These types are internally represented by a struct that has the numerical value and adds a boolean indicating if the value is valid:", "abstract": ""}, {"id": 25299619, "score": 17, "vote": 0, "content": "For strings of non-numbers, try: except: is actually slower than regular expressions.  For strings of valid numbers, regex is slower.  So, the appropriate method depends on your input.  If you find that you are in a performance bind, you can use a new third-party module called fastnumbers that provides a function called isfloat.  Full disclosure, I am the author.  I have included its results in the timings below. As you can see", "abstract": ""}, {"id": 34615173, "score": 15, "vote": 0, "content": "I know this is particularly old but I would add an answer I believe covers the information missing from the highest voted answer that could be very valuable to any who find this: For each of the following methods connect them with a count if you need any input to be accepted. (Assuming we are using vocal definitions of integers rather than 0-255, etc.) x.isdigit()\nworks well for checking if x is an integer. x.replace('-','').isdigit()\nworks well for checking if x is a negative.(Check - in first position) x.replace('.','').isdigit()\nworks well for checking if x is a decimal. x.replace(':','').isdigit()\nworks well for checking if x is a ratio. x.replace('/','',1).isdigit()\nworks well for checking if x is a fraction.", "abstract": ""}, {"id": 42437198, "score": -3, "vote": 0, "content": "use following it handles all cases:-", "abstract": ""}, {"id": 40064255, "score": 1, "vote": 0, "content": "I also used the function you mentioned, but soon I notice that strings as \"Nan\", \"Inf\" and it's variation are considered as number. So I propose you improved version of your function, that will return false on those type of input and will not fail \"1e3\" variants:", "abstract": ""}, {"id": 3335060, "score": 48, "vote": 0, "content": "Updated after Alfe pointed out you don't need to check for float separately as complex handles both: Previously said: Is some rare cases you might also need to check for complex numbers (e.g. 1+2i), which can not be represented by a float:", "abstract": ""}, {"id": 32453110, "score": 34, "vote": 0, "content": "For int use this: But for float we need some tricks ;-). Every float number has one point... Also for negative numbers just add lstrip(): And now we get a universal way:", "abstract": ""}, {"id": 30549042, "score": 0, "vote": 0, "content": "Try this.", "abstract": ""}, {"id": 26829047, "score": 3, "vote": 0, "content": "I was working on a problem that led me to this thread, namely how to convert a collection of data to strings and numbers in the most intuitive way.  I realized after reading the original code that what I needed was different in two ways: 1 - I wanted an integer result if the string represented an integer 2 - I wanted a number or a string result to stick into a data structure so I adapted the original code to produce this derivative:", "abstract": ""}, {"id": 24559671, "score": 5, "vote": 0, "content": "I needed to determine if a string cast into basic types (float,int,str,bool). After not finding anything on the internet I created this: Example You can capture the type and use it ", "abstract": ""}, {"id": 17926244, "score": 3, "vote": 0, "content": "RyanN suggests If you want to return False for a NaN and Inf, change line to x = float(s); return (x == x) and (x - 1 != x). This should return True for all floats except Inf and NaN But this doesn't quite work, because for sufficiently large floats, x-1 == x returns true. For example, 2.0**54 - 1 == 2.0**54", "abstract": ""}, {"id": 16743970, "score": 0, "vote": 0, "content": "You can generalize the exception technique in a useful way by returning more useful values than True and False.  For example this function puts quotes round strings but leaves numbers alone.  Which is just what I needed for a quick and dirty filter to make some variable definitions for R. ", "abstract": ""}, {"id": 10762002, "score": 66, "vote": 0, "content": "how about this: which will return true only if there is one or no '.' in the string of digits. will return false edit: just saw another comment ...\nadding a .replace(badstuff,'',maxnum_badstuff) for other cases can be done. if you are passing salt and not arbitrary condiments (ref:xkcd#974) this will do fine :P", "abstract": ""}, {"id": 15205926, "score": 11, "vote": 0, "content": "You can use Unicode strings, they have a method to do just what you want: Or: http://www.tutorialspoint.com/python/string_isnumeric.htm http://docs.python.org/2/howto/unicode.html", "abstract": ""}, {"id": 9842626, "score": 9, "vote": 0, "content": "So to put it all together, checking for Nan, infinity and complex numbers (it would seem they are specified with j, not i, i.e. 1+2j) it results in:", "abstract": ""}, {"id": 9337733, "score": 14, "vote": 0, "content": "In C# there are two different functions that handle parsing of scalar values: float.parse(): Note: If you're wondering why I changed the exception to a TypeError, here's the documentation. float.try_parse(): Note: You don't want to return the boolean 'False' because that's still a value type. None is better because it indicates failure. Of course, if you want something different you can change the fail parameter to whatever you want. To extend float to include the 'parse()' and 'try_parse()' you'll need to monkeypatch the 'float' class to add these methods. If you want respect pre-existing functions the code should be something like: SideNote: I personally prefer to call it Monkey Punching because it feels like I'm abusing the language when I do this but YMMV. Usage: And the great Sage Pythonas said to the Holy See Sharpisus, \"Anything you can do I can do better; I can do anything better than you.\"", "abstract": ""}, {"id": 3912515, "score": 4, "vote": 0, "content": "I did some speed test. Lets say that if the string is likely to be a number the try/except strategy is the fastest possible.If the string is not likely to be a number and you are interested in Integer check, it worths to do some test (isdigit plus heading '-'). \nIf you are interested to check float number, you have to use the try/except code whitout escape.", "abstract": ""}, {"id": 3618897, "score": 82, "vote": 0, "content": "There is one exception that you may want to take into account: the string 'NaN' If you want is_number to return FALSE for 'NaN' this code will not work as Python converts it to its representation of a number that is not a number (talk about identity issues): Otherwise, I should actually thank you for the piece of code I now use extensively. :) G.", "abstract": ""}, {"id": 1139186, "score": 1, "vote": 0, "content": "Here's my simple way of doing it. Let's say that I'm looping through some strings and I want to add them to an array if they turn out to be numbers. Replace the myvar.apppend with whatever operation you want to do with the string if it turns out to be a number. The idea is to try to use a float() operation and use the returned error to determine whether or not the string is a number.", "abstract": ""}, {"id": 358479, "score": 45, "vote": 0, "content": "Which, not only is ugly and slow, seems clunky. It may take some getting used to, but this is the pythonic way of doing it.  As has been already pointed out, the alternatives are worse.  But there is one other advantage of doing things this way:  polymorphism. The central idea behind duck typing is that \"if it walks and talks like a duck, then it's a duck.\"  What if you decide that you need to subclass string so that you can change how you determine if something can be converted into a float?  Or what if you decide to test some other object entirely?  You can do these things without having to change the above code. Other languages solve these problems by using interfaces.  I'll save the analysis of which solution is better for another thread.  The point, though, is that python is decidedly on the duck typing side of the equation, and you're probably going to have to get used to syntax like this if you plan on doing much programming in Python (but that doesn't mean you have to like it of course). One other thing you might want to take into consideration: Python is pretty fast in throwing and catching exceptions compared to a lot of other languages (30x faster than .Net for instance).  Heck, the language itself even throws exceptions to communicate non-exceptional, normal program conditions (every time you use a for loop).  Thus, I wouldn't worry too much about the performance aspects of this code until you notice a significant problem.", "abstract": ""}, {"id": 354134, "score": 12, "vote": 0, "content": "Casting to float and catching ValueError is probably the fastest way, since float() is specifically meant for just that. Anything else that requires string parsing (regex, etc) will likely be slower due to the fact that it's not tuned for this operation. My $0.02.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/961632/convert-integer-to-string-in-python", "keywords": [], "tags": ["python", "string", "integer"], "question": {"id": 961632, "title": "Convert integer to string in Python", "content": "How do I convert an integer to a string? For the reverse, see How do I parse a string to a float or int?. Floats can be handled similarly, but handling the decimal points can be tricky because floating-point values are not precise. See Converting a float to a string without rounding it for more specific advice.", "abstract": ""}, "answers": [{"id": 75495036, "score": 0, "vote": 0, "content": "You can also call format(): If you want to add a thousands separator: or to convert to string representation of floats For a \"European\" separator:", "abstract": ""}, {"id": 961638, "score": 2317, "vote": 0, "content": "Links to the documentation: str(x) converts any object x to a string by calling x.__str__(), or repr(x) if x doesn't have a __str__() method.", "abstract": ""}, {"id": 961652, "score": 69, "vote": 0, "content": "There is no typecast and no type coercion in Python. You have to convert your variable in an explicit way. To convert an object into a string you use the str() function. It works with any object that has a method called __str__() defined. In fact is equivalent to The same if you want to convert something to int, float, etc.", "abstract": ""}, {"id": 65207539, "score": 1, "vote": 0, "content": "There are several ways to convert an integer to string in python.\nYou can use [ str(integer here) ] function, the f-string  [ f'{integer here}'], the .format()function [ '{}'.format(integer here) and even the '%s'% keyword [ '%s'% integer here]. All this method can convert an integer to string. See below example", "abstract": ""}, {"id": 62712547, "score": 0, "vote": 0, "content": "Here is a simpler solution: In the above program, int() is used to convert the string representation of an integer. Note: A variable in the format of string can be converted into an integer only if the variable is completely composed of numbers. In the same way, str() is used to convert an integer to string. I used a list to print the output to highlight that variable (a) is a string. But to understand the difference how a list stores a string and integer, view the below code first and then the output.", "abstract": ""}, {"id": 56754728, "score": 14, "vote": 0, "content": "For Python 3.6, you can use the f-strings new feature to convert to string and it's faster compared to str() function. It is used like this: Python provides the str() function for that reason. For a more detailed answer, you can check this article: Converting Python Int to String and Python String to Int", "abstract": ""}, {"id": 47751397, "score": 8, "vote": 0, "content": "You can use %s or .format: Or:", "abstract": ""}, {"id": 56301633, "score": 5, "vote": 0, "content": "With the introduction of f-strings in Python 3.6, this will also work: It is actually faster than calling str(), at the cost of readability. In fact, it's faster than %x string formatting and .format()!", "abstract": ""}, {"id": 961661, "score": 20, "vote": 0, "content": "To manage non-integer inputs:", "abstract": ""}, {"id": 51444152, "score": 13, "vote": 0, "content": "In Python => 3.6 you can use f formatting:", "abstract": ""}, {"id": 48697636, "score": 7, "vote": 0, "content": "For someone who wants to convert int to string in specific digits, the below method is recommended. For more details, you can refer to Stack Overflow question Display number with leading zeros.", "abstract": ""}, {"id": 961641, "score": 18, "vote": 0, "content": "", "abstract": ""}, {"id": 30063942, "score": 8, "vote": 0, "content": "The most decent way in my opinion is ``.", "abstract": ""}, {"id": 961636, "score": 150, "vote": 0, "content": "Try this:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/74732097/python-converting-a-9-digit-integer-into-a-string-with-the-format-of-xxx-xx-x", "keywords": [], "tags": ["python", "string", "integer"], "question": {"id": 74732097, "title": "Python - Converting a 9 digit integer into a string with the format of &quot;xxx-xx-xxxx&quot;", "content": "I was working on some practice problems for a python course i am in and I was a little lost on one of the questions. The task seems relatively simple: Create a solution that accepts an integer input representing a 9-digit unformatted student identification number. Output the identification number as a string with no spaces. The solution should be in the format: 111-22-3333. So if the input is \"154175430\" then the expected output is \"154-17-5430\". This seems pretty straightforward, however once i looked at the initial coding comments they gave us to start the program, the first line of comment read: This hint is what really tripped me up. I was just wondering how or why you would use a modulo or floored division if you are just converting an integer to a string? I assume it has to do with the formatting to get the \"-\" in between the necessary digits?", "abstract": ""}, "answers": [{"id": 74732233, "score": 0, "vote": 0, "content": "I am assuming an answer similar to this is wanted:", "abstract": ""}, {"id": 74732209, "score": 1, "vote": 0, "content": "Going the floor division and modulus route we can try: We could also be lazy and use a regex replacement:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/74665788/how-to-convert-string-to-number-in-python", "keywords": [], "tags": ["python", "string", "integer", "numbers", "converters"], "question": {"id": 74665788, "title": "How to convert string to number in python?", "content": "I have list of numbers as str if I use int to convert the result is [1, 4, 8].\nIf I use float to convert the result is [1.0, 4.0, 8.6] I want to convert them to [1, 4, 8.6] I've tried this:", "abstract": ""}, "answers": [{"id": 74666124, "score": 0, "vote": 0, "content": "You can try map each element using loads from json: Or using eval(): Notes: Using json.loads() or ast.literal_eval is safer than eval() when\nthe string to be evaluated comes from an unknown source", "abstract": ""}, {"id": 74666093, "score": 0, "vote": 0, "content": "You're going to need a small utility function: Then,", "abstract": ""}, {"id": 74665943, "score": 0, "vote": 0, "content": "You can use ast.literal_eval to convert an string to a literal: As @Muhammad Akhlaq Mahar noted in his comment, str.isidigit does not return True for negative integers:", "abstract": ""}, {"id": 74665939, "score": 0, "vote": 0, "content": "One way is to use ast.literal_eval Word of caution - there are values which return True with str.isdigit() but not convertible to int or float and in case of literal_eval will raise SyntaxError.", "abstract": ""}, {"id": 74665819, "score": 3, "vote": 0, "content": "Convert the items to a integer if isdigit() returns True, else to a float. This can be done by a list generator: To check if it actually worked, you can check for the types using another list generator:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44833017/how-do-i-represent-a-string-as-a-number", "keywords": [], "tags": ["python", "python-2.7", "python-3.x", "numbers"], "question": {"id": 44833017, "title": "How do I represent a string as a number?", "content": "I need to represent a string as a number, however it is 8928313 characters long, note this string can contain more than just alphabet letters, and I have to be able to convert it back efficiently too. My current (too slow) code looks like this:", "abstract": ""}, "answers": [{"id": 74621627, "score": 0, "vote": 0, "content": "Store your strings in an array of distinct values; i.e. a string table.  In your dataset, use a reference number.  A reference number of n corresponds to the nth element of the string table array.", "abstract": ""}, {"id": 44833339, "score": 4, "vote": 0, "content": "Ok, since other people are giving awful answers, I'm going to step in. Code DONT DO THIS Explanation Characters are essentially bytes: they can be encoded in different ways, but ultimately you can treat them within a given encoding as a sequence of bytes. In order to convert them to a number, we can shift them left 8-bits for their position in the sequence, creating a unique number. r, the range value, is the position in reverse order: the 4th element needs to go left 24 bytes (3*8), etc. After getting the range and converting our data to 8-bit integers, we can then transform the data and take the sum, giving us our unique identifier. It will be identical byte-wise (or in reverse byte-order) of the original number, but just \"as a number\". This is entirely futile. Don't do it. Performance Any performance is going to be outweighed by the fact that you're creating an identical object for no valid reason, but this solution is decently performant. 1,000 elements takes ~486 microseconds, 10,000 elements takes ~20.5 ms, while 100,000 elements takes about 1.5 seconds. It would work, but you shouldn't do it. This means it's scaled as O(n**2), which is likely due to memory overhead of reallocating the data each time the integer size gets larger. This might take ~4 hours to process all 8e6 elements (14365 seconds, calculated fitting the lower-order data to ax**2+bx+c). Remember, this is all to get the identical byte representation as the original data. Futility Remember, there are ~1e78 to 1e82 atoms in the entire universe, on current estimates. This is ~2^275. Your value will be able to represent 2^71426504, or about 260,000 times as many bits as you need to represent every atom in the universe. You don't need such a number. You never will.", "abstract": ""}, {"id": 44833326, "score": 0, "vote": 0, "content": "Your alpha.find() function needs to iterate through alpha on each loop. You can probably speed things up by using a dict, as dictionary lookups are O(1):", "abstract": ""}, {"id": 44833147, "score": 0, "vote": 0, "content": "There are several optimizations you can perform. For example, the find method requires searching through your string for the corresponding letter. A dictionary would be faster. Even faster might be (benchmark!) the chr function (if you're not too picky about the letter ordering) and the ord function to reverse the chr. But if you're not picky about ordering, it might be better if you just left-NULL-padded your string and treated it as a big binary number in memory if you don't need to display the value in any particular format. You might get some speedup by iterating over characters instead of character indices. If you're using Python 2, a large range will be slow since a list needs to be generated (use xrange instead for Python 2); Python 3 uses a generator, so it's better. Your print function is going to slow down output a fair bit, especially if you're outputting to a tty. A big number library may also buy you speed-up: Handling big numbers in code", "abstract": ""}, {"id": 44833066, "score": 1, "vote": 0, "content": "If there are only ANSII characters. You can use ord() and chr(). built-in functions", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/54945964/comparing-strings-containing-numbers-in-python", "keywords": [], "tags": ["python", "string", "string-comparison"], "question": {"id": 54945964, "title": "Comparing strings containing numbers in Python", "content": "I have a list of strings and I would like to verify some conditions on the strings. For example:  How can I verify it? \nI'm actually doing like this:  and I'm writing all the valid cases. \nI would like to have just one condition. ", "abstract": ""}, "answers": [{"id": 54946297, "score": 0, "vote": 0, "content": "You can just compare strings if they differ only by number and numbers have the same digits count. I.e.: The will be naturally sorted as String_3 > String_1 > String_2 But will NOT work for:\n it has 3 digits instead of 2 and it will be String_4 < String_3 thus So, the better, if you can extract number from the string, like following: Now you can compare prices as integer: ([0-9]*) - is the capturing group of the regular expression, all defined in the round parenthesis will be returned in group(1) method of the Python match object. You can extend this simple regular expression [0-9]* further for your needs. If you have list of strings:", "abstract": ""}, {"id": 54946317, "score": 0, "vote": 0, "content": "I suppose you have only ono value in your string. So we can do it with regex.", "abstract": ""}, {"id": 54946123, "score": 0, "vote": 0, "content": "You could use a regular expression to extract the number after  \"price is\", and then convert the number in string format to int. And, finally to compare if it is greater than 14, for example: Output:", "abstract": ""}, {"id": 54946120, "score": 1, "vote": 0, "content": "You can list all of the integers in the string and use them in an if statement after. If your string contains more than one number, you can select which one you want to use in the list. Hoep it helps.", "abstract": ""}, {"id": 54946051, "score": 0, "vote": 0, "content": "Is the string format always going to be the exact same? As in, it will always start with \"The price is\" and then have a positive integer, and then end with \"euros'? If so, you can just split the string into words and index the integer, cast it into an int, and check if it's greater than 14.  If the strings will not be consistent, you may want to consider a regex solution to get the numeral part of the sentence out. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73531476/how-to-extract-only-integer-part-from-a-string-in-python", "keywords": [], "tags": ["python", "string", "list", "split", "integer"], "question": {"id": 73531476, "title": "How to extract only integer part from a string in Python?", "content": "I would like to extract only the numbers contained in a string. Can isdigit() and split() be combined for this purpose or there is simpler/faster way? Example: Output: My code:", "abstract": ""}, "answers": [{"id": 73531568, "score": 2, "vote": 0, "content": "Import regex library: If you want to extract all digits: If you want to extract only first digit:", "abstract": ""}, {"id": 73531818, "score": 0, "vote": 0, "content": "OP:", "abstract": ""}, {"id": 73531677, "score": 1, "vote": 0, "content": "So if we take m as a list you can just loop through it and check if the current char is a digit then if so append it. For loop solution: List comprehension solution - appends each number at different indexes: Hope this helped, also if you want to only get the values of an iterable (e.g. a list) just use for varname in iterable it's faster and cleaner. If you need both index and the value, use for index, varname in enumerate(iterable).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73433744/python-string-to-number-list", "keywords": [], "tags": ["python", "string", "floating"], "question": {"id": 73433744, "title": "python string to number list", "content": "python string contains floating point numbers S = \"1,2.5,e,3\" I am trying to convert it to number list by ignoring non-number values. Instead of it is giving me", "abstract": ""}, "answers": [{"id": 73433818, "score": 3, "vote": 0, "content": "Output:\n[1.0, 2.5, 3.0]", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/62186920/convert-only-number-strings-to-integer-in-python-list", "keywords": [], "tags": ["python"], "question": {"id": 62186920, "title": "convert only number strings to integer in python list", "content": "I have below python list How can i get below output with one command (convert only numeric strings to numeric)", "abstract": ""}, "answers": [{"id": 62187852, "score": 1, "vote": 0, "content": "Here is your code", "abstract": ""}, {"id": 62187536, "score": 3, "vote": 0, "content": "Try converting to integer if numeric. For floats convert it blindly and if there is an exception, we can assume its a string. Output:\n[2, 3, 44, 22, 'cat', 2.2, -3.4, 'Mountain'] UPDATE\nA shorter version of the code would be:", "abstract": ""}, {"id": 62187562, "score": 1, "vote": 0, "content": "The brute force way to do it is to go through the whole list and convert item by item. If the conversion fails, it will raise a ValueError exception which you can catch. which gives", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/13206698/convert-number-to-string-in-python", "keywords": [], "tags": ["python"], "question": {"id": 13206698, "title": "convert number to string in python", "content": "I meet a problem about converting number to string. I want to get a string \"0100\" from str(0100), but what I got is \"64\". Does any way I can do to get a string \"0100\" from 0100. UPDATE Thanks for many people's pointing out that the leading \"0\" is a indicator for octal. I know it, what I want is to convert 0100 to \"0100\", any suggestion? Best Regards,", "abstract": ""}, "answers": [{"id": 53365910, "score": 0, "vote": 0, "content": "You could just concatenate both strings so if you want 0100  that way res = '0100'", "abstract": ""}, {"id": 13208302, "score": -1, "vote": 0, "content": "Not sure if I understood the question... maybe you're looking for this:", "abstract": ""}, {"id": 13206777, "score": 0, "vote": 0, "content": "In Python2, a leading 0 on a numeric literal signifies that it is an octal number. This is why 0100 == 64. This also means that 0800 and 0900 are syntax errors It's a funny thing that's caught out many people at one time or another. In Python3, 0100 is a syntax error, you must use the 0o prefix if you need to write a octal literal. eg. 0o100 == 64", "abstract": ""}, {"id": 13206739, "score": 1, "vote": 0, "content": "The integer should be written as 100, not 0100. You can format the string with leading zeros like this:", "abstract": ""}, {"id": 13206733, "score": 1, "vote": 0, "content": "Your first issue is that the literal \"0100\", because it begins with a digit 0, is interpreted in octal instead of decimal. By contrast, str(100) returns \"100\" as expected. Secondly, it sounds like you want to zero-fill your numbers to a fixed width, which you can do with the zfill method on strings. For example, str(100).zfill(4) returns \"0100\".", "abstract": ""}]}]