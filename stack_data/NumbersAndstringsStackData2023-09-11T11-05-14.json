[{"link": "https://stackoverflow.com/questions/2693776/removing-trailing-newline-character-from-fgets-input", "keywords": [], "tags": ["c", "string", "gcc", "newline", "fgets"], "question": {"id": 2693776, "title": "Removing trailing newline character from fgets() input", "content": "I am trying to get some data from the user and send it to another function in gcc. The code is something like this. However, I find that it has a newline \\n character in the end. So if I enter John it ends up sending John\\n. How do I remove that \\n and send a proper string.", "abstract": ""}, "answers": [{"id": 75720804, "score": 0, "vote": 0, "content": "To expand on the answers by @Jerry Coffin and @Tim \u010cas: The strchr version is by design much faster than the strcspn (and strlen versions are likely the fastest of all). The internals of strcspn has to iterate through the \"\\n\" string and if reasonably implemented, it only does that once and stores down the string length somewhere. Then while searching, it also has to use a nested for loop going through the \"\\n\" string. Ignoring things like word size that a library-quality implementation of these functions would take in account, naive implementations may look like this: In case of strchr, there are two branches per character. One searching for the null terminator and other comparing the current character with the one searched for. In case of strcspn, it either has to pre-calculate s2 size as in my example, or alternatively iterate through it while looking for null as well as the search key. The latter is essentially just what strchr does, so the inner loop could have been replaced with strchr. No matter how we implement it, there will be a lot of extra branching. An attentive language lawyer might also spot the absence of restrict in the strcspn standard library definition. Meaning that the compiler is not allowed to assume that s1 and s2 are different strings. This blocks some optimizations too. The strlen version will be faster than both, since strlenonly needs to check for null termination and nothing else. Though as mentioned in the answer by @chux - Reinstate Monica, there are some situations where it won't work, so it is slightly more brittle than the other versions. The root of the problem is the bad API of the fgets function - if it had been implemented better back in the days, it would have returned a size corresponding to the number of characters actually read, which would have been great. Or alternatively a pointer to the last character read like strchr. Instead the standard lib wasted the return value by returning a pointer to the first character in the string passed, which is mildly useful.", "abstract": ""}, {"id": 70312576, "score": -2, "vote": 0, "content": "This is my solution. Very simple.", "abstract": ""}, {"id": 65009713, "score": 1, "vote": 0, "content": "In general, rather than trimming data that you don't want, avoid writing it in the first place.  If you don't want the newline in the buffer, don't use fgets.  Instead, use getc or fgetc or scanf.  Perhaps something like: Note that this particular approach will leave the newline unread, so you may want to use a format string like \"%255[^\\n]%*c\" to discard it (eg, sprintf(fmt, \"%%%zd[^\\n]%%*c\", sizeof Name - 1);), or perhaps follow the scanf with a getchar().", "abstract": ""}, {"id": 2693826, "score": 230, "vote": 0, "content": "The elegant way: The slightly ugly way: The slightly strange way: Note that the strtok function doesn't work as expected if the user enters an empty string (i.e. presses only Enter). It leaves the \\n character intact. There are others as well, of course.", "abstract": ""}, {"id": 47483624, "score": 1, "vote": 0, "content": "If using getline is an option - Not neglecting its security issues and if you wish to brace pointers - you can avoid string functions as the getline returns the number of characters. Something like below Note: The [ security issues ] with getline shouldn't be neglected though.", "abstract": ""}, {"id": 60551717, "score": 1, "vote": 0, "content": "The steps to remove the newline character in the perhaps most obvious way: Note if you only pressed Enter at the fgets() string request (the string content was only consisted of a newline character) the string in NAME will be an empty string thereafter. If you rather like a function for use this technique by handling fgets output strings in general without retyping each and every time, here is fgets_newline_kill: In your provided example, it would be: Note that this method does not work if the input string has embedded \\0s in it. If that would be the case strlen() would only return the amount of characters until the first \\0. But this isn\u00b4t quite a common approach, since the most string-reading functions usually stop at the first \\0 and take the string until that null character. Aside from the question on its own. Try to avoid double negations that make your code unclearer: if (!(fgets(Name, sizeof Name, stdin) != NULL) {}. You can simply do if (fgets(Name, sizeof Name, stdin) == NULL) {}.", "abstract": ""}, {"id": 29070298, "score": 2, "vote": 0, "content": "For single '\\n' trimming, for multiple '\\n' trimming,", "abstract": ""}, {"id": 54555679, "score": 1, "vote": 0, "content": "My Newbie way ;-) Please let me know if that's correct. It seems to be working for all my cases:", "abstract": ""}, {"id": 27729970, "score": 25, "vote": 0, "content": "Below is a fast approach to remove a potential '\\n' from a string saved by fgets().\nIt uses strlen(), with 2 tests. Now use buffer and len as needed. This method has the side benefit of a len value for subsequent code.  It can be easily faster than strchr(Name, '\\n').  Ref  YMMV, but both methods work. buffer, from the original fgets() will not contain in \"\\n\" under some circumstances:\nA) The line was too long for buffer so only char preceding the '\\n' is saved in buffer. The unread characters remain in the stream.\nB) The last line in the file did not end with a '\\n'.   If input has embedded null characters '\\0' in it somewhere, the length reported by strlen() will not include the '\\n' location. Some other answers' issues:  strtok(buffer, \"\\n\"); fails to remove the '\\n' when buffer is \"\\n\".  From this answer - amended after this answer to warn of this limitation.  The following fails on rare occasions when the first char read by fgets() is '\\0'.  This happens when input begins with an embedded '\\0'.  Then buffer[len -1] becomes buffer[SIZE_MAX] accessing memory certainly outside the legitimate range of buffer. Something a hacker may try or found in foolishly reading UTF16 text files.  This was the state of an answer when this answer was written.  Later a non-OP edited it to include code like this answer's check for \"\". sprintf(buffer,\"%s\",buffer); is undefined behavior: Ref.  Further, it does not save any leading, separating or trailing whitespace.  Now deleted. [Edit due to good later answer] There are no problems with the 1 liner buffer[strcspn(buffer, \"\\n\")] = 0; other than performance as compared to the strlen() approach.  Performance in trimming is usually not an issue given code is doing I/O - a black hole of CPU time.  Should following code need the string's length or is highly performance conscious, use this strlen() approach.  Else the strcspn() is a fine alternative.", "abstract": ""}, {"id": 46264011, "score": -2, "vote": 0, "content": "You should give it a try. This code basically loop through the string until it finds the '\\n'. When it's found the '\\n' will be replaced by the null character terminator '\\0' Note that you are comparing characters and not strings in this line, then there's no need to use strcmp(): since you will be using single quotes and not double quotes. Here's a link about single vs double quotes if you want to know more", "abstract": ""}, {"id": 33786802, "score": -1, "vote": 0, "content": "Tim \u010cas one liner is amazing for strings obtained by a call to fgets, because you know they contain a single newline at the end.  If you are in a different context and want to handle strings that may contain more than one newline, you might be looking for strrspn. It is not POSIX, meaning you will not find it on all Unices. I wrote one for my own needs. For those looking for a Perl chomp equivalent in C, I think this is it (chomp only removes the trailing newline). The strrcspn function:", "abstract": ""}, {"id": 35470648, "score": -2, "vote": 0, "content": "The function below is a part of string processing library I am maintaining on Github. It removes and unwanted characters from a string, exactly what you want An example usage could be  You may want to check other available functions, or even contribute to the project :)\nhttps://github.com/fnoyanisi/zString", "abstract": ""}, {"id": 2693827, "score": 86, "vote": 0, "content": "", "abstract": ""}, {"id": 28462221, "score": 620, "vote": 0, "content": "Perhaps the simplest solution uses one of my favorite little-known functions, strcspn(): If you want it to also handle '\\r' (say, if the stream is binary): The function counts the number of characters until it hits a '\\r' or a '\\n' (in other words, it finds the first '\\r' or '\\n'). If it doesn't hit anything, it stops at the '\\0' (returning the length of the string). Note that this works fine even if there is no newline, because strcspn stops at a '\\0'. In that case, the entire line is simply replacing '\\0' with '\\0'.", "abstract": ""}, {"id": 17386177, "score": 12, "vote": 0, "content": "Direct to remove the '\\n' from the fgets output if every line has '\\n' Otherwise:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/275018/how-can-i-remove-a-trailing-newline", "keywords": [], "tags": ["python", "newline", "trailing"], "question": {"id": 275018, "title": "How can I remove a trailing newline?", "content": "How can I remove the last character of a string if it is a newline?", "abstract": ""}, "answers": [{"id": 9507807, "score": 36, "vote": 0, "content": "or you could always get geekier with regexps", "abstract": ""}, {"id": 275025, "score": 2255, "vote": 0, "content": "Try the method rstrip() (see doc Python 2 and Python 3) Python's rstrip() method strips all kinds of trailing whitespace by default, not just one newline as Perl does with chomp. To strip only newlines: In addition to rstrip(), there are also the methods strip() and lstrip(). Here is an example with the three of them:", "abstract": ""}, {"id": 58499321, "score": 7, "vote": 0, "content": "With regex Replace \\n,\\t,\\r With regex with Join", "abstract": ""}, {"id": 50870896, "score": 0, "vote": 0, "content": "This will work both for windows and linux (bit expensive with re sub if you are looking for only re solution)", "abstract": ""}, {"id": 32882948, "score": 35, "vote": 0, "content": "This would replicate exactly perl's chomp (minus behavior on arrays) for \"\\n\" line terminator: (Note: it does not modify string 'in place'; it does not strip extra trailing whitespace; takes \\r\\n in account)", "abstract": ""}, {"id": 45342003, "score": 9, "vote": 0, "content": "I'm bubbling up my regular expression based answer from one I posted earlier in the comments of another answer.  I think using re is a clearer more explicit solution to this problem than str.rstrip. If you want to remove one or more trailing newline chars: If you want to remove newline chars everywhere (not just trailing): If you want to remove only 1-2 trailing newline chars (i.e., \\r, \\n, \\r\\n, \\n\\r, \\r\\r, \\n\\n) I have a feeling what most people really want here, is to remove just one occurrence of a trailing newline character, either \\r\\n or \\n and nothing more. (The ?: is to create a non-capturing group.) (By the way this is not what '...'.rstrip('\\n', '').rstrip('\\r', '') does which may not be clear to others stumbling upon this thread.  str.rstrip strips as many of the trailing characters as possible, so a string like foo\\n\\n\\n would result in a false positive of foo whereas you may have wanted to preserve the other newlines after stripping a single trailing one.)", "abstract": ""}, {"id": 27890752, "score": 9, "vote": 0, "content": "I find it convenient to have be able to get the chomped lines via in iterator, parallel to the way you can get the un-chomped lines from a file object. You can do so with the following code: Sample usage:", "abstract": ""}, {"id": 43641376, "score": 8, "vote": 0, "content": "It looks like there is not a perfect analog for perl's chomp.  In particular, rstrip cannot handle multi-character newline delimiters like \\r\\n. However, splitlines does as pointed out here.\nFollowing my answer on a different question, you can combine join and splitlines to remove/replace all newlines from a string s: The following removes exactly one trailing newline (as chomp would, I believe). Passing True as the keepends argument to splitlines retain the delimiters.  Then, splitlines is called again to remove the delimiters on just the last \"line\": ", "abstract": ""}, {"id": 40750864, "score": 3, "vote": 0, "content": "There are three types of line endings that we normally encounter: \\n, \\r and \\r\\n. A rather simple regular expression in re.sub, namely r\"\\r?\\n?$\", is able to catch them all. (And we gotta catch 'em all, am I right?) With the last argument, we limit the number of occurences replaced to one, mimicking chomp to some extent. Example: ... where a == b == c is True.", "abstract": ""}, {"id": 40749138, "score": 5, "vote": 0, "content": "", "abstract": ""}, {"id": 27054136, "score": 32, "vote": 0, "content": "you can use strip: demo:", "abstract": ""}, {"id": 28937424, "score": 39, "vote": 0, "content": "will remove all newlines at the end of the string s. The assignment is needed because rstrip returns a new string instead of modifying the original string. ", "abstract": ""}, {"id": 16527062, "score": 43, "vote": 0, "content": "You may use line = line.rstrip('\\n'). This will strip all newlines from the end of the string, not just one.", "abstract": ""}, {"id": 2396894, "score": 55, "vote": 0, "content": "I might use something like this: I think the problem with rstrip(\"\\n\") is that you'll probably want to make sure the line separator is portable. (some antiquated systems are rumored to use \"\\r\\n\"). The other gotcha is that rstrip will strip out repeated whitespace. Hopefully os.linesep will contain the right characters. the above works for me.", "abstract": ""}, {"id": 326279, "score": 102, "vote": 0, "content": "Note that rstrip doesn't act exactly like Perl's chomp() because it doesn't modify the string. That is, in Perl: results in $x being \"a\". but in Python: will mean that the value of x is still \"a\\n\". Even x=x.rstrip() doesn't always give the same result, as it strips all whitespace from the end of the string, not just one newline at most.", "abstract": ""}, {"id": 275401, "score": 167, "vote": 0, "content": "The canonical way to strip end-of-line (EOL) characters is to use the string rstrip() method removing any trailing \\r or \\n.  Here are examples for Mac, Windows, and Unix EOL characters. Using '\\r\\n' as the parameter to rstrip means that it will strip out any trailing combination of '\\r' or '\\n'.  That's why it works in all three cases above. This nuance matters in rare cases.  For example, I once had to process a text file which contained an HL7 message.  The HL7 standard requires a trailing '\\r' as its EOL character.  The Windows machine on which I was using this message had appended its own '\\r\\n' EOL character.  Therefore, the end of each line looked like '\\r\\r\\n'.  Using rstrip('\\r\\n') would have taken off the entire '\\r\\r\\n' which is not what I wanted.  In that case, I simply sliced off the last two characters instead. Note that unlike Perl's chomp function, this will strip all specified characters at the end of the string, not just one:", "abstract": ""}, {"id": 19531239, "score": 19, "vote": 0, "content": "An example in Python's documentation simply uses line.strip(). Perl's chomp function removes one linebreak sequence from the end of a string only if it's actually there. Here is how I plan to do that in Python, if process is conceptually the function that I need in order to do something useful to each line from this file:", "abstract": ""}, {"id": 37346773, "score": 4, "vote": 0, "content": "Just use :  or You don't need any of this complicated stuff", "abstract": ""}, {"id": 1077495, "score": 13, "vote": 0, "content": "I don't program in Python, but I came across an FAQ at python.org advocating S.rstrip(\"\\r\\n\") for python 2.2 or later.", "abstract": ""}, {"id": 33392998, "score": 1, "vote": 0, "content": "If you are concerned about speed (say you have a looong list of strings) and you know the nature of the newline char, string slicing is actually faster than rstrip. A little test to illustrate this: Output:", "abstract": ""}, {"id": 26554128, "score": -2, "vote": 0, "content": "A catch all:", "abstract": ""}, {"id": 21242117, "score": 13, "vote": 0, "content": "", "abstract": ""}, {"id": 19317570, "score": 9, "vote": 0, "content": "If your question is to clean up all the line breaks in a multiple line str object (oldstr), you can split it into a list according to the delimiter '\\n' and then join this list into a new str(newstr). newstr = \"\".join(oldstr.split('\\n')) ", "abstract": ""}, {"id": 8327143, "score": 8, "vote": 0, "content": "workaround solution for special case: if the newline character is the last character (as is the case with most file inputs), then for any element in the collection you can index as follows:  to slice out your newline character. ", "abstract": ""}, {"id": 5803510, "score": 19, "vote": 0, "content": "Careful with \"foo\".rstrip(os.linesep): That will only chomp the newline characters for the platform where your Python is being executed. Imagine you're chimping the lines of a Windows file under Linux, for instance: Use \"foo\".rstrip(\"\\r\\n\") instead, as Mike says above.", "abstract": ""}, {"id": 5764202, "score": 20, "vote": 0, "content": "rstrip doesn't do the same thing as chomp, on so many levels. Read http://perldoc.perl.org/functions/chomp.html and see that chomp is very complex indeed. However, my main point is that chomp removes at most 1 line ending, whereas rstrip will remove as many as it can. Here you can see rstrip removing all the newlines: A much closer approximation of typical Perl chomp usage can be accomplished with re.sub, like this:", "abstract": ""}, {"id": 275659, "score": 183, "vote": 0, "content": "And I would say the \"pythonic\" way to get lines without trailing newline characters is splitlines().", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1654021/how-can-i-delete-a-newline-if-it-is-the-last-character-in-a-file", "keywords": [], "tags": ["linux", "perl", "shell", "awk", "sed"], "question": {"id": 1654021, "title": "How can I delete a newline if it is the last character in a file?", "content": "I have some files that I'd like to delete the last newline if it is the last character in a file.  od -c shows me that the command I run does write the file with a trailing new line: I've tried a few tricks with sed but the best I could think of isn't doing the trick: Any ideas how to do this?", "abstract": ""}, "answers": [{"id": 1654115, "score": 11, "vote": 0, "content": "gawk", "abstract": ""}, {"id": 72138792, "score": 0, "vote": 0, "content": "Here's a simple solution that uses sed.\nYour versions of sed needs to support the -z option. It can either be used in a pipe or used to edit the file in place with the -i option", "abstract": ""}, {"id": 12579554, "score": 56, "vote": 0, "content": "You can do this with head from GNU coreutils, it supports arguments that are relative to the end of the file. So to leave off the last byte use: To test for an ending newline you can use tail and wc. The following example saves the result to a temporary file and subsequently overwrites the original: You could also use sponge from moreutils to do \"in-place\" editing: You can also make a general reusable function by stuffing this in your .bashrc file: As noted by KarlWilbur in the comments and used in Sorentar's answer, truncate --size=-1 can replace head -c-1 and supports in-place editing.", "abstract": ""}, {"id": 12148703, "score": 68, "vote": 0, "content": "You can take advantage of the fact that shell command substitutions remove trailing newline characters: Simple form that works in bash, ksh, zsh: Portable (POSIX-compliant) alternative (slightly less efficient): Note: A guide to the other answers: If Perl is available, go for the accepted answer - it is simple and memory-efficient (doesn't read the whole input file at once). Otherwise, consider ghostdog74's Awk answer - it's obscure, but also memory-efficient; a more readable equivalent (POSIX-compliant) is: awk 'NR > 1 { print prev } { prev=$0 } END { ORS=\"\"; print }' in.txt Printing is delayed by one line so that the final line can be handled in the END block, where it is printed without a trailing \\n due to setting the output-record separator (OFS) to an empty string. If you want a verbose, but fast and robust solution that truly edits in-place (as opposed to creating a temp. file that then replaces the original), consider jrockway's Perl script.", "abstract": ""}, {"id": 40569742, "score": 9, "vote": 0, "content": "A fast solution is using the gnu utility truncate: The test will be true if the file does have a trailing new line. The removal is very fast, truly in place, no new file is needed and the search is also reading from the end just one byte (tail -c1).", "abstract": ""}, {"id": 52047796, "score": 2, "vote": 0, "content": "This is a good solution if you need it to work with pipes/redirection instead of reading/output from or to a file. This works with single or multiple lines. It works whether there is a trailing newline or not. Details: Note: Mac's default head does not support the -c option. You can do brew install coreutils and use ghead instead.", "abstract": ""}, {"id": 39142246, "score": 1, "vote": 0, "content": "POSIX SED: '${/^$/d}'", "abstract": ""}, {"id": 37823116, "score": 8, "vote": 0, "content": "A very simple method for single-line files, requiring GNU echo from coreutils:", "abstract": ""}, {"id": 37302409, "score": 1, "vote": 0, "content": "ruby: or:", "abstract": ""}, {"id": 2759674, "score": 2, "vote": 0, "content": "Assuming Unix file type and you only want the last newline this works. It will not work on multiple newlines... * Works only if the last line is a blank line.", "abstract": ""}, {"id": 15568555, "score": 3, "vote": 0, "content": "", "abstract": ""}, {"id": 1654042, "score": 241, "vote": 0, "content": "or, to edit the file in place: [Editor's note: -pi -e was originally -pie, but, as noted by several commenters and explained by @hvd, the latter doesn't work.] This was described as a 'perl blasphemy' on the awk website I saw. But, in a test, it worked.", "abstract": ""}, {"id": 19769053, "score": 0, "vote": 0, "content": "Should remove any last occurence of \\n in file. Not working on huge file (due to sed buffer limitation)", "abstract": ""}, {"id": 1663283, "score": 6, "vote": 0, "content": "Here is a nice, tidy Python solution.  I made no attempt to be terse here. This modifies the file in-place, rather than making a copy of the file and stripping the newline from the last line of the copy.  If the file is large, this will be much faster than the Perl solution that was chosen as the best answer. It truncates a file by two bytes if the last two bytes are CR/LF, or by one byte if the last byte is LF.  It does not attempt to modify the file if the last byte(s) are not (CR)LF.  It handles errors.  Tested in Python 2.6. Put this in a file called \"striplast\" and chmod +x striplast. P.S. In the spirit of \"Perl golf\", here's my shortest Python solution.  It slurps the whole file from standard input into memory, strips all newlines off the end, and writes the result to standard output.  Not as terse as the Perl; you just can't beat Perl for little tricky fast stuff like this. Remove the \"\\n\" from the call to .rstrip() and it will strip all white space from the end of the file, including multiple blank lines. Put this into \"slurp_and_chomp.py\" and then run python slurp_and_chomp.py < inputfile > outputfile.", "abstract": ""}, {"id": 11154296, "score": 0, "vote": 0, "content": "I had a similar problem, but was working with a windows file and need to keep those CRLF -- my solution on linux:", "abstract": ""}, {"id": 10107400, "score": 1, "vote": 0, "content": "Yet another answer FTR (and my favourite!): echo/cat the thing you want to strip and capture the output through backticks. The final newline will be stripped. For example:", "abstract": ""}, {"id": 2759611, "score": 2, "vote": 0, "content": "Using dd:", "abstract": ""}, {"id": 2482346, "score": 0, "vote": 0, "content": "", "abstract": ""}, {"id": 1654040, "score": 3, "vote": 0, "content": "See also Match any character (including newlines) in sed.", "abstract": ""}, {"id": 1658873, "score": 7, "vote": 0, "content": "If you want to do it right, you need something like this: We open the file for reading and appending; opening for appending means that we are already seeked to the end of the file.  We then get the numerical position of the end of the file with tell.  We use that number to seek back one character, and then we read that one character.  If it's a newline, we truncate the file to the character before that newline, otherwise, we do nothing. This runs in constant time and constant space for any input, and doesn't require any more disk space, either.", "abstract": ""}, {"id": 1656988, "score": 0, "vote": 0, "content": "The only time I've wanted to do this is for code golf, and then I've just copied my code out of the file and pasted it into an echo -n 'content'>file statement.", "abstract": ""}, {"id": 1656218, "score": 5, "vote": 0, "content": "Yet another perl WTDI:", "abstract": ""}, {"id": 1654049, "score": 19, "vote": 0, "content": " Edit 2:  Here is an awk version (corrected) that doesn't accumulate a potentially huge array:     awk '{if (line) print line; line=$0} END {printf $0}' abc", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/59795526/how-to-remove-starting-newlines-or-the-starting-new-from-a-binary-file", "keywords": [], "tags": ["python", "shell", "perl", "sed", "command-line"], "question": {"id": 59795526, "title": "How to remove starting newlines or the starting new from a binary file?", "content": "I see there are discussions about removing trailing newlines. How can I delete a newline if it is the last character in a file? But I don't find a discusion about removing starting newlines. Could anybody let me know what is the best way to delete starting newlines (one liner preferred)? Thanks.", "abstract": ""}, "answers": [{"id": 59795703, "score": 1, "vote": 0, "content": "In Python, start reading the file without writing in a loop until you get a non-empty line.", "abstract": ""}, {"id": 59797313, "score": 0, "vote": 0, "content": "Set a flag when you find a line that's not just a newline and print when that flag is set: e.g.:", "abstract": ""}, {"id": 59797001, "score": 0, "vote": 0, "content": "This is what I came up with, I'm sure it can still be improved a bit. Here is an alternative solution, which opens the file twice.", "abstract": ""}, {"id": 59796800, "score": 0, "vote": 0, "content": "Simple filter to skip leading empty lines One liner version perl -0777 -pe 's/^\\n+//' filename", "abstract": ""}, {"id": 59795559, "score": 2, "vote": 0, "content": "The equivalent-opposite Perl code to chomp is s/^\\n//. Instead of doing it on the last line (eof), do it on the first line. Even though it will only be an empty line, removing the newline will mean that line will print nothing in the output. or in place: Since starting newlines are by definition empty lines, you can also just skip printing them by using -n instead of -p (same behavior but without printing, so you can determine which lines to print). If you want to remove potentially multiple starting newlines, you could take another approach; advance the handle yourself in the beginning until you receive a non-empty line. It's all much easier if you don't mind reading the entire file into memory at once rather than line by line: To avoid doing any excess work editing the file unless it starts with newline characters, you could condition the edit by prefixing it with another command (reads first line of the file and causes a non-zero exit status if it doesn't start with a newline):", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/56751930/how-to-remove-n-characters-from-the-end-of-line", "keywords": [], "tags": ["perl"], "question": {"id": 56751930, "title": "How to remove `\\n` characters from the end of line?", "content": "Doc says: chomp;  # avoid \\n on last field But when file has windows CRLF, only LF is removed from the end. How to remove both CRLF characters from the end?", "abstract": ""}, "answers": [{"id": 56752462, "score": 3, "vote": 0, "content": "The reason you're having this problem is because Perl's file I/O methods are tuned to work correctly with the line endings used by the local operating system.  When you read a file which uses a different line ending convention (such as a Windows text file being processed under a *nix OS), that can prevent chomp from working correctly. As the first sentence in the perldoc states, chomp \"removes any trailing string that corresponds to the current value of $/\".  So, if you know when you're using a Windows file vs. when you're using a *nix file, you can work around the different OS line ending convention by setting $/ accordingly, to \\n for *nix and to \\r\\n for Windows. If you don't know which line ending convention a given file uses, then you'll have to fall back on a regex, such as $line =~ s/\\r?\\n\\z//.  If removing all trailing whitespace (not just line endings) is acceptable in your situation, $line =~ s/\\s+\\z// will do that for you and potentially save you another step later on.", "abstract": ""}, {"id": 56752219, "score": 4, "vote": 0, "content": "Glib answer: Run your program on Windows. Slightly less glib answer: Run your data file through dos2unix before processing it. Almost entirely not glib answer: The documentation that you point at starts with this: This safer version of chop removes any trailing string that corresponds to the current value of $/ So if you want to change the behaviour of chomp() you need to change the value of $/.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/7290445/clarification-on-chomp", "keywords": [], "tags": ["perl", "chomp"], "question": {"id": 7290445, "title": "Clarification on chomp", "content": "I'm on break from classes right now and decided to spend my time learning Perl. I'm working with Beginning Perl (http://www.perl.org/books/beginning-perl/) and I'm finishing up the exercises at the end of chapter three. One of the exercises asked that I \"Store your important phone numbers in a hash. Write a program to look up numbers by the person's name.\" Anyway, I had come up with this:  And it just wouldn't work. I kept getting this error message: Use of uninitialized value in concatenation (.) or string at hello.plx\n  line 17,  line 1 I tried playing around with the code some more but each \"solution\" looked more complex than the \"solution\" that came before it. Finally, I decided to check the answers. The only difference between my code and the answer was the presence of chomp ($input); after <STDIN>;. Now, the author has used chomp in previous example but he didn't really cover what chomp was doing. So, I found this answer on www.perlmeme.org: The chomp() function will remove (usually) any newline character from\n  the end of a string. The reason we say usually is that it actually\n  removes any character that matches the current value of $/ (the input\n  record separator), and $/ defaults to a newline.. Anyway, my questions are: What newlines are getting removed? Does Perl automatically append a \"\\n\" to the input from <STDIN>? I'm just a little unclear because when I read \"it actually removes any character that matches the current value of $/\", I can't help but think \"I don't remember putting a $/ anywhere in my code.\" I'd like to develop best practices as soon as possible - is it best to always include chomp after <STDIN> or are there scenarios where it's unnecessary?", "abstract": ""}, "answers": [{"id": 7293346, "score": 2, "vote": 0, "content": "<STDIN> is a short-cut notation for readline( *STDIN );.  What readline() does is reads the file handle until it encounters the contents of $/ (aka $INPUT_RECORD_SEPARATOR) and returns everything it has read including the contents of $/.  What chomp() does is remove the last occurrence contents of $/, if present. The contents is often called a newline character but it may be composed of more than one character.  On Linux, it contains a LF character but on Windows, it contains CR-LF. See:", "abstract": ""}, {"id": 7292437, "score": 0, "vote": 0, "content": "Though it may be obvious, it's still worth mentioning why the chomp is needed here. The hash created contains 4 lookup keys: \"Me\", \"Home\", \"Emergency\" and \"Lookup\" When $input is specified from <STDIN>, it'll contain \"Me\\n\", \"Me\\r\\n\" or some other line-ending variant depending on what operating system is being used. The uninitialized value error comes about because the \"Me\\n\" key does not exist in the hash. And this is why the chomp is needed:", "abstract": ""}, {"id": 7290502, "score": 3, "vote": 0, "content": "OK, as of 1), perl doesn't add any \\n at input. It is you that hit Enter when finished entering the number. If you don't specify $/, a default of \\n will be put (under UNIX, at least). As of 2), chomp will be needed whenever input comes from the user, or whenever you want to remove the line ending character (reading from a file, for example). Finally, the error you're getting may be from perl not understanding your variable within the double quotes of the last print, because it does have a _ character. Try to write the string as follows: (note the {} around the last variable).", "abstract": ""}, {"id": 7290496, "score": 0, "vote": 0, "content": "I think best practice here is to write: Here is quick example how chomp function ($/ meaning is explained there) works removing just one trailing new line (if any): BTW: That's funny thing is that I am learning Perl too and I reached hashes five minutes ago. ", "abstract": ""}, {"id": 7290485, "score": 9, "vote": 0, "content": "<STDIN> reads to the end of the input string, which contains a newline if you press return to enter it, which you probably do. chomp removes the newline at the end of a string.  $/ is a variable (as you found, defaulting to newline) that you probably don't have to worry about; it just tells perl what the 'input record separator' is, which I'm assuming means it defines how far <FILEHANDLE> reads.  You can pretty much forget about it for now, it seems like an advanced topic.  Just pretend chomp chomps off a trailing newline.  Honestly, I've never even heard of $/ before. As for your other question, it is generally cleaner to always chomp variables and add newlines as needed later, because you don't always know if a variable has a newline or not; by always chomping variables you always get the same behavior.  There are scenarios where it is unnecessary, but if you're not sure it can't hurt to chomp it. Hope this helps!", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/49183359/delete-newline-character-in-text-file-if-next-line-is-less-than-a-certain-length", "keywords": [], "tags": ["bash", "perl", "awk", "sed"], "question": {"id": 49183359, "title": "Delete newline character in text file if next line is less than a certain length", "content": "I'd like to create a script with any combination of bash, sed, awk, or perl that deletes the newline character of a line if the next line is less than a certain length.  Let's say we want to delete the newline character if the next line is less than 5 characters.  If we have this source text file: Here's the desired output: Here's a script that identifies all the lines that are less than 5 characters: It returns this. Here's a script that gets rid of the newlines (it's the line numbers from the previous script minus one): How do I combine these two scripts?  Or is there a better way to solve this? Update There were multiple correct answers (some didn't work on my Mac, but I think they'd work on other machines).  Here's how long the correct answers took on my machine with a 769,811 line CSV file (40,000 lines had the newline character removed).", "abstract": ""}, "answers": [{"id": 49183557, "score": 0, "vote": 0, "content": "sed is also good for simple substitutions such as this: How it works: :a This defines a label a. N This reads in the next line and appends it (with a newline character) to the current contents of the pattern space. s/\\n(.{,4})$/\\1/ If a newline character occurs within 4 characters before the end of the current line, then remove the newline ba If the above substitution command resulted in a change to the line, then jump back to label a. The above was tested with GNU sed.  For BSD/macOS sed, try:", "abstract": ""}, {"id": 49198837, "score": 0, "vote": 0, "content": "You can try this sed (ok on OpenBSD)", "abstract": ""}, {"id": 49187379, "score": 1, "vote": 0, "content": "If you want to avoid slurping and you want to look ahead, the general solution is to buffer as many lines as you want to look ahead. One in this case. In this particular case, you can make do with the following: Both of these solutions handle inputs that don't have a line feed on the last line. See Specifying file to process to Perl one-liner for usage.", "abstract": ""}, {"id": 49183426, "score": 4, "vote": 0, "content": "As in life, in software it's much easier to do things based on what has happened rather than what will happen. Don't think of any problem has needing to do X if the NEXT line contains Y, think of it as needing to do Z if the CURRENT line contains Y and then the solution is always simple and obvious, e.g.: In the above we print a newline if the CURRENT line length is 5 or more. It's clear and simple and will work with any awk in any shell on any UNIX box.", "abstract": ""}, {"id": 49183509, "score": 2, "vote": 0, "content": "output [ Well it took me 2 minutes to write the one-liner and about an hour to explain. ] Here's the explanation: Switches: -p - read every line of the input files, run the code specified by -e for each line, and print the variable $_ (which is modified by the -e code)   -0[octal number] - input line separator; if we specify 0777 the whole file will be considered a line and read at once -l - strip input lines from ending \\n, set the output line separator equal to the input line separator. (I removed it, cause it's actually not needed here)  Now the regular expression: s{pattern}{replacement} - search for pattern in variable $_ and replace it with replacement  pattern parts: \\r?\\n - match every newline symbol. For Unix \\n would be enough, \\r? - optional match of CR that may be necessary for old perl versions under Windows.   Actually I think \\r? can be removed too. (?=pattern) - a positive look-ahead match of pattern, a zero width match, that is it does not consume the characters.  .{0,5}$ - match from zero to five characters ending with     s{}{} operator modifiers: m - multiline matching, makes $ match just before \\n everywhere in text, not only at the end of the line. \ng - global matching, replace every occurrence in the text. Finally, how it all works:  Perl slurps the whole file (-0777) and (-p), then it searches for every occurence of \\r?\\n that is followed by no more than 5 non-newline characters and a newline: (?=.{0,5}$).\nEvery occurrence is replaced by the empty string {}. I think I've been clear enough. Additional information can be obtained from: perldoc perlre, perldoc perlop , perldoc perlrun.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/9751161/removing-newline-character-from-a-string-in-perl", "keywords": [], "tags": ["regex", "string", "perl"], "question": {"id": 9751161, "title": "Removing newline character from a string in Perl", "content": "I have a string that is read from a text file, but in Ubuntu Linux, and I try to delete its newline character from the end. I used all the ways. But for s/\\n|\\r/-/ (I look whether it finds any replaces any new line string) it replaces the string, but it still goes to the next line when I print it. Moreover, when I used chomp or chop, the string is completely deleted. I could not find any other solution. How can I fix this problem?", "abstract": ""}, "answers": [{"id": 40248713, "score": 3, "vote": 0, "content": "", "abstract": ""}, {"id": 9751414, "score": 7, "vote": 0, "content": "You can wipe the linebreaks with something like this: When you do that though, you'll need to change the regex in your if statement to not look for them. I also don't think you want a /g in your if. You really shouldn't have a $line2 either. I also wouldn't do this type of thing: You can do ... instead. Also, print accepts a list, so instead of concatenating your strings, you can just use commas.", "abstract": ""}, {"id": 9752569, "score": 12, "vote": 0, "content": "You are probably experiencing a line ending from a Windows file causing issues. For example, a string such as \"foo bar\\n\", would actually be \"foo bar\\r\\n\". When using chomp on Ubuntu, you would be removing whatever is contained in the variable $/, which would be \"\\n\". So, what remains is \"foo bar\\r\". This is a subtle, but very common error. For example, if you print \"foo bar\\r\" and add a newline, you would not notice the error: But when you concatenate the string with another string, you overwrite the first string, because \\r moves the output handle to the beginning of the string. For example: It would effectively be \"foo bar\\r: WRONG\\n\", but the text after \\r would cause the following text to wrap back on top of the first part: This is more obvious when the first line is longer than the second. For example, try the following: And you will get the output: The solution is to remove the bad line endings. You can do this with the dos2unix command, or directly in Perl with: Also, be aware that your other code is somewhat horrific. What do you for example think that $13 contains? That'd be the string captured by the 13th parenthesis in your previous regular expression. I'm fairly sure that value will always be undefined, because you do not have 13 parentheses. You declare two sets of $id and $name. One outside the loop and one at the top. This is very poor practice, IMO. Only declare variables within the scope they need, and never just bunch all your declarations at the top of your script, unless you explicitly want them to be global to the file. Why use $line and $line2 when they have the same value? Just use $line. And seriously, what is up with this: That looks like an attempt to obfuscate, no offence. Three nested negations and a bunch of unnecessary parentheses? First off, since it is an if-else, just swap it around and reverse the regular expression. Second, [^\\W_] a double negation is rather confusing. Why not just use [A-Za-z0-9]? You can split this up to make it easier to parse:", "abstract": ""}, {"id": 9752854, "score": 17, "vote": 0, "content": "The correct way to remove Unicode linebreak graphemes, including CRLF pairs, is using the \\R regex metacharacter, introduced in v5.10. The use encoding pragma is strongly deprecated. You should either use the use open pragma, or use an encoding in the  mode argument on 3-arg open, or use binmode.", "abstract": ""}, {"id": 9751433, "score": 4, "vote": 0, "content": "You can do something like: =~ tr/\\n// But really chomp should work: Also s/\\n|\\r// only replaces the first occurrence of \\r or \\n.  If you wanted to replace all occurrences you would want the global modifier at the end s/\\r|\\n//g. Note: if you're including \\r for windows it usually ends its line as \\r\\n so you would want to replace both (e.g. s/(?:\\r\\n|\\n)//), of course the statement above (s/\\r|\\n//g) with the global modifier would take care of that anyways.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/31262739/difference-between-chomp-and-trim-in-perl", "keywords": [], "tags": ["perl", "trim", "chomp"], "question": {"id": 31262739, "title": "Difference between chomp and trim in Perl?", "content": "What is the difference between chomp and trim in Perl? Which one is better to use and when?", "abstract": ""}, "answers": [{"id": 31264491, "score": 4, "vote": 0, "content": "Chomp: The chomp() function will remove (usually) any newline character from the end of a string. The reason we say usually is that it actually removes any character that matches the current value of $/ (the input record separator), and $/ defaults to a newline.\nFor more information see chomp. As rightfold has commented There is no trim function in Perl. Generally people write a function with name trim (you can use any other name also) to remove leading and trailing white spaces (or single or double quotes or any other special character) trim remove white space from both ends of a string:", "abstract": ""}, {"id": 31263927, "score": -1, "vote": 0, "content": "Chomp: It only removes the last character, if it is a newline.  More details can be found at: http://perldoc.perl.org/functions/chomp.html Trim: There is no function called Trim in Perl. Although, we can create our function to remove the leading and trailing spaces in Perl. Code can be as follows: perl trim function - remove leading and trailing whitespace More details can be found at :http://perlmaven.com/trim", "abstract": ""}, {"id": 31262852, "score": 1, "vote": 0, "content": "trim removes both leading and trailing whitespaces, chomp removes only trailing input record separator (usually new line character). ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11645696/perls-chomp-chomp-is-removing-the-whole-word-instead-of-the-newline", "keywords": [], "tags": ["perl"], "question": {"id": 11645696, "title": "Perl&#39;s Chomp: Chomp is removing the whole word instead of the newline", "content": "I am facing issues with perl chomp function.\nI have a test.csv as below: I want to print the 2nd field of this csv. This is my code: The output of aboe code is : I really don't know where the \"1\" is comming from. Actually, the last filed can be printed as below: the output is: Now, i am using these field values as an input to the DB and the DB INSERT statement is failing due this invisible newline. So I thought chomp would help me here. instead of chomping, it gives me \"11111\".  Could you help me understand what am i doing wrong here. Thanks. Adding more information after reading loldop's responce: If I write as below, then it will not print anything (not even the \"11111\" output mentioned above) Meaning, chomp is removing the last string and the trailing new line.", "abstract": ""}, "answers": [{"id": 11655015, "score": 0, "vote": 0, "content": "So, I was quite frustrated with this easy looking task bugging me for the whole day long. I really appreciate everyone who responded.  Finaly I ended up using Text::CSV perl module and then calling each of the CSV field as array reference. There was no need left to run the chomp after using Text::CSV. Here is the code: and here is hte output: Later i was pulled these individual values and inserted into the DB.  Thanks everyone.", "abstract": ""}, {"id": 11646710, "score": 5, "vote": 0, "content": "The reason you see only a string of 1s is that you are printing the value of $val which is the value returned from chomp. chomp doesn't return the trimmed string, it modifies its parameter in-place and returns the number of characters removed from the end. Since it always removes exactly one \"\\n\" character you get a 1 output for each element of the array. You really should use warnings instead of the -w command-line option, and there is no reason here to read the entire file into an array. But well done on using a lexical filehandle with the three-parameter form of open. Here is a quick refactoring of your program that will do what you want.", "abstract": ""}, {"id": 11645884, "score": 1, "vote": 0, "content": "If you simply want to get rid of new lines you can use a regex:", "abstract": ""}, {"id": 11645835, "score": 1, "vote": 0, "content": "although, it is my fault at the beginning.\nchomp function return 1 <- result of usage this function.\nalso, you can find this bad example below. but it will works, if you use numbers. \nsometimes i use this cheat (don't do that! it is my bad-hack code!)\nmap{/filter/ && $_;}@all_to_filter;\ninstead of this, use\ngrep{/filter/}@all_to_filter;", "abstract": ""}]}]