[{"link": "https://stackoverflow.com/questions/13034496/using-global-variables-between-files", "keywords": [], "tags": ["python", "share", "global"], "question": {"id": 13034496, "title": "Using global variables between files?", "content": "I'm bit confused about how the global variables work. I have a large project, with around 50 files, and I need to define global variables for all those files. What I did was define them in my projects main.py file, as following: I'm trying to use myList in subfile.py, as following An other way I tried, but didn't work either And inside subfile.py I had this: But again, it didn't work. How should I implement this? I understand that it cannot work like that, when the two files don't really know each other (well subfile doesn't know main), but I can't think of how to do it, without using io writing or pickle, which I don't want to do.", "abstract": ""}, "answers": [{"id": 76381762, "score": 0, "vote": 0, "content": "I saw once somewhere in the internet (sorry, can't remember where) the following way (that I have been using since then): Create a file called (for example) variables.py where you declare all your globals, ex: variable1=0.0\nvariable2= \"my text\" call such variables wherever you want (in another files for example): variables.variable1= 1 (here assigning 1 to it) Edit: found an example of it: https://www.edureka.co/community/52900/how-do-i-share-global-variables-across-modules-python", "abstract": ""}, {"id": 69155045, "score": 2, "vote": 0, "content": "Namespace nightmares arise when you do from config import mySharedThing. That can't be stressed enough. It's OK to use from in other places. You can even have a config module that's totally empty. result: But using objects you pulled in with from will take you down a path of frustration. result: And maybe you'll try to fix it like this: result: And then maybe you'll find this page and try to solve it by adding an init() method. But the whole problem is the from.", "abstract": ""}, {"id": 45646477, "score": 188, "vote": 0, "content": "See Python's document on sharing global variables across modules: The canonical way to share information across modules within a single program is to create a special module (often called config or cfg). config.py:\n Import the config module in all modules of your application; the module then becomes available as a global name. main.py:\n In general, don\u2019t use from modulename import *. Doing so clutters the importer\u2019s namespace, and makes it much harder for linters to detect undefined names.", "abstract": ""}, {"id": 68278598, "score": 2, "vote": 0, "content": "Based on above answers and links within I created a new module called global_variables.py: Then in my main module I use this: In another child imported module I can use: I've only spent a few minutes testing in two different python multiple-module programs but so far it's working perfectly.", "abstract": ""}, {"id": 64578792, "score": 2, "vote": 0, "content": "I just came across this post and thought of posting my solution, just in case of anyone being in the same situation as me, where there are quite some files in the developed program, and you don't have the time to think through the whole import sequence of your modules (if you didn't think of that properly right from the start, such as I did). In such cases, in the script where you initiate your global(s), simply code a class which says like: and then use, instead of the line in the script where you initiated your globals, instead of use I was then able to retrieve / change the values of any of these globals via in any script, and these changes were automatically also applied to all the other scripts using them. All worked now, by using the exact same import statements which previously failed, due to the problems mentioned in this post / discussion here. I simply thought of global object's properties being changing dynamically without the need of considering / changing any import logic, in comparison to simple importing of global variables, and that definitely was the quickest and easiest (for later access) approach to solve this kind of problem for me.", "abstract": ""}, {"id": 13034908, "score": 467, "vote": 0, "content": "The problem is you defined myList from main.py, but subfile.py needs to use it. Here is a clean way to solve this problem: move all globals to a file, I call this file settings.py. This file is responsible for defining globals and initializing them: Next, your subfile can import globals: Note that subfile does not call init()\u2014 that task belongs to main.py: This way, you achieve your objective while avoid initializing global variables more than once.", "abstract": ""}, {"id": 34432306, "score": 10, "vote": 0, "content": "Hai Vu answer works great, just one comment:  In case you are using the global in other module and you want to set the global dynamically, pay attention to import the other modules after you set the global variables, for example:", "abstract": ""}, {"id": 13034700, "score": 24, "vote": 0, "content": "You can think of Python global variables as \"module\" variables - and as such they are much more useful than the traditional \"global variables\" from C. A global variable is actually defined in a module's __dict__ and can be accessed from outside that module as a module attribute. So, in your example: And:", "abstract": ""}, {"id": 13034779, "score": 4, "vote": 0, "content": "Your 2nd attempt will work perfectly, and is actually a really good way to handle variable names that you want to have available globally.  But you have a name error in the last line.  Here is how it should be: See the last line?  myList is an attr of globfile, not subfile.  This will work as you want. Mike", "abstract": ""}, {"id": 13034602, "score": 12, "vote": 0, "content": "Using from your_file import * should fix your problems. It defines everything so that it is globally available (with the exception of local variables in the imports of course). for example: and:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/68152369/global-variables-between-modules", "keywords": [], "tags": ["python", "python-3.x", "global-variables"], "question": {"id": 68152369, "title": "Global variables between modules", "content": "I have not been able to find a reason why the matter does not work for me, so I would like to ask a question here. I have 2 files: file2.py: and main.py: And I am getting the error: NameError: name 'justTry' is not defined.\nWhy can't I use the justTry variable, which I declared as a global variable in the step before the listing?", "abstract": ""}, "answers": [{"id": 68153138, "score": 3, "vote": 0, "content": "when \"*importing\" something, it executes the code, and copy's the globals in to your globals. but if globals get alterd later, it won't re-copy the globals. the solution is, to re-import the file after test is called file2.py: main.py:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66450386/sharing-global-variables-across-modules-combined-with-from-module-import", "keywords": [], "tags": ["python", "module", "global-variables"], "question": {"id": 66450386, "title": "sharing global variables across modules combined with from module import *", "content": "I read here a clear way to share variables across modules.\nAccordingly, my code is set up like this: config.py mod.py main.py Now, this is just a MWE.  In the real case, I have lots of variables to share between modules - not just x.  And mod.py actually reads a file to get these values and store them in variables. main.py is designed set the environment and then drop the user into interactive mode, so that the user can play around with these functions and these variables. My question is: can I simplify the variable names so that I don't need to use config.x but simply x?  I know I can use something like this: import config as g and then refer to g.x.  But I'd like to make it even simpler. But when I try from config import *, I always get errors about variables not being defined.  Is it possible? And as a related question, given that global variables are somewhat evil\u2122, is the method of sharing variables presented in the link in my top sentence also evil?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/65756343/sharing-global-variables-across-modules-best-practice", "keywords": [], "tags": ["python", "variables", "global"], "question": {"id": 65756343, "title": "Sharing global variables across modules best practice", "content": "I have a variable that needs to be accessed in functions across several modules and will not be modified while it runs (Could be modified before code runs).  I see 2 ways of doing this. I could declare a variable in the global namespace and pass as a function input parameter main.py utils.py vs. Creating a config.py that holds the \"global\" variable main.py utils.py config.py Is there one method that is preferred over the other?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/62175203/how-to-share-global-variables-between-files-in-python-like-c", "keywords": [], "tags": ["python", "extern"], "question": {"id": 62175203, "title": "How to share global variables between files in Python like C", "content": "i have 2 files  how to get the X value in  main.py file i have to use only 2 files here \nnow if print or store x to other variable it has to print 8", "abstract": ""}, "answers": [{"id": 62175628, "score": 0, "vote": 0, "content": "you have to use the global keyword properly", "abstract": ""}, {"id": 62175557, "score": 0, "vote": 0, "content": "You can do something like this to get varaible x in main.py , if you declare x as global inside foo()  that mean you will be accessing the global x not local x.  OUTPUT", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61735278/how-to-retain-global-variables-across-modules", "keywords": [], "tags": ["python", "python-3.x", "trace"], "question": {"id": 61735278, "title": "How to retain global variables across modules?", "content": "I have a module: generate_ruml that has a global variable, foo. When I run the script python3 generate_ruml.py, it works. However, when I call the function of generate_ruml (function name is: gruml()) from another module: gruml_cli using python3 gruml_cli.py, the global variable is not accessed and is considered as None while using Trace. How do I make the line global foo work? Below is the code for generate_ruml: Below is the code for gruml_cli: This is the error I receive when I call the function from gruml_cli: I also tried to insert the script generate_ruml.py in the sys path but in vain.", "abstract": ""}, "answers": [{"id": 61735682, "score": 0, "vote": 0, "content": "You can either import the variable as Or you can reference the variable as, throughout your code.", "abstract": ""}, {"id": 61735562, "score": 0, "vote": 0, "content": "It looks like you need to import the global variable as well. Like:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61431024/share-global-variables-between-modules", "keywords": [], "tags": ["python"], "question": {"id": 61431024, "title": "share global variables between modules", "content": "I have 2 python modules. In one of them there is a boolean variable which is being changed continuously (according to input).\nIn the second module I'm doing something according to the value of boolean variable in the first module.  I want this shared variable to be updated simultaneously but the value doesn't change since I import it the first time.\nI tried to use global variables but that doesn't work too!   In a simplified way:   module1.py: in module2.py: What is the correct way to share this variable and it's update value?", "abstract": ""}, "answers": [{"id": 61431513, "score": 0, "vote": 0, "content": "The following works - maybe that helps you out Module 4: Module 1: Module 2: Module 3: Running module 3 shows that the modules are sharing the variable of module 4.", "abstract": ""}, {"id": 61431452, "score": 0, "vote": 0, "content": "You can do this using a generator function. A generator is a special function that, instead of executing when called, it returns an iterator that executes the body until it comes to a yield statement. Any function with a yield statement is a generator. module1.py: module2.py:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/48681438/access-global-variable-across-multiple-modules-and-threads", "keywords": [], "tags": ["python", "multithreading", "global-variables"], "question": {"id": 48681438, "title": "Access global variable across multiple modules and threads", "content": "I have two python scripts which import each other and access a variable defined in the first script. But changes made to this variable are not seen in the other module. Code with which the behavior can be reproduced: File a.py File b.py: Run the program with python a.py. The result is: Expected output: ... where the keys are time.time() strings. I thought the global variable X should be able to be referenced wherever we want to. So why is X not updated in b.f even though the call to set is adding these keys to it?", "abstract": ""}, "answers": [{"id": 48686221, "score": 4, "vote": 0, "content": "The problem is that two instances of the variable X are created in such a set-up: one in a.py and another in b.py. The problem also occurs in this example that reduces it to the essence -- it is not related to creating threads: File a.py: File b.py: When running a.py the output is: B original value\n  B new value\n  A original value If the same X were accessed, then the last line of the output would have read: A new value This happens because import creates new instances of all global names therein. It will do this only upon the first time import a is encountered, and it really is the first time here. The module created by execution of a.py is named __main__, not a. Since this name is different from a, import a will really import the module, and not just reference the already loaded __main__ module. See also the Python documentation for a description of how module names are resolved. As a consequence the names in these two modules are distinct; import a does not make the __main__ names accessible to the other module. A quick solution is to replace the import a statement in b.py with an import __main__ statement, and use __main__.X as the qualified name you want to access in b.py. But this is not regarded the advised way to proceed. A more robust way is to ensure the global variables are not defined in the executed script, but in an imported module -- one that is imported by both a.py and b.py. The second import will make the names available that were defined when the first import was parsed: File common.py: File a.py: File b.py: Now the output is: B original value\n  B new value\n  A new value File common.py: File a.py: File b.py:", "abstract": ""}, {"id": 48686000, "score": 0, "vote": 0, "content": "I think the answer lies in the fact that python does not truly allow global variables. A scope of a global is typically only in the same module. So when another module imports a module with globals, the namespace is copied and a variable is created with same original value. An imported Python module will not have direct access to the globals in the module which imports it, nor vice versa.  You may want to read the section 1.2.5 & 1.15.6 from  Norman Matloff's Quick and Painless Python PDF Tutorial", "abstract": ""}, {"id": 48682414, "score": 0, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/32914488/global-variables-between-different-modules", "keywords": [], "tags": ["python", "methods", "module", "global"], "question": {"id": 32914488, "title": "Global Variables between different modules", "content": "main.py:  module.py The program prints: main - before: 20  func2: 20  func1: 10 main - after 20 'var' is a global variable. I would expect that the moment I change var's value, it will be changed wherever the variable 'var' appears. \nThe only difference between func1 and func2 is that func1 is in another module. Still, I don't understand why the value of 'var' is different between func1 and func2. ", "abstract": ""}, "answers": [{"id": 32915882, "score": 5, "vote": 0, "content": "There is no such thing as a truly global variable in python. Objects are bound to variables in namespaces and the global keyword refers to the current module namespace. from somemodule import * creates new variables in the current module's namespace and refers them to somemodule's objects. You now have two different variables pointing to the same object. If you rebind one of the variables, the other ones continue to reference the original object. Further, a function.s \"global\" namespace is the module it is defined in, even if it is imported to a different module. If you want a \"global\" variable, import the module and use its namespace qualified name instead of rebinding individual variables in the local namespace. Here's an annotated example... cfg.py main.py", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/29304931/global-variables-in-python-to-share-variable-across-files", "keywords": [], "tags": ["python", "global-variables"], "question": {"id": 29304931, "title": "Global variables in Python to share variable across files", "content": "I have a Python script that gets a command line argument, and then it is stored as a global variable within the script: The script then imports a couple of other files, each containing another function. I am trying to carry the value of this variable to the other functions as well, by doing the following: which is contained in another file than the original script. When I run the script, I get  What am I missing?", "abstract": ""}, "answers": [{"id": 29304978, "score": 4, "vote": 0, "content": "global in Python means \"within that module\". It does not share names across modules. If you want to access a variable defined in one module from another, simply import it: or, even better, pass it as an argument to func.", "abstract": ""}]}]