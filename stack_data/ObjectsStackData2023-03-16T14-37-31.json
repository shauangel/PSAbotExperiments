[{"link": "https://stackoverflow.com/questions/1535327/how-to-print-instances-of-a-class-using-print", "keywords": [], "tags": ["python", "class", "printing", "object"], "question": {"id": 1535327, "title": "How to print instances of a class using print()?", "content": "When I try to print an instance of a class, I get an output like this: How can I make it so that the print will show something custom (e.g. something that includes the a attribute value)? That is, how can I can define how the instances of the class will appear when printed (their string representation)? See How can I choose a custom string representation for a class itself (not instances of the class)? if you want to define the behaviour for the class itself (in this case, so that print(Test) shows something custom, rather than <class __main__.Test> or similar). (In fact, the technique is essentially the same, but trickier to apply.)", "abstract": ""}, "answers": [{"id": 73475351, "score": 2, "vote": 0, "content": "Even though this is an older post, there is also a very convenient method introduced in dataclasses (as of Python 3.7). Besides other special functions such as __eq__ and __hash__, it provides a __repr__ function for class attributes. You example would then be: If you want to hide a certain attribute from being outputted, you can set the field decorator parameter repr to False:", "abstract": ""}, {"id": 1535375, "score": 180, "vote": 0, "content": "As Chris Lutz explains, this is defined by the __repr__ method in your class. From the documentation of repr(): For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a __repr__() method. Given the following class Test: ..it will act the following way in the Python shell: If no __str__ method is defined, print(t) (or print(str(t))) will use the result of __repr__ instead If no __repr__ method is defined then the default is used, which is roughly equivalent to:", "abstract": ""}, {"id": 1535336, "score": 874, "vote": 0, "content": "The __str__ method is what gets called happens when you print it, and the __repr__ method is what happens when you use the repr() function (or when you look at it with the interactive prompt). If no __str__ method is given, Python will print the result of __repr__ instead. If you define __str__ but not __repr__, Python will use what you see above as the __repr__, but still use __str__ for printing.", "abstract": ""}, {"id": 66609115, "score": 7, "vote": 0, "content": "__repr__ and __str__ are already mentioned in many answers. I just want to add that if you are too lazy to add these magic functions to your class, you can use objprint. A simple decorator @add_objprint will help you add the __str__ method to your class and you can use print for the instance. Of course if you like, you can also use objprint function from the library to print any arbitrary objects in human readable format. The output is like", "abstract": ""}, {"id": 65923868, "score": 16, "vote": 0, "content": "Simple. In the print, do: as long as the constructor is", "abstract": ""}, {"id": 52998941, "score": 86, "vote": 0, "content": "If you're in a situation like @Keith you could try: It goes against what I would consider good style but if you're just trying to debug then it should do what you want.", "abstract": ""}, {"id": 49282111, "score": 20, "vote": 0, "content": "A prettier version of response by @user394430 Produces visually nice list of the names and values. An even fancier version (thanks Ruud) sorts the items:", "abstract": ""}, {"id": 37349332, "score": 15, "vote": 0, "content": "For Python 3: If the specific format isn't important (e.g. for debugging) just inherit from the Printable class below.  No need to write code for every object.   Inspired by this answer", "abstract": ""}, {"id": 14354579, "score": 12, "vote": 0, "content": "You need to use __repr__. This is a standard function like __init__.\nFor example:", "abstract": ""}, {"id": 32635523, "score": 81, "vote": 0, "content": "A generic way that can be applied to any class without specific formatting could be done as follows: And then, produces", "abstract": ""}, {"id": 31800938, "score": 2, "vote": 0, "content": "There are already a lot of answers in this thread but none of them particularly helped me, I had to work it out myself, so I hope this one is a little more informative. You just have to make sure you have parentheses at the end of your class, e.g: Here's an example of code from a project I was working on: To print my Hydrogen class, I used the following: Please note, this will not work without the parentheses at the end of Hydrogen. They are necessary. Hope this helps, let me know if you have anymore questions. ", "abstract": ""}, {"id": 13971187, "score": 14, "vote": 0, "content": "Just to add my two cents to @dbr's answer, following is an example of how to implement this sentence from the official documentation he's cited: \"[...] to return a string that would yield an object with the same value when passed to eval(), [...]\" Given this class definition: Now, is easy to serialize instance of Test class: So, running last piece of code, we'll get: But, as I said in my last comment: more info is just here!", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance", "keywords": [], "tags": ["python", "introspection", "instanceof", "python-datamodel"], "question": {"id": 510972, "title": "Getting the class name of an instance", "content": "How do I find out the name of the class used to create an instance of an object in Python? I'm not sure if I should use the inspect module or parse the __class__ attribute.", "abstract": ""}, "answers": [{"id": 74891859, "score": 0, "vote": 0, "content": "If you're looking to solve this for a list (or iterable collection) of objects, here's how I would solve:", "abstract": ""}, {"id": 73761570, "score": 0, "vote": 0, "content": "You can first use type and then str to extract class name from it.", "abstract": ""}, {"id": 510988, "score": 168, "vote": 0, "content": "type() ?", "abstract": ""}, {"id": 64843213, "score": 11, "vote": 0, "content": "You can simply use __qualname__ which stands for qualified name of a function or class Example: documentation link qualname", "abstract": ""}, {"id": 16293038, "score": 30, "vote": 0, "content": "In Python 2, Example:", "abstract": ""}, {"id": 61937483, "score": 7, "vote": 0, "content": "To get instance classname: or both are the same", "abstract": ""}, {"id": 511059, "score": 2456, "vote": 0, "content": "Have you tried the __name__ attribute of the class? ie type(x).__name__ will give you the name of the class, which I think is what you want. If you're still using Python 2, note that the above method works with new-style classes only (in Python 3+ all classes are \"new-style\" classes). Your code might use some old-style classes. The following works for both:", "abstract": ""}, {"id": 46205181, "score": 23, "vote": 0, "content": "Alternatively you can use the classmethod decorator: Usage:", "abstract": ""}, {"id": 45061340, "score": 14, "vote": 0, "content": "Apart from grabbing the special __name__ attribute, you might find yourself in need of the qualified name for a given class/function. This is done by grabbing the types __qualname__. In most cases, these will be exactly the same, but, when dealing with nested classes/methods these differ in the output you get. For example: Since introspection is what you're after, this is always you might want to consider.", "abstract": ""}, {"id": 24130402, "score": 51, "vote": 0, "content": "The sample code above (when input in the interactive interpreter) will produce '__main__.A' as opposed to 'A' which is produced if the __name__ attribute is invoked. By simply passing the result of A.__class__ to the str constructor the parsing is handled for you. However, you could also use the following code if you want something more explicit. This behavior can be preferable if you have classes with the same name defined in separate modules. The sample code provided above was tested in Python 2.7.5.", "abstract": ""}, {"id": 9383568, "score": 16, "vote": 0, "content": "Good question. Here's a simple example based on GHZ's which might help someone:", "abstract": ""}, {"id": 511060, "score": 515, "vote": 0, "content": "Do you want the name of the class as a string?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/1911281/how-do-i-get-list-of-methods-in-a-python-class", "keywords": [], "tags": ["python"], "question": {"id": 1911281, "title": "How do I get list of methods in a Python class?", "content": "I want to iterate through the methods in a class, or handle class or instance objects differently based on the methods present. How do I get a list of class methods? Also see:", "abstract": ""}, "answers": [{"id": 74315537, "score": 0, "vote": 0, "content": "For my use case, I needed to distinguish between class methods, static methods, properties, and instance methods. The inspect module confuses the issue a bit (particularly with class methods and instance methods), so I used vars based on a comment on this SO question. The basic gist is to use vars to get the __dict__ attribute of the class, then filter based on various isinstance checks. For instance methods, I check that it is callable and not a class method. One caveat: this approach of using vars (or __dict__ for that matter) won't work with __slots__. Using Python 3.6.9 (because it's what the Docker image I'm using as my interpreter has): To see it in action, I created this little test class: then did: which output In this example I'm discarding the actual methods, but if you needed to keep them you could just use a dict comprehension instead of a set comprehension:", "abstract": ""}, {"id": 71816408, "score": -1, "vote": 0, "content": "Just like this", "abstract": ""}, {"id": 68804677, "score": 1, "vote": 0, "content": "use inspect.ismethod and dir and getattr output:", "abstract": ""}, {"id": 68575686, "score": 0, "vote": 0, "content": "None of the above worked for me. I've encountered this problem while writing pytests. The only work-around I found was to: 1- create another directory and place all my .py files there 2- create a separate directory for my pytests and then importing the classes I'm interested in This allowed me to get up-to-dated methods within the class - you can change the method names and then use print(dir(class)) to confirm it.", "abstract": ""}, {"id": 65571791, "score": 9, "vote": 0, "content": "Try\nprint(help(ClassName))\nIt prints out methods of the class", "abstract": ""}, {"id": 54326058, "score": 5, "vote": 0, "content": "This also works: In mymodule.py: In another file: Output: ['foo', 'bar'] From the Python docs: Return true if the object is a user-defined or built-in function or method.", "abstract": ""}, {"id": 64315050, "score": 3, "vote": 0, "content": "You can use a function which I have created. Output:", "abstract": ""}, {"id": 50179469, "score": 9, "vote": 0, "content": "If your method is a \"regular\" method and not a staticmethod, classmethod etc.\nThere is a little hack I came up with - This can be extended to other type of methods by changing \"function\" in the if condition correspondingly.\nTested in Python 2.7 and Python 3.5.", "abstract": ""}, {"id": 61200307, "score": 5, "vote": 0, "content": "There's this approach: When dealing with a class instance, perhaps it'd be better to return a list with the method references instead of just names\u00b9. If that's your goal, as well as It may be of use. You might also want to assure it's callable(getattr(obj, m)), since dir returns all attributes within obj, not just methods. In a nutshell, for a class like We could check instance retrieval with So you can call it right away: \u00b9 An use case: I used this for unit testing. Had a class where all methods performed variations of the same process - which led to lengthy tests, each only a tweak away from the others. DRY was a far away dream. Thought I should have a single test for all methods, so I made the above iteration. Although I realized I should instead refactor the code itself to be DRY-compliant anyway... this may still serve a random nitpicky soul in the future.", "abstract": ""}, {"id": 63305638, "score": -1, "vote": 0, "content": "To produce a list of methods put the name of the method in a list without the usual parenthesis. Remove the name and attach the parenthesis and that calls the method.", "abstract": ""}, {"id": 61957218, "score": 26, "vote": 0, "content": "You can list all methods in a python class by using the following code This will return a list of all the names of the methods in the class", "abstract": ""}, {"id": 61490721, "score": 7, "vote": 0, "content": "I just keep this there, because top rated answers are not clear. This is simple test with not usual class based on Enum. And this is output results. So what we have: Why are votes so erroneous? And where i'm wrong? And where wrong other people which answers have so low votes?", "abstract": ""}, {"id": 1911287, "score": 426, "vote": 0, "content": "An example (listing the methods of the optparse.OptionParser class): Notice that getmembers returns a list of 2-tuples. The first item is the name of the member, the second item is the value. You can also pass an instance to getmembers:", "abstract": ""}, {"id": 59631738, "score": -1, "vote": 0, "content": "This is just an observation. \"encode\" seems to be a method for string objects However, if str1 is inspected for methods, an empty list is returned So, maybe I am wrong, but the issue seems to be not simple.", "abstract": ""}, {"id": 57149907, "score": 2, "vote": 0, "content": "gives an identical list as does.", "abstract": ""}, {"id": 55332478, "score": -6, "vote": 0, "content": "If you want to list only methods of a python class", "abstract": ""}, {"id": 55056496, "score": -2, "vote": 0, "content": "output", "abstract": ""}, {"id": 53608586, "score": 60, "vote": 0, "content": "Say you want to know all methods associated with list class\nJust Type The following  Above will give you all methods of list class", "abstract": ""}, {"id": 39061905, "score": 207, "vote": 0, "content": "Python 3.x answer without external libraries dunder-excluded result:", "abstract": ""}, {"id": 29333454, "score": 30, "vote": 0, "content": "you can also import the FunctionType from types and test it with the class.__dict__:", "abstract": ""}, {"id": 24715094, "score": 3, "vote": 0, "content": "So Think Python page 210", "abstract": ""}, {"id": 1911313, "score": 290, "vote": 0, "content": "There is the dir(theobject) method to list all the fields and methods of your object (as a tuple) and the inspect module (as codeape write) to list the fields and methods with their doc (in \"\"\"). Because everything (even fields) might be called in Python, I'm not sure there is a built-in function to list only methods. You might want to try if the object you get through dir is callable or not.", "abstract": ""}, {"id": 7478804, "score": 15, "vote": 0, "content": "Note that you need to consider whether you want methods from base classes which are inherited (but not overridden) included in the result. The dir() and inspect.getmembers() operations do include base class methods, but use of the __dict__ attribute does not.", "abstract": ""}, {"id": 24795848, "score": 1, "vote": 0, "content": "I know this is an old post, but just wrote this function and will leave it here is case someone stumbles looking for an answer:", "abstract": ""}, {"id": 1911291, "score": 38, "vote": 0, "content": "Try the property __dict__.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73928136/python-class-methods-and-conventions", "keywords": [], "tags": ["python", "class", "oop", "package", "conventions"], "question": {"id": 73928136, "title": "Python class, methods and conventions", "content": "Suppose Im creating a class named Bar: Once I create an object of Bar, How should I get the value of the foo variable?\nShould I just type this? Or should I create a method get_foo()? And then write First or second option?", "abstract": ""}, "answers": [{"id": 74056850, "score": 0, "vote": 0, "content": "If you have a class Bar and want to access the variable foo, use your first case that is: But if you want to modify the variable, editing through the object is not recommended. For that, create a function like this: Now you can edit the variable and also access it with the updated value.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71584421/multiple-different-roles-to-a-python-class", "keywords": [], "tags": ["python"], "question": {"id": 71584421, "title": "Multiple different roles to a python class", "content": "What is the best way to apply multiple different \"roles\" to an object of a class. Let's say I have the following classes Then I would like to be able to make certain additional modifications to objects of those classes. For example, I could have multiple different settings that modify some of the options, such as something like: SpecialRole1 that has options 1 and 2 set to False or SpecialRole2 that has options 1 and 4 set to True. Then if I apply SpecialRole1 and SpecialRole2 to BasicAccessSettings (in that order), the resulting settings would be Similarly, I would like to be able to add the same special roles to SpecialAccessSettings if needed. How could this be implemented? I've considered decorators and inheritance, but wasn't really able to figure out the best way. Inheritance would result in a massive amount of different classes but maybe multiple inheritance could be the solution somehow?", "abstract": ""}, "answers": [{"id": 71585739, "score": 0, "vote": 0, "content": "You could manage the permissions (options) in an enum.IntFlag and use it as follows Edit:\nGive the permissions self-explanatory names and provide a decorator in the user class to check permission for specific methods. Edit2: Had a bug in the permission check.", "abstract": ""}, {"id": 71584958, "score": 0, "vote": 0, "content": "Inheritance works well here: Then you can: Which will work as expected giving, the default basic plus the role modifications in order:", "abstract": ""}, {"id": 71584556, "score": 0, "vote": 0, "content": "You can try: output:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70656424/is-there-a-way-to-disable-some-function-in-python-class-so-that-it-cannot-be-use", "keywords": [], "tags": ["python", "python-class", "python-object"], "question": {"id": 70656424, "title": "Is there a way to disable some function in python class so that it cannot be used except using it in inside its class?", "content": "for example i have myClassFile.py file with code as follow: then i have run.py file with code as follow: which when i run will output how to prevent someone to write below code on run.py file or outside myClass ? so that if they used that method outside myClass class it will be an error or some sort", "abstract": ""}, "answers": [{"id": 70656528, "score": 3, "vote": 0, "content": "You can add a level of protection around methods and attributes by prefixing them with __. But you can't make them totally private (as far as I know), there's always a way around, as shown in example below.", "abstract": ""}, {"id": 70656465, "score": -1, "vote": 0, "content": "Python does not have support for these. You can mark them private by prefixing them with _, or make it harder to call them by prefixing them with __. These are called private methods. To make a private variable or a method in python, just prefix it with a __, so def second(self) turns into def __second(self). This also works for variables and functional programming variables! gives an error, but x.test() prints _test out successfully! Note, this can still be run by using x.__Test__test()", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66012667/using-self-in-init-part-of-a-class-in-python", "keywords": [], "tags": ["python-3.x", "class", "neural-network", "pytorch", "self"], "question": {"id": 66012667, "title": "Using self in init part of a class in Python", "content": "Is there any difference between the following two codes related to initializing a class in Python? If there exists any difference, what is that, and which code is preferable? Edit: I am going to write an artificial neural network with Python (and Pytorch). In fact, the above two codes are just some examples. In the actual case, I have seen in various resources that when there exists self.input = input in the initialization of a class, in other parts it is used as self.input, not input. My questions: What are the differences between these two approaches? Why is the use of self.input preferable, in my case? Example: (from https://docs.dgl.ai/en/latest/tutorials/models/1_gnn/4_rgcn.html#sphx-glr-tutorials-models-1-gnn-4-rgcn-py)", "abstract": ""}, "answers": [{"id": 66013317, "score": 2, "vote": 0, "content": "No. there is no difference between these two approaches in your case with this level of information. but could they? Yes. they could. if they have some modifications in their setters or getters. later in my answer I'll show you how. First of all, I prefer using this one: the above implementation calculates the summation on demand. so when you change self.first or self.second, summ will be calculated automatically. you can access the sum as you did before. let's implements them as follows. in setters I doubled the inputs to show you how setters can affect the results. it's just an imaginary example and is not exactly what you wrote. now let's take a look at the outputs: so, if you are not sure what to choose between those two, maybe the first approach is what you need.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61452246/python-class-with-a-lot-of-arguments", "keywords": [], "tags": ["python", "class", "oop"], "question": {"id": 61452246, "title": "Python Class with a lot of arguments", "content": "I am writing a program for my Vocabulary Trainer.\nTherefor I want to create a class for one entry. But the class will get a lot of arguments, currently around 15.\nIs a Class really the right approach then? Or should I make divide that up into functions in the class to get the dates all afterwards?\nThank you for your advice\nStyx1337", "abstract": ""}, "answers": [{"id": 61452509, "score": 3, "vote": 0, "content": "My advice is to find ways to group the arguments into logical units.  Seeing more of the context would make it easier to make concrete suggestions, but the kana... and kanji... groupings suggest that maybe there should be some sort of class to represent progress tracking?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46636267/python-class-as-object", "keywords": [], "tags": ["python", "class", "object"], "question": {"id": 46636267, "title": "Python class as object", "content": "I wonder if the class below becomes an object in a moment when is defined or does it become and object in the moment when I instantiate it? so, blabla is an object. The question is: is the BlaBlaCar class an object too so it is an object on it is own when I not call it? Does it exist in the memory as an object when is defined as 'class BlaBlaCar(object)' ??? EDIT:\nIt is clear to me that when I do: print(BlaBlaCar()) then I instantiate class object. The question is when I create the class body definition do I create object to? ", "abstract": ""}, "answers": [{"id": 46636409, "score": 1, "vote": 0, "content": "I concur with @jonrsharpe 's comment and I think you can find all information you need here. Almost everything in Python is an Object. I looked up some references for this as well. Here, in the Python Docs, it is stated: Class Definition Syntax\n  The simplest form of class definition looks like this: Class definitions, like function definitions (def statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an if statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful \u2014 we\u2019ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods \u2014 again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope \u2014 thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we\u2019ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header (ClassName in the example).  From this you take, that the pure definition of the class is an object. And here I could find this information about objects: 2.4.2. What's an Object?\n  Everything in Python is an object, and almost everything has attributes and methods. All functions have a built-in attribute doc, which returns the doc string defined in the function's source code. The sys module is an object which has (among other things) an attribute called path. And so forth. Still, this begs the question. What is an object? Different programming languages define \u201cobject\u201d in different ways. In some, it means that all objects must have attributes and methods; in others, it means that all objects are subclassable. In Python, the definition is looser; some objects have neither attributes nor methods (more on this in Chapter 3), and not all objects are subclassable (more on this in Chapter 5). But everything is an object in the sense that it can be assigned to a variable or passed as an argument to a function (more in this in Chapter 4). This is so important that I'm going to repeat it in case you missed it the first few times: everything in Python is an object. Strings are objects. Lists are objects. Functions are objects. Even modules are objects. Be aware, however, that no instance is created with the class definition until:", "abstract": ""}, {"id": 46636546, "score": 0, "vote": 0, "content": "First, to dispell any doubt, a class definition does give you an object representing the class itself (not an instance): So you see BlaBlaCar is an object in memory. You ask, \"where is the class object created to?\" The class definition normally is in a module (or in the example above, in the current namespace, which is __main__).  When this module is executed, a module object is created.  As part of module execution, any class definition executed will result in a class object which is then bound to the class name in the module's namespace.   So in a sense, you can say the class object is \"in\" the module's namespace.  But really, you can ask a similar question, \"where is the module object created to?\", at which point, the answer just is that the interpreter creates the object and has one or more references to it, just like any other object you create. A subtlety is that the garbage collector will collect any object that doesn't have a reference to it.  In the case of the class object, the surrounding module has it in its namespace.  In the case of the module itself, there is always a reference from places like sys.modules.  ", "abstract": ""}, {"id": 46636506, "score": 1, "vote": 0, "content": "As has been pointed out elsewhere, almost everything in Python is an object.\nHowever, I feel that your question The question is when I create the class body definition do I create object to?  has not been addressed directly yet. When Python executes the definition of the class, yes, an object is created. But it is important to note that ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/36640673/why-should-i-use-classes-in-python", "keywords": [], "tags": ["python", "class", "oop"], "question": {"id": 36640673, "title": "Why should I use classes in python?", "content": "I am a  very amateur learner of Python, and I have recently started learning the concept of classes. I can understand the concept of classes (very) roughly, but I can't understand why I can't simply write some functions instead of writing a class? For example, (I am learning from Interactive python) one of the exercise given (which I am supposed to write using a class) is : Add a distanceFromPoint method that works similar to distanceFromOrigin except that it takes a Point as a parameter and computes the distance between that point and self. Add a method reflect_x to Point which returns a new Point, one which is the reflection of the point about the x-axis. For example, Point(3, 5).reflect_x() is (3, -5). They written the code using classes like this:  Why should I use class when I can write them simply like this: ", "abstract": ""}, "answers": [{"id": 36642170, "score": 0, "vote": 0, "content": "Your example of a point is a bad one for justifying the use of classes.  A class is a great way of describing what something is rather than manipulating data. So a point just has two bits of information describing it (in 2D space anyway).  Think of something more abstract, like, a movie file. Movies have all sorts of information associated with them: title, duration, genres, actors, age rating, popularity, language, awards... goes on. Try writing functions that handle a long list of all of this information and you will quickly see the merits of a class. Maths is maybe the one area where there really isn't that much contextual information, there are only a few variables and they define everything. Real-world data is less clearly defined and so benefits from the extensibility of classes.", "abstract": ""}, {"id": 36641737, "score": 22, "vote": 0, "content": "One of the big advantages of using OOP is extensibility. Let's say you'd written an application that processes lots of data in the form of points. Now your customer adds to the specification that as well as the x and y coordinate of each point, your app needs to know what colour each point is. If you'd written your code to store each point as a tuple, (x, y), you might add the colour as a third value: (x, y, colour). But now you have to go through all of your code to find the places where it's broken because you changed the data format. If you'd used a class, you could simply define a new class that inherits from Point and adds the necessary capabilities: All your code that worked with the Point class will still work with the new class, and you can do this even if you didn't write, or can't change, the definition of the Point class.", "abstract": ""}, {"id": 36641026, "score": 0, "vote": 0, "content": "Functional and object-oriented programming are different paradigms. In Python, everything is an object, even ints. The whole language goes towards object-oriented programming, which is why you should prefer going for it, especially if your program will grow.", "abstract": ""}, {"id": 36640908, "score": 3, "vote": 0, "content": "You can declare a function outside of a class.\nBut storing them in class is a better pratice in general in programming. OOP is considered to be more readable and also reusable. And in this case, the distance between two points depends on points, so it's logical to have the distanceFromPoint method in this class. Class also allow you to be sure than you calculate the distance from Points and not for tuples who can contains bad values, like more than two coordinates.", "abstract": ""}]}]