[{"link": "https://stackoverflow.com/questions/75908947/list-context-and-the-comma-operator-in-perl", "keywords": [], "tags": ["list", "perl", "operator-precedence", "scalar", "comma-operator"], "question": {"id": 75908947, "title": "List context and the comma operator in Perl", "content": "Having some significant confusion about what it means to \"evaluate in list context\", specifically related to the comma operator. In the linked perlop doc, it says: In list context, it's just the list argument separator, and inserts both its arguments into the list. However,  the code gives output 9, 1. This respects the fact that, when used as a binary operator on scalar values (?), the comma operator , has lower precedence that the assignment = operator. But since I'm assigning to the list @y, shouldn't the right hand side of the assignment be evaluated in list context and, by the above quote, treat the comma simply as a separator? I suspect that I just don't truly understand what it \"evaluate in list context\" means, precisely...", "abstract": ""}, "answers": [{"id": 75909711, "score": 6, "vote": 0, "content": "The problem has nothing to do with context.[1] It's a precedence issue. Assignment has higher precedence than comma, so means but you want Note that the parens do nothing but override precedence. Warnings would have caught this. Always use use strict; use warnings; or equivalent! I suspect that I just don't truly understand what it \"evaluate in list context\" means, precisely... Each operator decides what to do and what to return based on the context in which they are evaluated. It does not, however, change how code is parsed.", "abstract": ""}, {"id": 75914218, "score": 0, "vote": 0, "content": "The array at the LHS of an assignment is actually enforcing list context [1], but the comma is not part of the RHS because of precedence. That's why in  @y = 9, 8, 7, 6; the commas are actually in void context.\nIkegami and others already explained this. But to answer your main question: I suspect that I just don't truly understand what it \"evaluate in list context\" means, precisely... Yes I have to admit that's a bit confusing here. For better understanding, here an example where you can see the effect of the three main contexts in Perl on a literal comma separated list. The callers context propagates to the return of a sub-routine, that's why you see the complete LIST in list-context and only the last element when the scalar comma operator is used. ctxt() is just a helper function I hacked, which you can use to find out which context you are dealing with in the future. HTH! :)", "abstract": ""}, {"id": 75909986, "score": 2, "vote": 0, "content": "...shouldn't the right hand side of the assignment be evaluated in list context... Just to emphasize this: yes, it should and it is -- after precedence rules are applied first. See that with It prints two warnings for Useless use of a constant... (for a and b), and then the values returned when localtime runs in a list context (and not the timestamp string, what it does in a scalar context).", "abstract": ""}, {"id": 75909100, "score": 2, "vote": 0, "content": "If you turn on warnings like you should, perl will give you some hints as to what's going on: running it shows @y = 9, 8, 7, 6 is an example of the comma operator in scalar context, and, as you noted, precedence rules. It's parsed as four different sub-expressions separated by commas: first @y = 9 assigns a single-element list to @y, and then the expressions 8, 7 and 6, all of which do nothing and generate warnings, and the whole thing would return 6 if there was anything to return to. If you want to assign a list to the variable, that list needs to be in parenthesis:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16582301/why-doesnt-comma-operator-seem-to-work-between-a-if-statement-and-an-else-s", "keywords": [], "tags": ["c", "if-statement", "comma-operator", "sequence-points"], "question": {"id": 16582301, "title": "Why doesn&#39;t comma operator seem to work between a &quot;if&quot; statement and an &quot;else&quot; statement in my code?", "content": "I know a statement like the following (commas in place of semi-colons) looks odd: But it works perfectly fine and I had read that it's because comma here acts as a sequence point.I can understand this.But I just fail to understand why the following fails then,where I have used a else as well: It gives the error expected expression before 'else'. Why does the second statement gives error?In the first statement, we saw that comma acts as a sequence point.Then why it doesn't act so before else?What's special about the second case that causes error?Here's my full program:", "abstract": ""}, "answers": [{"id": 16583125, "score": 0, "vote": 0, "content": "In 2nd case else is no having matching if, what is happening here is after printf(\"Hi\\n\"), when else arrives compiler looks for if i.e else should come only after terminated if statement. so it is giving error.", "abstract": ""}, {"id": 16582673, "score": 6, "vote": 0, "content": "The comma operator expects an expression and the else part of an if else construct ain't an expression. Thus a comma followed by the keyword else is a syntax error.", "abstract": ""}, {"id": 16582501, "score": 4, "vote": 0, "content": "Imagine, that: is translated to: In this case, return here means \"insert in place of this expression\". And indeed, , acts as a sequence point. Then,  would look like: But Would look like: And the else inside does not make any sense. That's why compiler complaints. In other words, , in C++ is an operator. So by the operator precedence, is interpreted as Which clearly violates the C++ syntax rules.", "abstract": ""}, {"id": 16582622, "score": 0, "vote": 0, "content": "Look at the correct syntax of IF-ELSE statement. Compiler expects semicolon to know that IF is ended. So you are basically trying to enter sub if-else statement into the first one, but without new if. So, either the curly brackets \"{}\" indicate the IF region, or if they are missing,  IF statement valid until the first semicolon.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72081593/assignment-destructuring-and-operator-precedence", "keywords": [], "tags": ["raku", "rakudo"], "question": {"id": 72081593, "title": "Assignment destructuring and operator precedence", "content": "The documentation says that the comma operator has higher precedence than the assignment = operator, and this is specifically different than in Perl, so that we are allowed to remove parentheses in some contexts. This allows us to do things like this: What I don't understand is why when do something like this: $b get assigned [1 2] while $a gets no value. While I would assume that the following would be equivalent, because the comma operator is tighter than the assignment. The semantics of Raku have a lot of subtlety and I guess I am thinking too much in terms of Perl. Like raiph said in the comments, my original assumption that the comma operator has higher precedence than the assignment operator was false. And it was due to a problem in the rendering of the operator precedence table, which didn't presented operators in their precedence order.\nThis explains the actual behavior of Raku for my examples.", "abstract": ""}, "answers": [{"id": 72105903, "score": 6, "vote": 0, "content": "The = operator itself is always item assignment level, which is tighter than comma. However, it may apply a \"sub-precedence\", which is how it is compared to any further infixes in the expression that follow it. The term that was parsed prior to the = is considered, and: To consider some cases (first, where it doesn't impact anything): If we have a single variable on the left and a list on the right, then: These apply with the = initializer (following a my $var declaration). This means that: Will result in $i being assigned 0 and $j being assigned $end. Effectively, the rule means we get to have parentheses-free initialization of array and hash variables, while still having lists of scalar initializations work out as in the loop case. Turning to the examples in the question. First, this: Parses a single term, then encounters the =. The precedence when comparing any following infixes would be list prefix (looser than ,). However, there are no more infixes here, so it doesn't really matter. In this case: The precedence parser sees the , infix, followed by the = infix. The = infix in itself is tighter than comma (item assignment precedence); the sub-precedence is only visible to infixes parsed after the = (and there are none here). Note that were it not this way, and the precedence shift applied to the expression as a whole, then: Would end up grouped not as (my $i = 0), (my @lagged = Nil, |@values), but rather (my $i = 0, my @lagged) = Nil, |@values, which is rather less useful.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66176774/python-tuple-ending-with-comma-difference", "keywords": [], "tags": ["python", "mysql-python"], "question": {"id": 66176774, "title": "python tuple ending with comma difference", "content": "What is the difference between and I noticed that for example mysql wrapper parameters formatting doesn't work with the first case, it must end with comma.", "abstract": ""}, "answers": [{"id": 72329951, "score": 0, "vote": 0, "content": "This code below which is not \"Tuple\" is : Same as this code below: While this code below is \"Tuple\":", "abstract": ""}, {"id": 66176844, "score": 1, "vote": 0, "content": "if you write only one element in parentheses (), the parentheses () are ignored and not considered a tuple. output: str to generate a one-element tuple, a comma , is needed at the end. ouput : tuple", "abstract": ""}, {"id": 66176935, "score": 1, "vote": 0, "content": "when using only parentheses, you are not creating a tuple, because the interpreter treats this as increasing operator precedence (just like parentheses in mathematics), and if you put a comma, the interpreter will understand that we are trying to create a tuple with one element, and do not increase priority", "abstract": ""}, {"id": 66176884, "score": 1, "vote": 0, "content": "The First will create a string and the second will make a tuple. That's actually the difference between making a tuple and a string between two parentheses.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52550/what-does-the-comma-operator-do", "keywords": [], "tags": ["c", "operators", "comma-operator"], "question": {"id": 52550, "title": "What does the comma operator , do?", "content": "What does the , operator do in C?", "abstract": ""}, "answers": [{"id": 52558, "score": 179, "vote": 0, "content": "The expression: First expression1 is evaluated, then expression2 is evaluated, and the value of expression2 is returned for the whole expression.", "abstract": ""}, {"id": 18444099, "score": 49, "vote": 0, "content": "The comma operator will evaluate the left operand, discard the result and then evaluate the right operand and that will be the result. The idiomatic use as noted in the link is when initializing the variables used in a for loop, and it gives the following example: Otherwise there are not many great uses of the comma operator, although it is easy to abuse to generate code that is hard to read and maintain. From the draft C99 standard the grammar is as follows: and paragraph 2 says: The left operand of a comma operator is evaluated as a void expression; there is a sequence point after its evaluation. Then the right operand is evaluated; the result has its type and value. 97) If an attempt is made to modify the result of a comma operator or to access it after the next sequence point, the behavior is undefined. Footnote 97 says: A comma operator does not yield an lvalue. which means you can not assign to the result of the comma operator. It is important to note that the comma operator has the lowest precedence and therefore there are cases where using () can make a big difference, for example: will have the following output:", "abstract": ""}, {"id": 54038455, "score": -2, "vote": 0, "content": "I'm reviving this simply to address questions from @Rajesh and @JeffMercado which i think are very important since this is one of the top search engine hits. Take the following snippet of code for example  It will print The i case is handled as explained by most answers. All expressions are evaluated in left-to-right order but only the last one is assigned to i. The result of the ( expression )is1`.  The j case follows different precedence rules since , has the lowest operator precedence. Because of those rules, the compiler sees assignment-expression, constant, constant .... The expressions are again evaluated in left-to-right order and their side-effects stay visible, therefore, j is 5 as a result of j = 5. Interstingly, int j = 5,4,3,2,1; is not allowed by the language spec. An initializer expects an assignment-expression so a direct , operator is not allowed. Hope this helps.", "abstract": ""}, {"id": 52615, "score": 150, "vote": 0, "content": "I've seen used most in while loops: It will do the operation, then do a test based on a side-effect. The other way would be to do it like this:", "abstract": ""}, {"id": 57573, "score": 30, "vote": 0, "content": "The comma operator combines the two expressions either side of it into one, evaluating them both in left-to-right order.  The value of the right-hand side is returned as the value of the whole expression.\n (expr1, expr2) is like { expr1; expr2; } but you can use the result of expr2 in a function call or assignment. It is often seen in for loops to initialise or maintain multiple variables like this: Apart from this, I've only used it \"in anger\" in one other case, when wrapping up two operations that should always go together in a macro.  We had code that copied various binary values into a byte buffer for sending on a network, and a pointer maintained where we had got up to: Where the values were shorts or ints we did this: Later we read that this was not really valid C, because (short *)ptr is no longer an l-value and can't be incremented, although our compiler at the time didn't mind.  To fix this, we split the expression in two: However, this approach relied on all developers remembering to put both statements in all the time.  We wanted a function where you could pass in the output pointer, the value and and the value's type.  This being C, not C++ with templates, we couldn't have a function take an arbitrary type, so we settled on a macro: By using the comma operator we were able to use this in expressions or as statements as we wished: I'm not suggesting any of these examples are good style!  Indeed, I seem to remember Steve McConnell's Code Complete advising against even using comma operators in a for loop: for readability and maintainability, the loop should be controlled by only one variable, and the expressions in the for line itself should only contain loop-control code, not other extra bits of initialisation or loop maintenance.", "abstract": ""}, {"id": 52590, "score": 2, "vote": 0, "content": "The only place I've seen it being useful is when you write a funky loop where you want to do multiple things in one of the expressions (probably the init expression or loop expression. Something like: Pardon me if there are any syntax errors or if I mixed in anything that's not strict C. I'm not arguing that the , operator is good form, but that's what you could use it for. In the case above I'd probably use a while loop instead so the multiple expressions on init and loop would be more obvious. (And I'd initialize i1 and i2 inline instead of declaring and then initializing.... blah blah blah.)", "abstract": ""}, {"id": 52571, "score": 3, "vote": 0, "content": "As earlier answers have stated it evaluates all statements but uses the last one as the value of the expression. Personally I've only found it useful in loop expressions:", "abstract": ""}, {"id": 52559, "score": 8, "vote": 0, "content": "It causes the evaluation of multiple statements, but uses only the last one as a resulting value (rvalue, I think). So... should result in x being set to 8.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/68554636/in-python-what-is-the-order-of-operations-for-the-walrus-operator", "keywords": [], "tags": ["python", "python-3.x", "walrus-operator"], "question": {"id": 68554636, "title": "In Python, What is the order of operations for the walrus operator?", "content": "It would be very useful if someone could give the answer by adding a W into PEMDAS. Thanks.", "abstract": ""}, "answers": [{"id": 68554666, "score": 5, "vote": 0, "content": "It is lower than everything except the comma operator.  https://www.python.org/dev/peps/pep-0572/", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16854007/comma-operator-precedence-while-used-with-operator", "keywords": [], "tags": ["c++", "c", "operator-precedence", "comma-operator"], "question": {"id": 16854007, "title": "Comma operator precedence while used with ? : operator", "content": "I have no idea why the result of the two sub programs below are different: However for these cases, the results are identical: Why parentheses make difference for the statement after \"?\", but make no difference for the statement after \":\"? Do you have any idea?", "abstract": ""}, "answers": [{"id": 16854294, "score": 4, "vote": 0, "content": "The relevant parts of the C++ grammar are: In summary, while the 'middle' of a conditional expression can be a full expression extending up to the :, the last sub-expression can only be an assignment-expression which excludes expressions using the comma operator (other than where the comma operator appears as part of valid sub-expression of an assignment-expression such as a parenthesized primary-expression or as the second operand of another conditional-expression). In C, the last sub-expression is more restricted, it cannot even be an assignment-expression although this is not a concern in your example.", "abstract": ""}, {"id": 16854093, "score": 3, "vote": 0, "content": "In this case  It is equivalent to ", "abstract": ""}, {"id": 16854098, "score": 2, "vote": 0, "content": "I guess it's because x ? y cannot be considered a valid expression, therefore the comma can't split the operator there. x ? y : z is a valid expression, the the comma after the colon can split into two expressions.", "abstract": ""}, {"id": 16854081, "score": 24, "vote": 0, "content": "This one: is equivalent to: so b is always incremented and only sometimes decremented.  There is no way to parse the comma operator between ? and : other than as parenthesized in the 'equivalent to' expression.  But after the :, the unparenthesized comma terminates the ternary ?: operator and leaves the increment as unconditionally executed.  The precedence of the comma operator is very, very low.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/57877543/comma-operator-precedence", "keywords": [], "tags": ["python"], "question": {"id": 57877543, "title": "Comma operator precedence", "content": "Couldn't find a unified resource that documents/explains this. I'm puzzled; is it an operator or not? Most importantly, what is its precedence? An example: Note that the comma isn't even listed as an operator in the link in the code comments. But here it is called an operator: https://docs.python.org/3/reference/expressions.html#parenthesized-forms Python version: 3.7.4 EDIT: I had originally provided this as an additional but incorrect example: But that was my mistake, because was incorrect, and after running it again I saw that when corrected it is: Therefore the comma precedence is behaving consistently in the example that was removed in the edit.", "abstract": ""}, "answers": [{"id": 57877610, "score": 5, "vote": 0, "content": "The right hand side: is evaluated first, and can be visualized as ((4 if False else 3), 2), which is an implicit tuple (a tuple without (), but a tuple nonetheless), and will eventually be 3, 2 or 4, 2 (depending on the evaluation of the if condition), then, the assignments will be made depending on what's on the left hand side, so, since there's only one variable on the left hand side in x = 4 if False else 3, 2, x will be a tuple ((3, 2) or (4, 2)), but if you use unpacking, as in x, y = 4 if False else 3, 2, the assignment will be:", "abstract": ""}, {"id": 57877762, "score": 2, "vote": 0, "content": "The RHS is parsed as a tuple in both cases, is possible to see this by printing the AST generated.  The difference is that in second case unpacking happens while in the first it doesn't The documentation that cover this is a little hard to track. First the assignment expression is found here\nhttps://docs.python.org/3.7/reference/simple_stmts.html#assignment-statements The RHS part is a starred_expression which leads to https://docs.python.org/3.7/reference/expressions.html#expression-lists Except when part of a list or set display, an expression list\n  containing at least one comma yields a tuple. The length of the tuple\n  is the number of expressions in the list. The expressions are\n  evaluated from left to right. Take a note here: containing at least one comma yields a tuple So here is your answer. Anything in RHS with a comma, that is not a list or a set, yields a tuple  I hope that helps", "abstract": ""}, {"id": 57877800, "score": 3, "vote": 0, "content": "The documentation of Assignment Statements makes a distinction between assigning to a single target or multiple targets.  If the target list is a single target with no trailing comma, optionally in parentheses, the object is assigned to that target. So in the first case, the RHS of the assignment (called the \"object\" in the documentation) is parsed as a single object. The comma is parsed as the value of the else clause of the conditional expression. Else: The object must be an iterable with the same number of items as there are targets in the target list, and the items are assigned, from left to right, to the corresponding targets. So in this case it first tries to parse the RHS as an iterable expression with two items. The comma is treated as the delimiter between the items in a generator expression.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6922677/does-python-have-a-comma-operator-like-c", "keywords": [], "tags": ["python"], "question": {"id": 6922677, "title": "does python have a comma operator like C", "content": "in C (and C family of languages) an expression (4+7, 5+2) returns 7. But the same expression in Python would result in a tuple (11, 7) So does python have a comma operator like C ?", "abstract": ""}, "answers": [{"id": 54932615, "score": 1, "vote": 0, "content": "An update to this question.  As it stands the accepted answer is incomplete since it does not allow assignment expressions to be used in this manner, (e.g. (a = 1, a+2)[-1] would generate an error). Python 3.8 is now coming up with Assignment Expressions which in theory should make this possible, i.e.", "abstract": ""}, {"id": 6922806, "score": 9, "vote": 0, "content": "You should use something like this to replace it: but as noted correctly in the comments, why would you want it? It is used in C or C++ quite seldomly and there are good reasons for that.", "abstract": ""}, {"id": 6922693, "score": 4, "vote": 0, "content": "AFAIK, no. Though you can always simulate this by using two lines instead of one. :-)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/43805222/why-trailing-comma-in-if-else-expressions-second-condition-causes-first-conditi", "keywords": [], "tags": ["python", "if-statement", "syntax", "tuples"], "question": {"id": 43805222, "title": "Why trailing comma in if-else expression&#39;s second condition causes first condition to be casted to tuple", "content": "The syntax of declaring tuples with commas is clear and everywhere I saw it it is being used with literals enclosed in braces e.g. (1,).  However, python does allow to use commas without enclosing braces to declare tuples, and there is strange behavior in one particular case, see the code below. Output: Tested on 2.7 and 3.5.\nCan someone explain why 1 is implicitly converted to the tuple?", "abstract": ""}, "answers": [{"id": 43805300, "score": 2, "vote": 0, "content": "It is because the ternary operator (a if b else c) is stronger than the \"comma\" operator. You may compare it with logical or and and operators where and is stronger than or:", "abstract": ""}, {"id": 43805267, "score": 6, "vote": 0, "content": "It's simply the order of operations:", "abstract": ""}]}]