[{"link": "https://stackoverflow.com/questions/75535298/py-to-exe-but-code-obfuscated-how-to-convert-it", "keywords": [], "tags": ["python", "pyinstaller", "exe"], "question": {"id": 75535298, "title": ".py to .exe but code obfuscated. how to convert it?", "content": "I wrote simple scrypt on python, obfuscated all main .py files with https://github.com/htr-tech/PyObfuscate. Now need to convert all this stuff to .exe Problem is that now pyinstaller cant see imports of .py files and libraries at all. Before obfuscating i could easily convert this to .exe but now its not working. Is there solution to choose libraries and other .py files imports manually to create correctly working .exe file? Python version is 3.10 if its needed I tried pyinstaller default build config and auto-py-to-exe", "abstract": ""}, "answers": [{"id": 75536599, "score": 0, "vote": 0, "content": "I used cx-Freeze with custom setup.py where included all i needed, works fine for me", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/3344115/how-to-obfuscate-python-code-effectively", "keywords": [], "tags": ["python"], "question": {"id": 3344115, "title": "How to obfuscate Python code effectively?", "content": "I am looking for how to hide my Python source code. How can I encode this example so that it isn't human-readable?  I've been told to use base64 but I'm not sure how.", "abstract": ""}, "answers": [{"id": 42094534, "score": 17, "vote": 0, "content": "Maybe you can try on pyconcrete, it's my open-source project encrypt .pyc to .pye and decrypt when import it encrypt & decrypt by library OpenAES convert all of your .py to *.pye remove *.py *.pyc or copy *.pye to other folder main.py encrypted as main.pye, it can't be executed by normal python.\nYou must use pyconcrete to process the main.pye script.\npyconcrete(exe) will be installed in your system path (ex: /usr/local/bin) download pyconcrete source and install by setup.py import pyconcrete in your main script recommendation project layout", "abstract": ""}, {"id": 67700239, "score": 1, "vote": 0, "content": "Here's my very noob approach for something I'm doing in CircuitPython.  It's currently partially tested. I've posted in this state because I thought it might be useful. There are two arguments: Here's what it does: It turns code like this ...into code like this: The comments can be omitted if necessary. Here's the code that does it:", "abstract": ""}, {"id": 68214794, "score": 18, "vote": 0, "content": "I would really recommend Nuitka over Cython. Nuitka also compiles Python to native platform code providing a similar level of obfuscation like compiled C code. Add the flags --onefile or -standalone if this works to get a package for distribution. I also used pyarmor referenced here, but the pytransform.so or pytransform.dll shared object which is the core of pyarmor is closed source, which was a blocker in my project.", "abstract": ""}, {"id": 39321698, "score": 42, "vote": 0, "content": "You could embed your code in C/C++ and compile\nEmbedding Python in Another Application embedded.c In Ubuntu/Debian In Centos/Redhat/Fedora compile with run with initial script: hello_world.py: run the script however some strings of the python code may be found in the compiled file In case you want an extra bit of obfuscation you could use base64 e.g: create the base 64 string of your code embedded_base64.c all commands this project (pyarmor) might also help: https://pypi.org/project/pyarmor/", "abstract": ""}, {"id": 65169500, "score": 9, "vote": 0, "content": "I know it is an old question. Just want to add my funny obfuscated \"Hello world!\" in Python 3 and some tips ;) It is possible to do manually, my tips are: use eval and/or exec with encrypted strings use [ord(i) for i in s] / ''.join(map(chr, [list of chars goes here])) as simple encryption/decryption use obscure variable names make it unreadable Don't write just 1 or True, write 1&True&0x00000001 ;) use different number systems add confusing comments like \"line 2\" on line 10 or \"it returns 0\" on while loop. use __builtins__ use getattr and setattr", "abstract": ""}, {"id": 58979147, "score": 19, "vote": 0, "content": "Check out these tools for obfuscation and minification of python code: Example .py output from pyminifier when run with --obfuscate and --gzip: $ pyminifier --obfuscate --gzip /tmp/tumult.py This output corresponds to a 40-line original input script as shown here.", "abstract": ""}, {"id": 28573360, "score": 17, "vote": 0, "content": "Well if you want to make a semi-obfuscated code you make code like this: and make a file like this (using the above code): file \"something.py\": just import \"something.py\" and run run(something.code) to run the code in the file. One trick is to make the code hard to read by design: never document anything, if you must, just give the output of a function, not how it works. Make variable names very broad, movie references, or opposites example: btmnsfavclr = 16777215 where as \"btmnsfavclr\" means \"Batman's Favorite Color\" and the value is 16777215 or the decimal form of \"ffffff\" or white. Remember to mix different styles of naming to keep those pesky people of of your code. Also, use tips on this site: Top 11 Tips to Develop Unmaintainable Code.", "abstract": ""}, {"id": 48876884, "score": 4, "vote": 0, "content": "Compile python source file to code object  Iterate code object, wrap bytecode of each code object as the following    format Serialize code object and obfuscate it Create wrapper script \"xxx.py\", ${obfuscated_code} stands for string constant generated in previous step. When import or run this wrapper script, the first statement is to call a CFunction: This function accepts 2 parameters: module name and obfuscated code, then After module imported, when any code object in this module is called\nfirst time, from the wrapped bytecode descripted in above section, we\nknow First op JUMP_ABSOLUTE jumps to offset n At offset n, the instruction is to call a PyCFunction. This function\nwill restore those obfuscated bytecode between offset 3 and n, and\nplace the original bytecode at offset 0 After function call, the last instruction jumps back to\noffset 0. The real bytecode is now executed Refer to Pyarmor", "abstract": ""}, {"id": 52818963, "score": 36, "vote": 0, "content": "Cython It seems that the goto answer for this is Cython.  I'm really surprised no one else mentioned this yet?  Here's the home page: https://cython.org In a nutshell, this transforms your python into C and compiles it,  thus making it as well protected as any \"normal\" compiled distributable C program.   There are limitations though.  I haven't explored them in depth myself, because as I started to read about them, I dropped the idea for my own purposes.  But it might still work for yours.  Essentially, you can't use Python to the fullest, with the dynamic awesomeness it offers.  One major issue that jumped out at me, was that keyword parameters are not usable :( You must write function calls using positional parameters only.  I didn't confirm this, but I doubt you can use conditional imports, or evals.  I'm not sure how polymorphism is handled... Anyway, if you aren't trying to obfuscate a huge code base after the fact, or ideally if you have the use of Cython in mind to begin with, this is a very notable option.", "abstract": ""}, {"id": 54503068, "score": 8, "vote": 0, "content": "The best way to do this is to first generate a .c file, and then compile it with tcc to a .pyd file\nNote: Windows-only Requirements Install: To obfuscate your .py file: To generate a .c file, Add an init<filename>() function to your .py file Optional cython --embed file.py cp Python.h tcc\\include tcc file.c -o file.pyd -shared -I\\path\\to\\Python\\include -L\\path\\to\\Python\\lib import .pyd file into app.exe", "abstract": ""}, {"id": 52835659, "score": 5, "vote": 0, "content": "Opy https://github.com/QQuick/Opy Opy will obfuscate your extensive, real world, multi module Python\n  source code for free! And YOU choose per project what to obfuscate and\n  what not, by editing the config file: Unlike some of the other options posted, this works for both Python 2 and 3! It is also free / opensource, and it is not an online only tool (unless you pay) like some of the others out there.  I am admittedly still evaluating this myself, but all of initial tests of it worked perfectly.  It appears this is exactly what I was looking for! The official version runs as a standalone utility, with the original intended design being that you drop a script into the root of the directory you want to obfuscate, along with a config file to define the details/options you want to employ.  I wasn't in love with that plan, so I added a fork from project, allowing you to import and utilize the tool from a library instead.  That way, you can roll this directly into a more encompassing packaging script. (You could of course wrap multiple py scripts in bash/batch, but I think a pure python solution is ideal). I requested my fork be merged into the original work, but in case that never happens, here's the url to my revised version: https://github.com/BuvinJT/Opy", "abstract": ""}, {"id": 49895327, "score": 6, "vote": 0, "content": "Try this python obfuscator: pyob.oxyry.com\npyob.oxyry.c will translated to", "abstract": ""}, {"id": 7418341, "score": 112, "vote": 0, "content": "This is only a limited, first-level obfuscation solution, but it is built-in: Python has a compiler to byte-code: produces a .pyo file that contains byte-code, and where docstrings are removed, etc.  You can rename the .pyo file with a .py extension, and python <your program.py> runs like your program but does not contain your source code. PS: the \"limited\" level of obfuscation that you get is such that one can recover the code (with some of the variable names, but without comments and docstrings). See the first comment, for how to do it. However, in some cases, this level of obfuscation might be deemed sufficient. PPS: If your program imports modules obfuscated like this, then you need to rename them with a .pyc suffix instead (I'm not sure this won't break one day), or you can work with the .pyo and run them with python -O \u2026.pyo (the imports should work).  This will allow Python to find your modules (otherwise, Python looks for .py modules).", "abstract": ""}, {"id": 43145191, "score": 0, "vote": 0, "content": "Try pasting your hello world python code to the following site: http://enscryption.com/encrypt-and-obfuscate-scripts.html It will produce a complex encrypted and obfuscated, but fully functional  script for you.  See if you can crack the script and reveal the actual code.  Or see if the level of complexity it provides satisfies your need for peace of mind.  The encrypted script that is produced for you through this site should work on any Unix system that has python installed.  If you would like to encrypt another way, I strongly suggest you write your own encryption/obfuscation algorithm (if security is that important to you). That way, no one can figure out how it works but you.  But, for this to really work, you have to spend a tremendous amount of time on it to ensure there aren't any loopholes that someone who has a lot of time on their hands can exploit.  And make sure you use tools that are already natural to the Unix system... i.e. openssl or base64. That way, your encrypted script is more portable.", "abstract": ""}, {"id": 28994533, "score": 8, "vote": 0, "content": "I would mask the code like this:", "abstract": ""}, {"id": 43403000, "score": 11, "vote": 0, "content": "There are multiple ways to obfuscate code. Here's just one example:", "abstract": ""}, {"id": 18605460, "score": 6, "vote": 0, "content": "I recently stumbled across this blogpost: Python Source Obfuscation using ASTs where the author talks about python source file obfuscation using the builtin AST module. The compiled binary was to be used for the HitB CTF and as such had strict obfuscation requirements. Since you gain access to individual AST nodes, using this approach allows you to perform arbitrary modifications to the source file. Depending on what transformations you carry out, resulting binary might/might not behave exactly as the non-obfuscated source.", "abstract": ""}, {"id": 3344502, "score": 44, "vote": 0, "content": "so that it isn't human-readable? i mean all the file is encoded !! when you open it you can't understand anything .. ! that what i want As maximum, you can compile your sources into bytecode and then distribute only bytecode. But even this is reversible. Bytecode can be decompiled into semi-readable sources. Base64 is trivial to decode for anyone, so it cannot serve as actual protection and will 'hide' sources only from complete PC illiterates. Moreover, if you plan to actually run that code by any means, you would have to include decoder right into the script (or another script in your distribution, which would needed to be run by legitimate user), and that would immediately give away your encoding/encryption. Obfuscation techniques usually involve comments/docs stripping, name mangling, trash code insertion, and so on, so even if you decompile bytecode, you get not very readable sources. But they will be Python sources nevertheless and Python is not good at becoming unreadable mess. If you absolutely need to protect some functionality, I'd suggest going with compiled languages, like C or C++, compiling and distributing .so/.dll, and then using Python bindings to protected code.", "abstract": ""}, {"id": 3344212, "score": 39, "vote": 0, "content": "You can use the base64 module to encode strings to stop shoulder surfing, but it's not going to stop someone finding your code if they have access to your files. You can then use the compile() function and the eval() function to execute your code once you've decoded it. So if you have 30 lines of code you'll probably want to encrypt it doing something like this: You'd then need to write a second script that does the compile() and eval() which would probably include the encoded script as a string literal encased in triple quotes.  So it would look something like this:", "abstract": ""}, {"id": 3345808, "score": -2, "vote": 0, "content": "I'll write my answer in a didactic manner... First type into your Python interpreter: then, go and take a look to the file this.py in your Lib directory within your Python distribution and try to understand what it does. After that, take a look to the eval function in the documentation: Now you should have found a funny way to protect your code. But beware, because that only works for people that are less intelligent than you! (and I'm not trying to be offensive, anyone smart enough to understand what you did could reverse it).", "abstract": ""}, {"id": 3345658, "score": 7, "vote": 0, "content": "Maybe you should look into using something simple like a truecrypt volume for source code storage as that seems to be a concern of yours.  You can create an encrypted file on a usb key or just encrypt the whole volume (provided the code will fit) so you can simply take the key with you at the end of the day. To compile, you could then use something like PyInstaller or py2exe in order to create a stand-alone executable.  If you really wanted to go the extra mile, look into a packer or compression utility in order to add more obfuscation.  If none of these are an option, you could at least compile the script into bytecode so it isn't immediately readable.  Keep in mind that these methods will merely slow someone trying to debug or decompile your program.", "abstract": ""}, {"id": 3344675, "score": 3, "vote": 0, "content": "As other answers have stated, there really just isn't a way that's any good. Base64 can be decoded. Bytecode can be decompiled. Python was initially just interpreted, and most interpreted languages try to speed up machine interpretation more than make it difficult for human interpretation. Python was made to be readable and shareable, not obfuscated. The language decisions about how code has to be formatted were to promote readability across different authors. Obfuscating python code just doesn't really mesh with the language. Re-evaluate your reasons for obfuscating the code.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/68725572/python-only-encryption-obfuscation", "keywords": [], "tags": ["python", "encryption", "python-3.7", "obfuscation"], "question": {"id": 68725572, "title": "Python only encryption/obfuscation", "content": "I'm looking for simple password-based obfuscation/security of strings.\nI've pretty much gone over each example of > Simple way to encode a string according to a password?\nAnd none of them work with my python 3.7.\nI got the error with ord() so I updated the code, but even after, its still broken. For examle: Gives me", "abstract": ""}, "answers": [{"id": 68727848, "score": 0, "vote": 0, "content": "In encode_zip_cycle you encode the \"encrypted\" string into utf-8 before doing the second encoding into base64. Yet, you don't revert this operation later in decode_zip_cycle. This is the correct decode_zip_cycle function:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64766307/is-it-possible-to-combine-obfuscated-files-into-one-file-using-pyarmor", "keywords": [], "tags": ["python", "pyarmor"], "question": {"id": 64766307, "title": "Is it possible to combine obfuscated files into one file using Pyarmor?", "content": "If I obfuscate test.py with Pyarmor, I would run a command like this: However, using this code will generate multiple files. As shown in the image below, in addition to the file test.py, a folder called pytransform is created.  When I distribute the obfuscated code to users, I must include this subfolder in the distribution. But I don't find this comfortable. I want to distribute the code to users in one file. If it is a file binarized using PyInstaller, you can also distribute it as one file using innosetup etc. But for non-binary Script, I couldn't find a way to make it a single file. Is there such a way?", "abstract": ""}, "answers": [{"id": 66003546, "score": 1, "vote": 0, "content": "The pytransform folder is generated the exact same every time. It never changes. As a result, if the recipient has a copy of the folder on their system (which they can easily generate using pyarmor), you don't need to send it to them, leaving you with only the one obfuscated file to send to them.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65306407/python-how-to-reduce-this-two-liner-to-one-line", "keywords": [], "tags": ["python"], "question": {"id": 65306407, "title": "Python how to reduce this two-liner to one line?", "content": "How do I write this in a single line? Obviously I don't want to write x = f2(f1(x), f1(x)) since it performs the same operation twice, but do I really have to do a two-liner here?", "abstract": ""}, "answers": [{"id": 65306583, "score": 0, "vote": 0, "content": "This really doesn't seem like a good place to condense things down to one line, but if you must, here's the way I would go about it. Let's take the function f2. Normally, you'd pass in parameters like this: But you can also use a tuple containing \"foo\" and \"bar\" and extract the values as arguments for your function using this syntax: So if you construct a tuple with two of the same element, you can use that syntax to pass the same value to both arguments: Now just eliminate the temporary variable t to make it a one-liner: Obviously this isn't very intuitive or readable though, so I'd recommend against it. One other option you have if you're using Python 3.8 or higher is to use the \"walrus operator\", which assigns a value and acts as an expression that evaluates to that value. For example, the below expression is equal to 5, but also sets x to 2 in the process of its evaluation: Here's your solution for a one-liner using the walrus operator: Basically, x is set to f1(x), then reused for the second parameter of f2. This one might be a little more readable but it still isn't perfect.", "abstract": ""}, {"id": 65306517, "score": 1, "vote": 0, "content": "This is horrendous, and 2 clear lines is better than 1 obfuscated line, but... Example of use: Prints 4.", "abstract": ""}, {"id": 65306480, "score": 1, "vote": 0, "content": "You should probably just keep it as two lines, it is perfectly clear that way. But if you must you can use an assignment expression: But again, don't try to cram your code into one line. Rarely is a code improved by trying to make a \"one-liner\". Write clear, readable, and maintainable code. Don't try to write the shortest code possible. That is maybe fun if you are playing code-golf, but it isn't what you should do if you are trying to write software that is actually going to be used.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64644518/pyarmor-the-obfuscation-write-specific-character-with-the-wrong-encoding-for", "keywords": [], "tags": ["python", "pandas", "obfuscation", "pyarmor"], "question": {"id": 64644518, "title": "PYARMOR : the obfuscation write specific character with the wrong encoding. For ex: &#176; is written &#194;&#176;", "content": "I use Pyarmor to obfuscate a script which reads a csv file and then looks for the column \"Wind Direction (\u00b0)\". I obtain a key error message \"KeyError: 'Wind Direction (\u00c2\u00b0)'\" when running the obfuscated script. This does not work when ofbuscated with pyarmor. I changed it using filter method of pandas to avoid looking for the specific character \"\u00b0\" and it worked fine. I guess this is a problem of encoding between ANSI and UTF-8. Has anyone faced this problem before? It is quite cumbersome to re-write all the code, is there a way to avoid this problem with pyarmor?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/47615485/obfuscating-a-string-to-be-saved-in-a-text-file", "keywords": [], "tags": ["python-3.x", "encode"], "question": {"id": 47615485, "title": "Obfuscating a string to be saved in a text file", "content": "I am trying to obfuscate a string so that it is not easily read by users. However, the obfuscated string should be in form a string that can be stored in a text file, not in byte form to be stored in binary file. I tried some approaches from Simple way to encode a string according to a password? but was not successful:  Output of above fn needs to be stored in a binary file. Changing ..._b64encode(bytes(enc)) to ..._b64encode(enc) does not work. How can I achieve similar result that can be stored in a text file? Edit: \nThe corresponding decode fn is as follows:", "abstract": ""}, "answers": [{"id": 47615532, "score": 1, "vote": 0, "content": "or see here for a full example:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/38030487/obfuscate-a-python-script-in-unicode-escape-sequences", "keywords": [], "tags": ["python-3.x", "unicode", "character-encoding"], "question": {"id": 38030487, "title": "Obfuscate a Python script in Unicode escape sequences", "content": "I want to obfuscate a Python script by using Unicode escape sequences. For example,  in Unicode escape sequences is: From my command line, I can achieve this with: I've create a file and put the \"Hello World\" Unicode escape sequence in it as the source code. But when I run it, I get: How can I use Unicode escape sequences in my source code.", "abstract": ""}, "answers": [{"id": 38032464, "score": 2, "vote": 0, "content": "You can use a PEP 263 header, which tells Python which encoding the source code is written in. The format is: By using the unicode_escape codec (selected from https://docs.python.org/3/library/codecs.html), Python will unescape your strings first.  sample.py Result:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/18199290/is-there-a-way-to-combine-a-python-project-codebase-that-spans-across-different", "keywords": [], "tags": ["python", "obfuscation"], "question": {"id": 18199290, "title": "Is there a way to combine a python project codebase that spans across different files into one file?", "content": "The reason I want to this is I want to use the tool pyobfuscate to obfuscate my python code. Butpyobfuscate can only obfuscate one file.", "abstract": ""}, "answers": [{"id": 30890182, "score": 1, "vote": 0, "content": "You can make a tool that: Or you can use this tool I wrote that does exactly that. To obfuscate multiple files, use it as follows:", "abstract": ""}, {"id": 18199727, "score": 1, "vote": 0, "content": "I've answered your direct question separately, but let me offer a different solution to what I suspect you're actually trying to do: Instead of shipping obfuscated source, just ship bytecode files. These are the .pyc files that get created, cached, and used automatically, but you can also create them manually by just using the compileall module in the standard library. A .pyc file with its .py file missing can be imported just fine. It's not human-readable as-is. It can of course be decompiled into Python source, but the result is\u2026 basically the same result you get from running an obfuscater on the original source. So, it's slightly better than what you're trying to do, and a whole lot easier. You can't compile your top-level script this way, but that's easy to work around. Just write a one-liner wrapper script that does nothing but import the real top-level script. If you have if __name__ == '__main__': code in there, you'll also need to move that to a function, and the wrapper becomes a two-liner that imports the module and calls the function\u2026\u00a0but that's as hard as it gets.) Alternatively, you could run pyobfuscator on just the top-level script, but really, there's no reason to do that. In fact, many of the packager tools can optionally do all of this work for you automatically, except for writing the trivial top-level wrapper. For example, a default py2app build will stick compiled versions of your own modules, along with stdlib and site-packages modules you depend on, into a pythonXY.zip file in the app bundle, and set up the embedded interpreter to use that zipfile as its stdlib.", "abstract": ""}, {"id": 18199625, "score": 1, "vote": 0, "content": "There are a definitely ways to turn a tree of modules into a single module. But it's not going to be trivial. The simplest thing I can think of is this: First, you need a list of modules. This is easy to gather with the find command or a simple Python script that does an os.walk. Then you need to use grep or Python re to get all of the import statements in each file, and use that to topologically sort the modules. If you only do absolute flat import foo statements at the top level, this is a trivial regex. If you also do absolute package imports, or from foo import bar (or from foo import *), or import at other levels, it's not much trickier. Relative package imports are a bit harder, but not that big of a deal. Of course if you do any dynamic importing, use the imp module, install import hooks, etc., you're out of luck here, but hopefully you don't. Next you need to replace the actual import statements. With the same assumptions as above, this can be done with a simple sed or re.sub, something like import\\s+(\\w+) with \\1 = sys.modules['\\1']. Now, for the hard part: you need to transform each module into something that creates an equivalent module object dynamically. This is the hard part. I think what you want to do is to escape the entire module code so that it can put into a triple-quoted string, then do this: Now just concatenate all of those transformed modules together. The result will be almost equivalent to your original code, except that it's doing the equivalent of import foo; del foo for all of your modules (in dependency order) right at the start, so the startup time could be a little slower.", "abstract": ""}, {"id": 18199438, "score": 0, "vote": 0, "content": "I think you can try using the find command with -exec option. you can execute all python scripts in a directory with the following command. Wish this helps. EDIT: OH sorry I overlooked that if you obfuscate files seperately they may not run properly, because it renames function names to different names in different files.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/25123727/obfuscated-mandlebrot-function-can-someone-deobfuscate-it", "keywords": [], "tags": ["python", "obfuscation", "fractals", "deobfuscation"], "question": {"id": 25123727, "title": "Obfuscated mandlebrot function - can someone deobfuscate it?", "content": "I'm new to python and i've become very interested in it's ability to produce fractal images. I've written a few simple ones myself, but I just discovered a script for Mandelbrot fractals... it produces beautiful, full color images at your desired resolution.... but the code is obfuscated to look like ASCII art of a Mandelbrot.... really cool, but silly if you want to read it easily. It contains functions I haven't learned yet in python, so if someone can indent the script to look like normal python script, that'd be great.\nThe script: As I said, the art is cool, but too hard to read! If someone can do this, I'd be greatly thankful.", "abstract": ""}, "answers": [{"id": 25124311, "score": 3, "vote": 0, "content": "Note: This is not meant as a definitive answer, but as an effort for a step-by-step de-obfuscation. If you can provide an additional step to make things clearer, it would be great if you could add it to this answer. Okay, let's start by giving the code proper newlines and indentation: A bit better, but still confusing. For example, defining P as an alias for struct.pack, and all those two-declarations-in-one lines. If we get rid of them, and move the lambda definition outside the loop, we get this: Things are starting to get a bit clearer now. The loop is writing color values for each pixel, and the lambda returns a 3-tuple, representing the blue, green and red values of each pixel. As per your comment, the asterisk (the star, *) unpacks a list into an argument list. After many hours, here's the nearly 100 MB image produced of the Mandelbrot set: ", "abstract": ""}]}]