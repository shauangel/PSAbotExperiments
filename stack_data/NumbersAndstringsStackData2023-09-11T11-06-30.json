[{"link": "https://stackoverflow.com/questions/647769/why-cant-pythons-raw-string-literals-end-with-a-single-backslash", "keywords": [], "tags": ["python", "string", "literals", "rawstring"], "question": {"id": 647769, "title": "Why can&#39;t Python&#39;s raw string literals end with a single backslash?", "content": "Technically, any odd number of backslashes, as described in the documentation. It seems like the parser could just treat backslashes in raw strings as regular characters (isn't that what raw strings are all about?), but I'm probably missing something obvious.", "abstract": ""}, "answers": [{"id": 75557735, "score": 2, "vote": 0, "content": "Given the confusion around the arbitrary-seeming restriction against an odd number of backslashes at the end of a Python raw-string, it's fair to say that this is a design mistake or legacy issue originating in a desire to have a simpler parser. While workarounds (such as r'C:\\some\\path' '\\\\' yielding (in Python notation:) 'C:\\\\some\\\\path\\\\' or (verbatim:) C:\\some\\path\\) are simple, it's counterintuitive to be needing them. For comparison, let's have a look at C++ and Perl. In C++, we can straightforwardly use raw string literal syntax to get the following output: If we want to use the closing delimiter (above: )) within the string literal, we can even extend the syntax in an ad-hoc way to R\"delimiterString(quotedMaterial)delimiterString\". For example, R\"asdf(some random delimiters: ( } [ ] { ) < > just for fun)asdf\" produces the string some random delimiters: ( } [ ] { ) < > just for fun in the output. (Ain't that a good use of \"asdf\"!) In Perl, this code will output the following: This is a test.\\This is another test. Replacing the first line by would lead to an error message: Can't find string terminator \"}\" anywhere before EOF at main.pl line 1. However, Perl treating a pre-delimiter \\ as an escape character doesn't prevent the user from having an odd number of backslashes at the end of the resulting string; eg to place 3 backslashes \\\\\\ into the end of $str, simply end the code with 6 backslashes: my $str = q{This is a test.\\\\\\\\\\\\};. Importantly, while we need to double the backslashes in the input, there is no Python-like inconsistent-seeming syntactic restriction. Another way of looking at things is that these 3 languages use different ways to address the parsing issue of interaction between escape characters and closing delimiters: \u00b9 The custom delimiterString itself cannot be more than 16 characters long, but that's hardly a limitation. \u00b2 If you need the delimiter itself, just escape it with \\. However, to be fair in a comparison to Python, we need to acknowledge that (1) C++ didn't have such string literals until C++11 and is famously hard to parse and (2) Perl is even harder to parse.", "abstract": ""}, {"id": 73234067, "score": 1, "vote": 0, "content": "The naive idea of a raw string is If I put an r in front of a pair of quotes,\nI can put whatever I want between the quotes\nand it will mean itself. Unfortunately, this does not work, because if the whatever\nhappens to contain a quote, the raw string would end at that point. It is simply impossible that I can put \"whatever I want\"\nbetween fixed delimiters, because some of it could look like\nthe terminating delimiter -- no matter what that delimiter is. One possible approach to this problem would be to say If I put an r in front of a pair of quotes,\nI can put whatever I want between the quotes\nas long as it does not contain a quote\nand it will mean itself. This restriction sounds harsh, until one recognizes that\nPython's large offering of quotes can accommodate most situations\nwith this rule. The following are all valid Python quotes: With this many possibilities for the delimiter, almost anything\ncan be made to work.\nAbout the only exception would be if the string\nliteral is supposed to contain a complete list of all allowed\nPython quotes. Python, however, takes a different route using\nan extended version of the above rule.\nIt effectively states If I put an r in front of a pair of quotes,\nI can put whatever I want between the quotes\nas long as it does not contain a quote\nand it will mean itself.\nIf I insist on including a quote, even that is allowed,\nbut I have to put a backslash before it. So the Python approach is, in a sense, even more liberal\nthan variant 1 above -- but it has the side effect of\n\"mis\"interpreting the closing quote as part of the string\nif the last intended character of the string is a backslash. Variant 2 is not helpful: After writing this, I go with several of the other posters\nthat variant 1 would have been easier to understand and to accept\nand therefore more pythonic. That's life!", "abstract": ""}, {"id": 5830053, "score": 30, "vote": 0, "content": "In order for you to end a raw string with a slash I suggest you can use this trick: It uses the implicit concatenation of string literals in Python and concatenates one string delimited with double quotes with another that is delimited by single quotes. Ugly, but works.", "abstract": ""}, {"id": 19654184, "score": 177, "vote": 0, "content": "The whole misconception about python's raw strings is that most of people think that backslash (within a raw string) is just a regular character as all others. It is NOT. The key to understand is this python's tutorial sequence: When an 'r' or 'R' prefix is present, a character following a\n  backslash is included in the string without change, and all\n  backslashes are left in the string So any character following a backslash is part of raw string. Once parser enters a raw string (non Unicode one) and encounters a backslash it knows there are 2 characters (a backslash and a char following it). This way: r'abc\\d' comprises a, b, c, \\, d r'abc\\'d' comprises a, b, c, \\, ', d r'abc\\'' comprises a, b, c, \\, ' and: r'abc\\' comprises a, b, c, \\, ' but there is no terminating quote now. Last case shows that according to documentation now a parser cannot find closing quote as the last quote you see above is part of the string i.e. backslash cannot be last here as it will 'devour' string closing char.", "abstract": ""}, {"id": 52739136, "score": -2, "vote": 0, "content": "I encountered this problem and found a partial solution which is good for some cases. Despite python not being able to end a string with a single backslash, it can be serialized and saved in a text file with a single backslash at the end. Therefore if what you need is saving a text with a single backslash on you computer, it is possible: BTW it is not working with json if you dump it using python's json library.  Finally, I work with Spyder, and I noticed that if I open the variable in spider's text editor by double clicking on its name in the variable explorer, it is presented with a single backslash and can be copied to the clipboard that way (it's not very helpful for most needs but maybe for some..). ", "abstract": ""}, {"id": 48031528, "score": 0, "vote": 0, "content": "Despite its role, even a raw string cannot end in a single\n  backslash, because the backslash escapes the following quote\n  character\u2014you still must escape the surrounding quote character to\n  embed it in the string.  That is, r\"...\\\" is not a valid string\n  literal\u2014a raw string cannot end in an odd number of backslashes.\n  If you need to end a raw string with a single backslash, you can use\n  two and slice off the second.", "abstract": ""}, {"id": 7986539, "score": 17, "vote": 0, "content": "Another trick is to use chr(92) as it evaluates to \"\\\".  I recently had to clean a string of backslashes and the following did the trick: I realize that this does not take care of the \"why\" but the thread attracts many people looking for a solution to an immediate problem.", "abstract": ""}, {"id": 648671, "score": 0, "vote": 0, "content": "some tips : 1) if you need to manipulate backslash for path then standard python module os.path is your friend. for example :  os.path.normpath('c:/folder1/') 2) if you want to build strings with backslash in it BUT without backslash at the END of your string then raw string is your friend (use 'r' prefix before your literal string). for example :  3) if you need to prefix a string in a variable X with a backslash then you can do this : 4) if you need to create a string with a backslash at the end then combine tip 2 and 3 : now lilypond_statement contains \"\\DisplayLilyMusic \\upper\" long live python ! :) n3on", "abstract": ""}, {"id": 648168, "score": 0, "vote": 0, "content": "Comming from C it pretty clear to me that a single \\ works as escape character allowing you to put special characters such as newlines, tabs and quotes into strings. That does indeed disallow \\ as last character since it will escape the \" and make the parser choke. But as pointed out earlier \\ is legal.", "abstract": ""}, {"id": 648135, "score": 9, "vote": 0, "content": "Since \\\" is allowed inside the raw string.  Then it can't be used to identify the end of the string literal.  Why not stop parsing the string literal when you encounter the first \"? If that was the case, then \\\" wouldn't be allowed inside the string literal.  But it is.", "abstract": ""}, {"id": 647877, "score": 2, "vote": 0, "content": "Another user who has since deleted their answer (not sure if they'd like to be credited) suggested that the Python language designers may be able to simplify the parser design by using the same parsing rules and expanding escaped characters to raw form as an afterthought (if the literal was marked as raw). I thought it was an interesting idea and am including it as community wiki for posterity.", "abstract": ""}, {"id": 647797, "score": 37, "vote": 0, "content": "That's the way it is! I see it as one of those small defects in python! I don't think there's a good reason for it, but it's definitely not parsing; it's really easy to parse raw strings with \\ as a last character. The catch is, if you allow \\ to be the last character in a raw string then you won't be able to put \" inside a raw string. It seems python went with allowing \" instead of allowing \\ as the last character. However, this shouldn't cause any trouble. If you're worried about not being able to easily write windows folder pathes such as c:\\mypath\\ then worry not, for, you can represent them as r\"C:\\mypath\", and, if you need to append a subdirectory name, don't do it with string concatenation, for it's not the right way to do it anyway! use os.path.join", "abstract": ""}, {"id": 647774, "score": 4, "vote": 0, "content": "The reason for why r'\\' is syntactical incorrect is that although the string expression is raw the used quotes (single or double) always have to be escape since they would mark the end of the quote otherwise. So if you want to express a single quote inside single quoted string, there is no other way than using \\'. Same applies for double quotes. But you could use:", "abstract": ""}, {"id": 647787, "score": 165, "vote": 0, "content": "The reason is explained in the part of that section which I highlighted in bold: String quotes can be escaped with a\n  backslash, but the backslash remains\n  in the string; for example, r\"\\\"\" is a\n  valid string literal consisting of two\n  characters: a backslash and a double\n  quote; r\"\\\" is not a valid string\n  literal (even a raw string cannot end\n  in an odd number of backslashes).\n  Specifically, a raw string cannot end\n  in a single backslash (since the\n  backslash would escape the following\n  quote character). Note also that a\n  single backslash followed by a newline\n  is interpreted as those two characters\n  as part of the string, not as a line\n  continuation. So raw strings are not 100% raw, there is still some rudimentary backslash-processing.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71459877/force-odd-number-of-backslashes-in-dictionary", "keywords": [], "tags": ["python", "string", "dictionary", "backslash"], "question": {"id": 71459877, "title": "Force odd number of backslashes in dictionary", "content": "I am specifically looking to print this in the terminal {'Name': '[{\\\\\\\"test\\\\\\\\\":\\\\\\\"somedata\\\\\\\"}]'} So far I can get 2 slashes or 4 slashes but I am not sure how to three slashes. I tried doing replace('\"','\\\\\\\"') I tried doing replace('\"','\\\\\\\\\"') I tried doing replace('\"',r'\\\"') I tried doing replace('\"',r'\\\"') I googled as much as I could and came to the conclusion that raw strings can't have an odd number of backslashes https://note.nkmk.me/en/python-raw-string-escape/#:~:text=source%3A%20raw_string_escape.py-,Raw%20strings%20cannot%20end%20with%20an%20odd%20number%20of%20backslashes,the%20end%20of%20the%20string. but I am not sure if there is a work around for this? https://stackoverflow.com/a/22792332 Odd or even number of backslashes and escaped character edit: I tried using unicode as @TDG mention but it still came out as 3 slashes", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/65854576/including-a-backslash-at-the-end-of-a-raw-triple-quoted-string-fails", "keywords": [], "tags": ["python", "python-3.x", "string"], "question": {"id": 65854576, "title": "Including a backslash at the end of a raw triple quoted string fails", "content": "The below fails with syntax error: Switching the last two characters causes the code to work as expected: Is this a python implementation issue, or did I miss something?", "abstract": ""}, "answers": [{"id": 65854966, "score": 0, "vote": 0, "content": "This question has already been documented on Python FAQ documentation. So you can read through the details. Extract from the FAQ: Why can\u2019t raw strings (r-strings) end with a backslash? More\nprecisely, they can\u2019t end with an odd number of backslashes: the\nunpaired backslash at the end escapes the closing quote character,\nleaving an unterminated string. Raw strings were designed to ease creating input for processors\n(chiefly regular expression engines) that want to do their own\nbackslash escape processing. Such processors consider an unmatched\ntrailing backslash to be an error anyway, so raw strings disallow\nthat. In return, they allow you to pass on the string quote character\nby escaping it with a backslash. These rules work well when r-strings\nare used for their intended purpose. Unfortunately there is no way around it. You need to end it with another character or include a space. If you include a space, the length will change. The trick to get the backslash as the last string is to add a space after the backslash. Here's the output of the above code: So you have to just change it to another character. The reason is \\ is an escape character and it is taking the ' as a char. My initial reaction was to add another backslash. However, that just adds the backslash to the string. See code below. The output is: The only workaround I found is to include the space but to slice the string to [:-1]. You can do the following: The output of this will be:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/2870730/python-raw-strings-and-trailing-backslash", "keywords": [], "tags": ["python", "windows", "escaping"], "question": {"id": 2870730, "title": "Python raw strings and trailing backslash", "content": "I ran across something once upon a time and wondered if it was a Python \"bug\" or at least a misfeature.  I'm curious if anyone knows of any justifications for this behavior.  I thought of it just now reading \"Code Like a Pythonista,\" which has been enjoyable so far.  I'm only familiar with the 2.x line of Python. Raw strings are strings that are prefixed with an r.  This is great because I can use backslashes in regular expressions and I don't need to double everything everywhere.  It's also handy for writing throwaway scripts on Windows, so I can use backslashes there also.  (I know I can also use forward slashes, but throwaway scripts often contain content cut&pasted from elsewhere in Windows.) So great!  Unless, of course, you really want your string to end with a backslash.  There's no way to do that in a 'raw' string. So one backslash before the closing quote is an error, but two backslashes gives you two backslashes!  Certainly I'm not the only one that is bothered by this? Thoughts on why 'raw' strings are 'raw, except for backslash-quote'?  I mean, if I wanted to embed a single quote in there I'd just use double quotes around the string, and vice versa.  If I wanted both, I'd just triple quote.  If I really wanted three quotes in a row in a raw string, well, I guess I'd have to deal, but is this considered \"proper behavior\"? This is particularly problematic with folder names in Windows, where the backslash is the path delimeter.", "abstract": ""}, "answers": [{"id": 26152767, "score": 3, "vote": 0, "content": "Another way to workaround this is: Updated for Python 3 and removed unnecessary slash at the end which implied an escape. Note that personally I doubt I would use the above. I guess maybe if it was a huge string with more than just a path. For the above I'd prefer non-raw and double up the slashes.", "abstract": ""}, {"id": 7923916, "score": -1, "vote": 0, "content": "Thoughts on why 'raw' strings are 'raw, except for backslash-quote'? I\n  mean, if I wanted to embed a single quote in there I'd just use double\n  quotes around the string, and vice versa. But that would then raise the question as to why raw strings are 'raw, except for embedded quotes?' You have to have some escape mechanism, otherwise you can never use the outer quote characters inside the string at all. And then you need an escape mechanism for the escape mechanism.", "abstract": ""}, {"id": 2870738, "score": 24, "vote": 0, "content": "It's a FAQ.   And in response to \"you really want your string to end with a backslash. There's no way to do that in a 'raw' string.\": the FAQ shows how to workaround it.", "abstract": ""}, {"id": 2870746, "score": 4, "vote": 0, "content": "Raw strings are meant mostly for readably writing the patterns for regular expressions, which never need a trailing backslash; it's an accident that they may come in handy for Windows (where you could use forward slashes in most cases anyway -- the Microsoft C library which underlies Python accepts either form!).  It's not cosidered acceptable to make it (nearly) impossible to write a regular expression pattern containing both single and double quotes, just to reinforce the accident in question. (\"Nearly\" because triple-quoting would almost alway help... but it could be a little bit of a pain sometimes). So, yes, raw strings were designed to behave that way (forbidding odd numbers of trailing backslashes), and it is considered perfectly \"proper behavior\" for them to respect the design decisions Guido made when he invented them;-).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/30157185/python-raw-string-literals", "keywords": [], "tags": ["python", "rawstring"], "question": {"id": 30157185, "title": "Python - Raw String Literals", "content": "I don't understand how raw string literals work. I know that when using r it ignores all specials, like when doing \\n it treats it as \\n and not as a new line. but then I tried to do this: and it said SyntaxError: EOL while scanning string literal and not '\\' why? did I understanded it correctly?\nand also what is the explanation for this :", "abstract": ""}, "answers": [{"id": 30157205, "score": 6, "vote": 0, "content": "In a raw literal the backslash will escape the quote character that is defining the string. String quotes can be escaped with a backslash, but the backslash\n  remains in the string; for example, r\"\\\"\" is a valid string literal\n  consisting of two characters: a backslash and a double quote; r\"\\\" is\n  not a valid string literal (even a raw string cannot end in an odd\n  number of backslashes). Specifically, a raw string cannot end in a\n  single backslash (since the backslash would escape the following quote\n  character). Note also that a single backslash followed by a newline is\n  interpreted as those two characters as part of the string, not as a\n  line continuation. From the docs", "abstract": ""}, {"id": 30157301, "score": 7, "vote": 0, "content": "The only way to put in a single quote into a string started with a single quote is to escape it. Thus, both raw and regular string literals will allow escaping of quote characters when you have an unescaped backslash followed by a quote character. Because of the requirement that there must be a way to express single (or double) quotes inside string literals that begin with single (or double) quotes, the string literal '\\' is not legal, whether you use a raw or regular string literal. To get any arbitrary string with an odd number of literal backslashes, I believe the best way is to use regular string literals. This is because trying to use r'\\\\' will work, but it will give you a string with two backslashes instead of one: This answer is only meant to complement the other one.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11168076/why-cant-i-end-a-raw-string-with-a-backslash", "keywords": [], "tags": ["python", "string", "rawstring"], "question": {"id": 11168076, "title": "Why can&#39;t I end a raw string with a backslash?", "content": "I am confused here, even though raw strings convert every \\ to \\\\ but when this \\ appears in the end it raises error. Update: This is now covered in Python FAQs as well: Why can\u2019t raw strings (r-strings) end with a backslash?", "abstract": ""}, "answers": [{"id": 30283185, "score": 3, "vote": 0, "content": "Quote from https://docs.python.org/3.4/reference/lexical_analysis.html#literals: Even in a raw literal, quotes can be escaped with a backslash, but the\n  backslash remains in the result; for example, r\"\\\"\" is a valid string\n  literal consisting of two characters: a backslash and a double quote;\n  r\"\\\" is not a valid string literal (even a raw string cannot end in an\n  odd number of backslashes). Specifically, a raw literal cannot end in\n  a single backslash (since the backslash would escape the following\n  quote character). Note also that a single backslash followed by a\n  newline is interpreted as those two characters as part of the literal,\n  not as a line continuation. So in raw string, backslash are not treated specially, except when preceding \" or '. Therefore, r'\\' or r\"\\\" is not a valid string cause right quote is escaped thus making the string literal invalid. In such case, there's no difference whether r exists, i.e. r'\\' is equivalent to '\\' and r\"\\\" is equivalent to \"\\\".", "abstract": ""}, {"id": 11170170, "score": 9, "vote": 0, "content": "Raw strings can't end in single backslashes because of how the parser works (there is no actual escaping going on, though). The workaround is to add the backslash as a non-raw string literal afterwards: Not pretty, but it works. You can add plus to make it clearer what is happening, but it's not necessary:", "abstract": ""}, {"id": 11169639, "score": 5, "vote": 0, "content": "Python strings are processed in two steps: First the tokenizer looks for the closing quote. It recognizes backslashes when it does this, but doesn't interpret them - it just looks for a sequence of string elements followed by the closing quote mark, where \"string elements\" are either (a character that's not a backslash, closing quote or a newline - except newlines are allowed in triple-quotes), or (a backslash, followed by any single character). Then the contents of the string are interpreted (backslash escapes are processed) depending on what kind of string it is. The r flag before a string literal only affects this step.", "abstract": ""}, {"id": 11168081, "score": 10, "vote": 0, "content": "You still need \\ to escape ' or \" in raw strings, since otherwise the python interpreter doesn't know where the string stops. In your example, you're escaping the closing '. Otherwise: Look at the syntax highlighting to see what I mean.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/24051248/why-escapes-even-when-it-is-a-raw-string", "keywords": [], "tags": ["python", "regex"], "question": {"id": 24051248, "title": "why \\* escapes even when it is a raw string?", "content": "I have read that when 'r' prefix is present, a character following a backslash is included in the string without change, and all backslashes are left in the string. But when I create a regex object: p=re.compile(r'\\*(.*?)\\*'), it matches '*text*'. I don't understand why it happens. Under my impression it should match '\\*text\\*'.", "abstract": ""}, "answers": [{"id": 24051270, "score": 12, "vote": 0, "content": "Regular expressions treat the backslash specially.  The backslash disables the \"magic\" behavior of special characters like *. To actually match a backslash, you need to put two in your raw string: r'\\\\foo' I think what confused you is that backslashes are special in strings and also special for regular expressions.  Python has raw strings to simplify your life: in a raw string, backslashes aren't special, leaving you free to think about the special way that the actual regular expression will handle the backslash. The regular expression compiler will see this sequence of two characters:  \\* It will see the backslash, and remove the backslash and treat the * specially (disable the \"magic\"). If you are using a raw string, it's easy to create the sequence of two characters: r'\\*' But if you are not using a raw string, backslashes are special inside the string, so you need to double the backslash to get one:  '\\\\*' If you actually want to match the pattern \\* then you need a backslash followed by another backslash, to get the match on an actual backslash; then a backslash followed by a *, to get the match on an actual *. There are two special rules about backslash in a raw string, and the two go together: a backslash can escape a quote character, and therefore you cannot end a raw string with an odd number of backslashes. https://docs.python.org/2/faq/design.html#why-can-t-raw-strings-r-strings-end-with-a-backslash EDIT: @Charles Duffy pointed out that Python's re module provides a function that will properly \"escape\" the special characters, for the times when you want to match them exactly. If you wanted to both match literal * and use the special behavior of *, one way to do it is this: This is a pattern that will match zero or more occurrences of the actual string *text*", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/23938753/how-to-print-an-odd-number-of-backslashes-in-python", "keywords": [], "tags": ["python", "escaping"], "question": {"id": 23938753, "title": "How to Print An Odd Number of Backslashes in Python", "content": "I need to print a string as part of a list that has 3 backslashes in it in Python. However, this is not appearing to be as simple as I expected. Any string that has an odd number of backslashes will do this because Python is escaping the quote. So I tried escaping myself: which is 6 backslashes. Not what I wanted. This has stumped a few of us around the water cooler.", "abstract": ""}, "answers": [{"id": 23938808, "score": 5, "vote": 0, "content": "'\\\\\\\\\\\\' is a string contain 3 backslashes. You can see that there are 3 characters in the string by applying list to it: '\\\\'*3 would also work: Or since  you could avoid the need to escape the backslash by using \\x5c:", "abstract": ""}, {"id": 23938782, "score": 2, "vote": 0, "content": "would work I think (r indicates a literal string) (as pointed out in the comments you cant end with a backslash in raw strings ...(so I added a space)) If you didnt want the space you could ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/23360807/trailing-slash-in-a-raw-string", "keywords": [], "tags": ["python", "syntax"], "question": {"id": 23360807, "title": "Trailing slash in a raw string", "content": "Just a quick silly question. How do I write a trailing slash in a raw string literal?", "abstract": ""}, "answers": [{"id": 23361028, "score": 2, "vote": 0, "content": "Raw string literals are parsed in exactly the same way as ordinary string literals; it\u2019s just the conversion from string literal to string object that\u2019s different. This means that all string literals must end with an even number of backslashes; otherwise, the unpaired backslash at the end escapes the closing quote character, leaving an unterminated string.", "abstract": ""}, {"id": 23360906, "score": 7, "vote": 0, "content": "You can't. A raw string literal can't end with an odd number of backslashes (langref; last paragraph of that section). You can, howerver, write a raw string literal without the backslash, and write the final backslash as an ordinary string literal: Adjacent string literals are implicitly concatenated by the parser.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/14180729/error-with-string-with-ending-backslash", "keywords": [], "tags": ["python", "string"], "question": {"id": 14180729, "title": "error with string with ending backslash", "content": "Possible Duplicate:\nwhy can\u2019t I end a raw string with a \\  Why is this syntax correct: while this gives the error SyntaxError: EOL while scanning string literal", "abstract": ""}, "answers": [{"id": 14180782, "score": 1, "vote": 0, "content": "Use os.path.join, it avoids this and takes care of using the OS-appropriate directory separators:", "abstract": ""}, {"id": 14180743, "score": 0, "vote": 0, "content": "Here, the backslash escapes the ending \".\nIf you want to use \\ in a string, the most safe way is to escape the backslash itself. Try this: I'd recommend it instead of using a raw string. The characters which need an escape are described in the python doc.", "abstract": ""}, {"id": 14180737, "score": 1, "vote": 0, "content": "In the second case, you are escaping the quote \\\" is the escape sequence for a \" To use the backslash, you should use a double backslash \\\\ This should work :", "abstract": ""}, {"id": 14180758, "score": 2, "vote": 0, "content": "Fromt the docs: When an 'r' or 'R' prefix is present, a character following a\n  backslash is included in the string without change, and all\n  backslashes are left in the string. For example, the string literal\n  r\"\\n\" consists of two characters: a backslash and a lowercase 'n'.\n  String quotes can be escaped with a backslash, but the backslash\n  remains in the string; for example, r\"\\\"\" is a valid string literal\n  consisting of two characters: a backslash and a double quote; r\"\\\" is\n  not a valid string literal (even a raw string cannot end in an odd\n  number of backslashes). Specifically, a raw string cannot end in a\n  single backslash (since the backslash would escape the following quote\n  character). Note also that a single backslash followed by a newline is\n  interpreted as those two characters as part of the string, not as a\n  line continuation. Specifically, a raw string cannot end in a\nsingle backslash (since the backslash would escape the following quote\ncharacter)", "abstract": ""}]}]