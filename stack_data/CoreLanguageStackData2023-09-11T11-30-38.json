[{"link": "https://stackoverflow.com/questions/68736719/shouldnt-shallow-copy-create-an-object-with-different-id-in-python", "keywords": [], "tags": ["python", "list", "shallow-copy"], "question": {"id": 68736719, "title": "Shouldn&#39;t shallow copy create an object with different id in python?", "content": "I am trying to learn the concept of deep copy and shallow copy. I understand that list1  and list2 would be references to the same memory, therefore id(list1[0]) will be equal to id(list2[0]). But shouldn't id(list1) be different from id(list2) as both are different objects of class list.", "abstract": ""}, "answers": [{"id": 68737463, "score": 1, "vote": 0, "content": "In python, assignment never copies data. You just get a new name that references the same value. There are basically three cases: Assignment: just a new name that points to the same object. copy.copy the object itself is copied, but members of the object are not. So a shallow copy of a list will be a new list, have a new ID but will point to the same objects in memory for its elements as the original list. copy.deepcopy recursively copies everything. Good resources:\nhttp://www.pythontutor.com/visualize.html#mode=edit Ned Batchelder, Facts and myths about python names and values https://youtu.be/_AEJHKGk9ns", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/60825689/how-to-deep-copy-a-class-object-in-python3", "keywords": [], "tags": ["python", "class", "deep-copy"], "question": {"id": 60825689, "title": "How to deep-copy a class object in Python3", "content": "GIVEN: GOAL:  An operation COPY such that the code fragment above results in  IN PLAIN WORDS:  By what means can a class object be deep-copied, so that it is totally isolated from its original. Using copy.deepcopy() delivers  so that is not the solution.", "abstract": ""}, "answers": [{"id": 75364708, "score": 1, "vote": 0, "content": "This example prints: Apparently, both A as well as B share the same values for their attributes x and f. Therefore, as you have already noted, copy.deepcopy doesn't work to \"copy\" a class object. It seems that Python class objects are singletons, because A is deepcopy(A) is True. So, alternatively, you could just use inheritance instead of copying: Which prints: Like this, we are able to change B.x and B.f without affecting A.x and A.f. However, isinstance(b, A) will be True, which might be undesired. Also, changes to class attributes of A will propagate to its child B. Therefore, you just change your original A into a dummy A_, first, and then derive both A and B from that: Now, isinstance(b, A) will be False and changes to class attributes of A will not propagate to B.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52345091/cloning-an-object-in-python", "keywords": [], "tags": ["python", "python-3.x", "class", "oop", "cloning"], "question": {"id": 52345091, "title": "Cloning an object in Python", "content": "I am writing a program which involves recursively making an instance of an object that may be passed as an argument. A sample of program: How do I clone an object (here sampleobj1) instead of manually assigning all variables of \"sample\" to self? I get the following error:  Why doesn't the line: self = sample work? Whatever I do, I always happen to get the same error. Individually copying the attributes seem just fine. But I am working on a code with a lot of attributes where copying each attribute seems a bit lengthy. sampleobj3 = copy(sampleobj1) also seems to work. But I want the copying to be done in the class & not in the main of the program.", "abstract": ""}, "answers": [{"id": 52345141, "score": 4, "vote": 0, "content": "The line self = sample only overwrites a local variable, it does not replace the object initially stored in self in memory. To copy instances of a class, you have to fully define how to build a new object from an existing one. You do this by defining the __copy__ and __deepcopy__ methods. These are the dunder methods used by copy.copy and copy.deepcopy respectively. Furthermore, note that it is bad practice to have input in your __init__ as it impedes the above solution. You should separate your logic and your IO.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72917225/how-to-completely-copy-a-class-instance-in-python-copy-deepcopy-doesnt-work", "keywords": [], "tags": ["python", "pygame", "copy"], "question": {"id": 72917225, "title": "How to completely copy a class instance in Python? copy.deepcopy doesn&#39;t work", "content": "Let's say I have a simple python class, such as I want to make a function that copies everything inside of this class. The problem I face is that when I use copy.deepcopy(<class instance>), since the paremeter is a pygame.Surface object, it cannot copy with that function. How could I make a function that creates a new class instance and stores the pointer to it in a new variable? EDIT:\nIt would be preferable to have a simple property, such as", "abstract": ""}, "answers": [{"id": 72919517, "score": 0, "vote": 0, "content": "You cannot deepcopy a pygame.Surface object, however a pygame.Surface has a copy method. See Duplicating a sprite. The problem with your code is that you load the Surface in the objects constructor. This is bad practice and is causing your problems. Load image at in initialization and pass the image to the objects constructor. Use a @staticmethod if you want to encapsulate the loading of the file in the class: Anyway there is absolutely no need to copy a pygame.Surface. Typically a surface is static and does not change at all. It only stores the graphical representation of an object and no other information. So many objects can share the same Surface object. You don't have to copy the Surface, just share it, which saves a lot of memory and improves performance:", "abstract": ""}, {"id": 72917834, "score": 0, "vote": 0, "content": "First of all, I would like to notice that it is not coincidence. You usually don't want to copy images, because it takes a lot of memory. If you still want to then:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72219980/how-to-copy-a-class-object-in-python", "keywords": [], "tags": ["python", "class", "object", "copy"], "question": {"id": 72219980, "title": "How to copy a class object in python", "content": "This is quite a simple question, however I cannot seem to figure out how to do it. I simply need to make a copy of a class object, for example: I tried to do both A.copy() and A.deepcopy(), but I get \"'Foo' object has no attribute 'copy'\"\nThis may be a super simple fix, however I have never used the copy module before and am not aware of why this may be an issue.\nFor reference, I need the copied object to be mutable (without affecting the original) so I figured the best way would be to use .deepcopy().", "abstract": ""}, "answers": [{"id": 72220352, "score": 1, "vote": 0, "content": "You're right,  using deepcopy from the built-in copy module is the way to go, since you want the exact replica of the Object Foo. Here, passing the object Foo(5) will return a Foo object, passing it without any args will return __name__.Foo", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65636981/how-to-make-deep-copy-of-a-specificmutable-object", "keywords": [], "tags": ["python", "python-3.x", "python-chess"], "question": {"id": 65636981, "title": "How to make deep copy of a specific(mutable) object?", "content": "I'm trying to make a chess engine. However, I ran into an error where: That isn't good,especially the legal move part. I traced back to the source of the error: I know about Python's quirky mutability, and though I know I can copy a list like this: type(board) returns<class 'chess.Board'>.\nHow to I make a full copy of board?\nThanks in advance.", "abstract": ""}, "answers": [{"id": 65637038, "score": 1, "vote": 0, "content": "Generally, Python has a library named 'copy' which implements deepcopy of the basic objects. Try to use from copy import deepcopy and override the __eq__ function of Board. For more information, take a look at How can I create a copy of an object in Python?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/57349369/python-class-dict-usage-for-cloning-object-attributes", "keywords": [], "tags": ["python", "class", "object", "copy"], "question": {"id": 57349369, "title": "python class __dict__ usage for cloning object attributes", "content": "EDIT\nClarification: While I do appreciate the corrections/suggestions for deep copy that are already posted, this question is mainly about usage of __dict__ method of class, and whether cloning object attrs using init this way is okay.  Is there any issue with this usage of init for copying object attrs, better way to achieve this?", "abstract": ""}, "answers": [{"id": 57349392, "score": 0, "vote": 0, "content": "You can simply use copy.deepcopy().", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/4794244/how-can-i-create-a-copy-of-an-object-in-python", "keywords": [], "tags": ["python", "oop", "object", "copy"], "question": {"id": 4794244, "title": "How can I create a copy of an object in Python?", "content": "I would like to create a copy of an object. I want the new object to possess all properties of the old object (values of the fields). But I want to have independent objects. So, if I change values of the fields of the new object, the old object should not be affected by that.", "abstract": ""}, "answers": [{"id": 46939443, "score": 148, "vote": 0, "content": "So, if I change values of the fields of the new object, the old object should not be affected by that. You mean a mutable object then. In Python 3, lists get a copy method (in 2, you'd use a slice to make a copy): Shallow copies are just copies of the outermost container. list.copy is a shallow copy: You don't get a copy of the interior objects. They're the same object - so when they're mutated, the change shows up in both containers. Deep copies are recursive copies of each interior object. Changes are not reflected in the original, only in the copy. Immutable objects do not usually need to be copied. In fact, if you try to, Python will just give you the original object: Tuples don't even have a copy method, so let's try it with a slice: But we see it's the same object: Similarly for strings: and for frozensets, even though they have a copy method: Immutable objects should be copied if you need a mutable interior object copied. As we can see, when the interior object of the copy is mutated, the original does not change. Custom objects usually store data in a __dict__ attribute or in __slots__ (a tuple-like memory structure.) To make a copyable object, define __copy__ (for shallow copies) and/or __deepcopy__ (for deep copies). Note that deepcopy keeps a memoization dictionary of id(original) (or identity numbers) to copies. To enjoy good behavior with recursive data structures, make sure you haven't already made a copy, and if you have, return that. So let's make an object: And copy makes a shallow copy: And deepcopy now makes a deep copy:", "abstract": ""}, {"id": 4794254, "score": 293, "vote": 0, "content": "To get a fully independent copy of an object you can use the copy.deepcopy() function. For more details about shallow and deep copying please refer to the other answers to this question and the nice explanation in this answer to a related question.", "abstract": ""}, {"id": 52160051, "score": 24, "vote": 0, "content": "Shallow copy with copy.copy() Deep copy with copy.deepcopy() Documentation: https://docs.python.org/3/library/copy.html Tested on Python 3.6.5.", "abstract": ""}, {"id": 48906171, "score": -1, "vote": 0, "content": "I believe the following should work with many well-behaved classed in Python: (Of course, I am not talking here about \"deep copies,\" which is a different story, and which may be not a very clear concept -- how deep is deep enough?) According to my tests with Python 3, for immutable objects, like tuples or strings, it returns the same object (because there is no need to make a shallow copy of an immutable object), but for lists or dictionaries it creates an independent shallow copy. Of course this method only works for classes whose constructors behave accordingly. Possible use cases: making a shallow copy of a standard Python container class.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/42143461/make-copy-of-object-instance-in-python", "keywords": [], "tags": ["python", "oop"], "question": {"id": 42143461, "title": "Make copy of object instance in Python", "content": "I would like to make a copy of a python class object which does not change when the original object changes. Here is my simple working example: From my understanding, when I set B = A, this just means B points to the object A. Hence when I change A it changes B as well. Is it possible to instead make B a new instance with all the same properties as A, but does not change when I change A? In my above example, I would like the value for B to stay at 1 when I increment A.  If A and B were lists instead of objects I would write B = list(A). I guess I am asking if there is a similar method for class objects? Thank you in advance for your help!", "abstract": ""}, "answers": [{"id": 42143502, "score": 15, "vote": 0, "content": "If you want to make a copy then one way is using deepcopy: All = does is to assign another reference to the same object in memory. The deepcopy creates a whole new object in memory with the values of A and B will reference it. if you do the following you will see different prints:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/29398336/how-to-copy-instances-of-a-custom-defined-class-in-python-3-3", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 29398336, "title": "How to copy instances of a custom defined class in Python 3.3?", "content": "I am trying to copy instances of a custom class in Python 3.3, similar to how dict.copy() and list.copy() work. How do I go about this? Here is an example of my custom class:", "abstract": ""}, "answers": [{"id": 29398459, "score": 17, "vote": 0, "content": "In general, you can use the copy module to produce copies of Python objects. copy.copy() will produce a shallow copy; a new instance is created but all attributes are simply copied over. If any of your attributes are mutable and you mutate those objects you'll see those changes reflected on both objects. copy.deepcopy() will produce a copy recursively; any mutable objects will themselves be cloned. If your class implements a __copy__ method it'll be used to create a shallow copy of the object; return a new instance with attributes copied over and altered as needed. Similarly, you can implement a __deepcopy__ method to implement a custom deep copy method; it'll be passed the memo state, pass this on to recursive copy.deepcopy() calls. Note that you cannot use this to copy a class object however. Classes are meant to be singletons; you don't need to create a copy in that case. You can use subclassing instead, or a class factory function, to produce distinct class objects.", "abstract": ""}]}]