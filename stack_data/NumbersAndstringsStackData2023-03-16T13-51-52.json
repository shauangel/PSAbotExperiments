[{"link": "https://stackoverflow.com/questions/66538838/can-someone-please-explain-the-logic-behind-using-space-in-function-call-to-an-i", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 66538838, "title": "Can someone please explain the logic behind using space in function call to an int value?", "content": "If I am doing this I am getting SyntaxError: invalid syntax but runs fine when using space How does it reads the space ?", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/64935152/python3-int-sizeof-produces-syntax-error", "keywords": [], "tags": ["python", "oop", "integer"], "question": {"id": 64935152, "title": "Python3 int.__sizeof__() produces syntax error", "content": "The following code produces a syntax error. Does anyone know why syntax errors result when using object attributes?", "abstract": ""}, "answers": [{"id": 64935249, "score": 7, "vote": 0, "content": "The lexer is greedy, so it recognizes 1.__sizeof__() as float literal 1. followed by an identifier __sizeof__, rather than an int literal followed by a . operator. Use parentheses to override assist the lexer:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/23998026/why-isnt-this-a-syntax-error-in-python", "keywords": [], "tags": ["python", "grammar", "conditional-expressions"], "question": {"id": 23998026, "title": "Why isn&#39;t this a syntax error in python?", "content": "Noticed a line in our codebase today which I thought surely would have failed the build with syntax error, but tests were passing so apparently it was actually valid python (in both 2.x and 3).   Whitespace is sometimes not required in the conditional expression: It doesn't work if the LHS is a variable: But it does seem to still work with other types of literals: What's going on here, is it intentionally part of the grammar for some reason?  Is this odd quirk a known/documented behaviour?", "abstract": ""}, "answers": [{"id": 23998137, "score": 4, "vote": 0, "content": "The Python lexer generates two tokens for the input 1if: the integer 1 and the keyword if, since no token that begins with a digit can contain the string if. xif, on the other hand, is recognized as a valid identifier; there is no reason to believe that it is an identifier followed by a keyword, and so is passed to the parser as a single token.", "abstract": ""}, {"id": 23998132, "score": 3, "vote": 0, "content": "With my limited knowledge of lexical processing and tokenizing I'd say what you're seeing is that any piece that can be lexical parsed as \"different\" (i.e. numbers/dictionaries, etc...) from the if are being done so. Most languages ignore spaces and I imagine that Python does the same (excluding, of course indentation levels). Once tokens are generated the grammar itself doesn't care, it most likely looks for an [EXPRESSION] [IF] [EXPRESSION] [ELSE] [EXPRESSION] grouping, which, again with your examples, would work fine.", "abstract": ""}, {"id": 23998128, "score": 66, "vote": 0, "content": "Except at the beginning of a logical line or in string literals, the whitespace characters space, tab and formfeed can be used interchangeably to separate tokens. Whitespace is needed between two tokens only if their concatenation could otherwise be interpreted as a different token (e.g., ab is one token, but a b is two tokens). So in this case, 1if is not a valid token, so the whitespace is optional. The 1 is interpreted as an integer literal of which the if is not a part. So if is interpreted separately and recognized as a keyword. In xif however, an identifier is recognized, so Python is not able to see that you wanted to do x if there.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/26255693/attribute-access-on-int-literals", "keywords": [], "tags": ["python", "parsing", "grammar", "lexical-analysis"], "question": {"id": 26255693, "title": "Attribute access on int literals", "content": "It has been covered here before that the second example doesn't work because the int literal is actually parsed as a float.   My question is, why doesn't python parse this as attribute access on an int, when the interpretation as a float is a syntax error?  The docs section on lexical analysis seem to suggest whitespace only required when other interpretations are ambiguous, but perhaps I'm reading this section wrong.   On a hunch it seems like the lexer is greedy (trying to take the biggest token possible), but I have no source for this claim.  ", "abstract": ""}, "answers": [{"id": 26258548, "score": 2, "vote": 0, "content": "Read carefully, it says Whitespace is needed between two tokens only if their concatenation could otherwise be interpreted as a different token (e.g., ab is one token, but a b is two tokens). 1.__hash__() is tokenized as: Python's lexer will choose a token which comprises the longest possible string that forms a legal token, when read from left to right; after parsing no two tokens should be able to be combined into a valid token. The logic is very similar to that in your other question. The confusion seems to be not recognizing the tokenizing step as a completely distinct step. If the grammar allowed splitting up tokens solely to make the parser happy then surely you'd expect  to tokenize as but there is no such rule, so it tokenizes as", "abstract": ""}, {"id": 26256242, "score": 3, "vote": 0, "content": "It\u2019s simply a matter of definition; for languages the grammar does the job. Attribute references are defined at a much broader level than floating point literals. So from a grammar level, the parser has to recognize 1. as a floating point literal and not as a attribute reference. Of course, the parser itself could backtrack when reaching the _ and try to figure out that it\u2019s not a floating point literal but an attribute reference instead. However, since CPython\u2019s parser is a LL(1) parser backtracking is not an option. As such, the grammar would have to be changed a lot to allow the parser to recognize this (although I\u2019m not sure right now if it\u2019s even possible with a LL(1) parser). We could also change Python\u2019s parser to something else, maybe one that does backtrack, but doing so is not only a very difficult task (it also would require to change the grammar) but would increase the complexity of the parsing process a lot (and with that likely decrease the speed). So maybe it would be possible, but it would require major changes in the language specification. And that alone would be problematic. It also would break existing code that make use of this early float recognition, e.g. 1.if True else 0.", "abstract": ""}, {"id": 26256232, "score": 3, "vote": 0, "content": "The lexer is very simple, and will not backtrack.  Language parsers are often divided into a lexing phase and a parsing phase, or a lexer and a parser.  The lexer breaks the character stream into tokens, and then the parser determines a program structure from the tokens.  The lexer sees four tokens: 1., __hash__, (, ): float, identifier, open-paren, close-paren.  The parser can't make sense of those tokens, but that doesn't mean the lexer will try to lex the characters differently.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/33054229/accessing-attributes-on-literals-work-on-all-types-but-not-int-why", "keywords": [], "tags": ["python", "python-2.7", "python-3.x", "language-lawyer"], "question": {"id": 33054229, "title": "Accessing attributes on literals work on all types, but not `int`; why?", "content": "I have read that everything in python is an object, and as such I started to experiment with different types and invoking __str__ on them \u2014 at first I was feeling really excited, but then I got confused.", "abstract": ""}, "answers": [{"id": 33054230, "score": 53, "vote": 0, "content": "123 is just as much of an object as 3.14, the \"problem\" lies within the grammar rules of the language; the parser thinks we are about to define a float \u2014 not an int with a trailing method call. We will get the expected behavior if we wrap the number in parenthesis, as in the below. Or if we simply add some whitespace after 123:  The reason it does not work for 123.__str__() is that the dot following the 123 is interpreted as the decimal-point of some partially declared floating-point. The parser tries to interpret __str__() as a sequence of digits, but obviously fails \u2014 and we get a SyntaxError basically saying that the parser stumbled upon something that it did not expect.  When looking at 123.__str__() the python parser could use either 3 characters and interpret these 3 characters as an integer, or it could use 4 characters and interpret these as the start of a floating-point. Just as a little child would like as much cake as possible on their plate, the parser is greedy and would like to swallow as much as it can all at once \u2014 even if this isn't always the best of ideas \u2014as such the latter (\"better\") alternative is chosen. When it later realizes that __str__() can in no way be interpreted as the decimals of a floating-point it is already too late; SyntaxError. Note In the above snippet, 123\u00a0 (note the space) must be interpreted as an integer since no number can contain spaces. This means that it is semantically equivalent to (123).__str__(). Note The above also works because a number can contain at most one decimal-point, meaning that it is equivalent to (123.).__str__().  This section contains the lexical definition of the relevant literals. Lexical analysis - 2.4.5 Floating point literals\n Lexical analysis - 2.4.4 Integer literals\n", "abstract": ""}, {"id": 10955711, "score": 41, "vote": 0, "content": "Add a space after the 4: Otherwise, the lexer will split this expression into the tokens \"4.\", \"__str__\", \"(\" and \")\", i.e. the first token is interpreted as a floating point number.  The lexer always tries to build the longest possible token.", "abstract": ""}, {"id": 10955713, "score": 89, "vote": 0, "content": "You need parens: The problem is the lexer thinks \"4.\" is going to be a floating-point number. Also, this works:", "abstract": ""}, {"id": 10955754, "score": 6, "vote": 0, "content": "actually (to increase unreadability...): is valid, too. it gives '0x1.0000000000000p+2' -- but then it's a float, of course...", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/31037609/why-is-1-real-a-syntax-error-but-1-real-valid-in-python", "keywords": [], "tags": ["python"], "question": {"id": 31037609, "title": "Why is &quot;1.real&quot; a syntax error but &quot;1 .real&quot; valid in Python?", "content": "So I saw these two questions on twitter. How is 1.real a syntax error but 1 .real is not?", "abstract": ""}, "answers": [{"id": 31038206, "score": 1, "vote": 0, "content": "1 .real works because it is the attribute .real called on the integer 1. 1.real does not work, because you imperatively need a space at the end of a float. Otherwise it is a syntax error.", "abstract": ""}, {"id": 31037690, "score": 11, "vote": 0, "content": "With 1.real Python is looking for a floating-point numeric literal like 1.0 and you can't have an r in a float. With 1 .real Python has taken 1 as an integer and is doing the attribute lookup on that. It's important to note that the floating-point syntax error handling happens before the . attribute lookup.", "abstract": ""}, {"id": 31037917, "score": 57, "vote": 0, "content": "I guess that the . is greedily parsed as part of a number, if possible, making it the float 1., instead of being part of the method call. Spaces are not allowed around the decimal point, but you can have spaces before and after the . in a method call. If the number is followed by a space, the parse of the number is terminated, so it's unambiguous. Let's look at the different cases and how they are parsed:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/22875862/why-the-bracket-cant-be-omitted-in-int-to-bytes", "keywords": [], "tags": ["python"], "question": {"id": 22875862, "title": "why the bracket can&#39;t be omitted in int.to_bytes?", "content": "Why i can't omit the bracket 3.to_bytes(2,\"big\")?This bracket  has what function here? ", "abstract": ""}, "answers": [{"id": 22875906, "score": 1, "vote": 0, "content": "Without the brackets, Python is attempting to parse 3.to_bytes as a floating point number; that is, it's trying to make 3.<something> and there's a syntax failure when you try to access to_bytes without the dot.  If you add an extra dot, it finishes the parsing of the float and attempts to access the method, which doesn't exist: If you have it in the brackets it passes because it doesn't try to make the floating point number. You can also run it with a space to get around this: When you store the int in a variable, Python doesn't attempt to parse it as a float, which is why you don't see it that way as well when using x.to_bytes().", "abstract": ""}, {"id": 22875894, "score": 1, "vote": 0, "content": "Because 3. by itself is a decimal (float type) number.  So 3.to_bytes is parsed as (3.)to_bytes which is invalid.  So you need to say (3).to_bytes to give the dot the meaning you intended.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/17622874/invalid-syntax-confusion-on-python-integers", "keywords": [], "tags": ["python"], "question": {"id": 17622874, "title": "Invalid Syntax confusion on Python Integers", "content": "We know that everything is an object in Python and so that includes integers. So doing dir(34) is no surprise, there are attributes available. My confusion stems from the following, why is it that doing 34.__class__ gives a syntax error when I know that 34 does have the attribute __class__. Furthermore, why does binding an integer to a name, say x, and then doing x.__class__ yield my expected answer of type int?", "abstract": ""}, "answers": [{"id": 17622928, "score": 12, "vote": 0, "content": "Because 34.__class__ is not a valid floating-point number, which is what the . denotes in a numeric literal. Try (34).__class__.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/11802214/integer-literal-is-an-object-in-python", "keywords": [], "tags": ["python", "syntax"], "question": {"id": 11802214, "title": "Integer literal is an object in Python?", "content": "Possible Duplicate:\naccessing a python int literals methods  Everything in Python is an object. Even a number is an object: I tried the following, because we should be able to access class members of an object:  Why does this not work?", "abstract": ""}, "answers": [{"id": 11802308, "score": 7, "vote": 0, "content": "Although the behaviour with 1.real seems unlogical, it is expected due to the language specification: Python interprets 1. as a float (see floating point literals). But as @mutzmatron pointed out (1).real works because the expression in brackets is a valid Python object.  Update: Note the following pits:", "abstract": ""}, {"id": 11802500, "score": 7, "vote": 0, "content": "a language is usually built in three layers. when you provide a program to a language it first has to \"read\" the program.  then it builds what it has read into something it can work with.  and finally it runs that thing as \"a program\" and (hopefully) prints a result. the problem here is that the first part of python - the part that reads programs - is confused.  it's confused because it's not clever enough to know the difference between  and  what seems to be happening is that it thinks you were trying to type a number like 1.234 but made a mistake and typed letters instead(!). so this has nothing to do with what 1 \"really is\" and whether or not is it an object.  all that kind of logic happens in the second and third stages i described earlier, when python tries to build and then run the program. what you've uncovered is just a strange (but interesting!) wrinkle in how python reads programs. [i'd call it a bug, but it's probably like this for a reason.  it turns out that some things are hard for computers to read.  python is probably designed so that it's easy (fast) for the computer to read programs.  fixing this \"bug\" would probably make the part of python that reads programs slower or more complicated.  so it's probably a trade-off.]", "abstract": ""}, {"id": 11802242, "score": 19, "vote": 0, "content": "Yes, an integer literal is an object in Python. To summarize, the parser needs to be able to understand it is dealing with an object of type integer, while the statement 1.real confuses the parser into thinking it has a float 1. followed by the word real, and therefore raises a syntax error.  To test this you can also try as well as, so in the case of 1.real python is interpreting the . as a decimal point.  Edit BasicWolf puts it nicely too - 1. is being interpreted as the floating point representation of 1, so 1.real is equivalent to writing (1.)real - so with no attribute access operator  i.e. period /full stop. Hence the syntax error.  Further edit As mgilson alludes to in his/her comment: the parser can handle access to int's attributes and methods, but only as long the statement makes it clear that it is being given an int and not a float.", "abstract": ""}, {"id": 11802420, "score": 3, "vote": 0, "content": "You can still access 1.real:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/13011461/why-cant-i-call-methods-directly-on-int-objects", "keywords": [], "tags": ["python"], "question": {"id": 13011461, "title": "Why can&#39;t I call methods directly on int objects?", "content": "Possible Duplicate:\naccessing a python int literals methods\nInteger literal is an object in Python?  In python it's possible, and sometimes even common, to call methods or look up attributes directly on literals: But for some reason this does not work on integer objects: Why not?", "abstract": ""}, "answers": [{"id": 13011462, "score": 9, "vote": 0, "content": "As is normally the case when I start typing a Stack Overflow question, I find the likely answer myself as I'm researching it. Well, today I'm posting the question anyway, along with what I think is the answer: It does not work for integers because the . is interpreted as a decimal point by the parser. The float example works because the parser knows that the second period must be attribute lookup -- there is no ambiguity in this case.", "abstract": ""}]}]