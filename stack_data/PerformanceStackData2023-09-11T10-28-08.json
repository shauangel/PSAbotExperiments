[{"link": "https://stackoverflow.com/questions/30817871/android-studio-is-slow-how-to-speed-up", "keywords": [], "tags": ["android-studio"], "question": {"id": 30817871, "title": "Android Studio is slow (how to speed up)?", "content": "I recently upgraded from Eclipse to Android Studio and I'm not really liking the experience. I'm comparing them both on a Windows 7 64 bit ultimate with 16GB of ram and Intel i7 4770 running NVidia Geforce 780 with the latest NVidia drivers if it matters and I'm running the latest JDK and the latest Android Studio. The Android Studio is very slow in building the project which I can live with but it's also extremely resource intensive and sometimes slows down the PC to a crawl.  Whenever I'm building or running anything in AS, my PC seems to become extremely sluggish. It also causes flickering of screen and occasionally blanking my second monitor if I click on \"Gradle build running\" spinner which I find very odd. The RAM usage also shoots up to ~3GB which I find excessive for doing nothing (this is when it's idle after a few builds). In addition, the panels at the bottom of AS keep jumping around which is a horrible user experience (moves from Android to Messages to Version Control or anything else on an ad-hoc basis depending on what's happening which is very, very annoying). What I would like to know is basically: 1) How do I make Android Studio run better? I may be doing something wrong or missing some updates that I'm not aware of and I'm sure others have also noticed these behaviors and have found some solutions to it. 2) How do I \"pin\" the bottom panels so that they don't jump around and instead, let me, the user, navigate to them when I wish to instead of automatically switching them? Many thanks and my apologies again if it's not the correct place for these questions. Edit 1\nSome more comments:", "abstract": ""}, "answers": [{"id": 41511694, "score": 28, "vote": 0, "content": "Recommendations: Tweaks: Some people say, that OS (Operating System) might cause much slowness. For example, XP or LINUX (or etc) was mentioned to perform 70% faster (don't know why..). Disable VCS by File > Settings > Plugins and disable the following things :\nCVS Integration;  Git Integration; GitHub; Google Cloud ... things; Subversion Integration; hg4idea;\n Editor is a resource eating too (especially on Large Monitors) and slow. Make it much much faster: click Help > Edit custom VM options and add these lines :\n-Dsun.java2d.d3d=false\n-Dsun.java2d.opengl=true\n save it and Restart Android Studio. If Android Studio has a proxy server setting and can't reach the server then it takes a long time to build and waiting for a timeout. Removing it helps much. File > Settings > Appearance & Behavior > System settings > HTTP Proxy. Another Useful quote (from article): Modules are expensive\u2026 On my current project  I had to build some libraries from scratch and had to fork some that almost fitted my needs but not quite! If that modules are not constantly modified, it\u2019s important to have this into consideration: the time needed to compile them from scratch, or even to check if the previous individual module build is up-to-date, can be up to almost 4x greater than to simply load that dependency as a binary .jar/.aar. Hint: run the gradle build -profile for an HTML report showing where\nthe time goes regarding the build process. Note: keep that \u201cunnecessary\u201d modules in your version control system\nfor the eventuallity of a quickfix/improvement in that dependency. In your Gradle build script, use only \nspecific Google Service, like:   compile 'com.google.android.gms:play-services-maps:...'\nInstead of full Google Library:  compile 'com.google.android.gms:play-services:...'\n(Compile time goes from 2 minutes to around 25 seconds). Gradle configures every project before executing tasks, regardless of whether the project is actually needed for the particular build. In global gradle.properties adding this will help much: org.gradle.configureondemand=true Surprisingly, some people say , they solved problem by reducing: 1) heapsizes to  -Xmx256m (instead of higher values);  2) Emulator Ram-size (from Edit AVD > Advanced Settings);", "abstract": ""}, {"id": 75975174, "score": 0, "vote": 0, "content": "There is a case where Android Studio may be slow if you cross more than, say 5000 lines of code in a single class. The IDE seems to be facing issues in loading / formatting / linting. Modularizing the class / XML files has helped in my case. Create a class / Utility class and have the logic there, or follow MVVM kind of code. At the last resort, try Power Saving Mode, from File->Power Save Mode.", "abstract": ""}, {"id": 72421919, "score": 2, "vote": 0, "content": "One Simple thing that no one has mentioned is File>Invalidate Caches. ", "abstract": ""}, {"id": 72323893, "score": 0, "vote": 0, "content": "Balance memory consumption and build speed using gradle options. For sample Android Studio 2022.1.1 (PC RAM 16GB) Gradle v7.3.3 (./gradle/wrapper/gradle-wrapper.properties) AGP v7.2.0 (./build.gradle) Cache Fix Gradle Plugin This Google Services dependency version supports Gradle Configuration Cache ./gradle.properties Useful links: https://proandroiddev.com/how-we-reduced-our-gradle-build-times-by-over-80-51f2b6d6b05b https://developer.android.com/studio/build/profile-your-build#using-the-gradle---profile-option", "abstract": ""}, {"id": 58571621, "score": 0, "vote": 0, "content": "Apart from following the optimizations mentioned in existing answers (not much helpful, was still painfully slow), doing below did the trick for me. HP Notebook with 6 GM RAM and i5 processor I have, still android studio was terribly slow.\nAfter checking task manager for memory usage, noticed that there is a software called \"HP Touchpoint Analytics Client\" that was taking more than 1 GB memory.\nFound that it's a spyware installed by HP in Windows 10 after searching about it in Google. Uninstalled a bunch of HP software which does nothing and slows down the system. \nNow, Android studio is considerably fast - Gradle build completes in less than 30 seconds when compared to more than 2 minutes before. Every keystroke would take 5 seconds to respond, now it is real time and performance is comparable with Eclipse. This might be true for Laptops from other vendors as well like Dell, etc.\nHP really messed up the user experience with their spyware for Windows 10 users. \nUninstall them, it will help Android studio and improves the overall laptop experience as well. Hope this helps someone. Thanks.", "abstract": ""}, {"id": 30818099, "score": 302, "vote": 0, "content": "to sum it up 1) in AndroidStudio's settings > compile enable checkbox named Compile independent modules in parallel. 2) Under Help> Edit Custom VM Options I have:  P.S. - Some people say Note, instead of    VM options, it's better to combine can be overriden by combining those lines into one line single command in gradle.properties, like this : org.gradle.jvmargs=-Xms1024m -Xmx4096m ...... 3) I have an old dual core with 4GB ram, running ubuntu. Qs command line option I have only --offline (which specifies that the build should operate without accessing network resources). I also enabled the remaining checkboxes and now it's running ok: Make project automatically Use in-process building Configure on demand Check the AndroidStudio's settings, under compile that the checkbox Compile independent modules in parallel is enabled. Under Vmoptions I have I have an old dual core with 4GB ram, running ubuntu. Qs commandline option I have only --offline , which specifies that the build should operate without accessing network resources. I enabled also the remaining checkboxes: Configure on demand and it is running ok Edit It is possible to provide additional options through studio.vmoptions located at (just replace X.X with version): Windows: go to %USERPROFILE%\\.AndroidStudioX.X\\studio.exe.vmoptions   (or studio64.exe.vmoptions) Mac: ~/Library/Preferences/.AndroidStudioX.X/studio.vmoptions Linux: ~/.AndroidStudioX.X/studio.vmoptions (and/or studio64.vmoptions) Increasing the value of -Xmx should help a lot. E.g will assign 4G as max heap, with initial value of 1G Edit: On windows the defaults are stored into  C:\\Program Files\\Android\\Android Studio\\bin\\*.vmoptions. The IDE allows you to tweak those values through Help->Edit Custom VM options (thanks to @Code-Read for pointing it out). EDIT 2: Android studio 3.5 makes easier to change same of those values. Just go to:", "abstract": ""}, {"id": 57588861, "score": 11, "vote": 0, "content": "Starting from Android Studio 3.5 some of the settings can be configured via: Preferences > Appearance & Behavior > System Settings > Memory Settings ", "abstract": ""}, {"id": 49336163, "score": 6, "vote": 0, "content": "This answer pertains to slow Gradle build speeds for Windows 10 after you've already gotten the Xmx and Xms memory settings straightened out. Windows Defender As far as Windows Defender is concerned it's simply not enough to add folders / files to the Windows Defender exclusion list via \"Files\" or \"Folders\". You must add directories pertaining to Android Studio / Gradle / Java (embedded JDK or Oracle JDK) as \"Process\" exclusions to Windows Defender : This obviously comes with security implications. The following describes more details pertaining to using a \"Process\" exclusion in Windows Defender (as opposed to adding a simple \"File\" or \"Folder\" exclusion) : A file name with full path causes the particular binary file to be excluded, i.e. any files it touches, regardless of where the file is located, will not be scanned by Windows Defender. A file name without any path causes any binary file with this file name to be excluded regardless of its location. A path followed by a \"*\" (e.g. c:\\my\\private\\tools*) causes any binaries under this path to be excluded. Any files touched by these processes will be excluded. This is different from a path exclusion, where files touched by any process under the excluded path is excluded. The key here being....adding these exclusions as \"Process\" type exclusions takes into account \"files the binary touches\" as opposed to manually finding and excluding every file / folder that is generated by Android Studio / Gradle. Windows File Indexing Windows file indexing seems to also slow down Gradle builds.  Turn off Windows File Indexing for the directories used by Gradle / Android Studio. Here are my \"Windows File Indexing\" and \"Windows Defender Process\" exclusions :", "abstract": ""}, {"id": 52203475, "score": 0, "vote": 0, "content": "I have tried to measure speed of Android Studio 3.1.4 on the same hardware: Macbook Pro 2011, RAM 4Gb, SSD 240GB Samsung, Core i5 2.4Ghz. I have installed on this machine 3 different OS: Windows 10, MacOS Hight Sierra 10.13, Ubuntu 18.04. Avarage build time (running command: gradlew clean build, gradlew clean assembleRelease) on MacOS/Ubuntu was around 30% faster than on Windows. On my another working machine: Core i5 3.0 Ghz 7400, RAM 16Gb, SSD 250Gb. Build time takes 4.34min on Windows 10 machine. The same project on a little bit slower processor, but with the same RAM and SSD and it is running Ubuntu 16.04 build time takes two times faster!! Well I was shocked with results, but still I choose Windows as development machine, because it's much more comfortable for me to use comfortable and usable keyboard and sotfware than on Unix like systems. And even if I had to choose between MacOS and Ubuntu - mac is really much easier to setup everything, and Ubuntu is too complex to use for usual people. Choise is up to you.", "abstract": ""}, {"id": 49876118, "score": 11, "vote": 0, "content": "The best way to boost up android studio runtime performance is to use SSD Drive. It will boost the performance as very much. I did all the above things and felt I should go for new laptop, but suddenly I came to know about SSD Drive and I tried it. Its Much Much better.....", "abstract": ""}, {"id": 47338973, "score": 5, "vote": 0, "content": "This might sound stupid and off topic but in my case I was using an external 4k Monitor with my MacBook Pro 13' (MacOS High Sierra, 2016) and I had the resolution set to the wrong scaled resolution. Switching to another scaled resolution where there was no \"using a scaled resolution may affect performance\" warning resolved my overall performance issues. In my case I had to increase the resolution to max. So for me it was an overall performance problem which first surfaced with Android Studio, it was not an Android Studio specific problem. EDIT 25.11.2017 As a result I had to increase font sizes in Android Studio:   and on my Mac in General. I followed some of these tips to get that done.", "abstract": ""}, {"id": 47361886, "score": 3, "vote": 0, "content": "I followed this post and it worked great for me. EDIT: Following tips have been mentioned in the above post. In gradle.properties, put this: And in build.gradle, put this (Note this will disable lint check):", "abstract": ""}, {"id": 38307709, "score": 3, "vote": 0, "content": "DO NOT EDIT studio.vmoptions ,It may not work. In gradle.properties file (in app directory) add this :", "abstract": ""}, {"id": 41951063, "score": 15, "vote": 0, "content": "In one particular system I looked at, this issue was caused by an over-zealous anti-virus that was interfering with Gradle, the build manager for Android Studio. It seems every time Gradle was \"touching\" a .jar file, the virus checker was unzipping the .jar and scanning it for viruses first. The Gradle build could only continue once the unzipping and scan was complete, thus leading to very long build times (5 min plus). Since Android Studio, by default, runs a Gradle build when you start up, it manifests as an extremely slow start-up. The problem is extremely easy to check for: To solve this, you will have to add the correct directories to the \"excluded folders\" of your anti-virus. Assume that your Windows username is \"Username\" and you have installed Android Studio on C: drive. You would then request to exclude from the virus check the following directories: Please note that you may need to take additional security precautions if you exclude these directories and you should co-operate with your security department in the workplace. This may involve setting up your own Maven repository if deemed necessary. (I am aware that this is a late answer, but none of the previous answers have addressed this potential issue)", "abstract": ""}, {"id": 37937367, "score": 28, "vote": 0, "content": "Adding more memory helped me: Android Studio 2.1.2 Edit Custom VM Options:  like below:", "abstract": ""}, {"id": 39670941, "score": 2, "vote": 0, "content": "I should mention that if you are using Mac, downloading and running an app from the App Store (like \"iBoostUp\" etc.)  which will clean out unused system files can speed up your computer dramatically, including AS. I also found that adding more memory to my Mac sped up AS as well.", "abstract": ""}, {"id": 37946613, "score": 2, "vote": 0, "content": "My Android Studio was not only slow in general use, but also when building.  Here's what I did: It's fast now. My Story before that: My laptop sports an Intel Core i7-3612QM and 8gig of ram. When I builded, all the 4 cores/8 threads were on 100% usage. My entire system froze until the ~10 minute wass done. Gradle took me like ~10 unproductive minutes of slow down. This is very annoying. I am using Android Studio since 1.4. There were also tremendous slow down when I copy paste code to and from, selecting menus, right-click context menus, editing manifest, editing gradle files, opening layout files, rendering in the UI Editor, etc. Its was very unusable most of the time. Due to frustration, I did the above steps.  Its fast now. Very usable just as before. I build for only ~20 seconds compare to ~10minutes before that. Also, Android Studio eats about 6gig with emulator and browser with lots of tab open, unlike before its hovering on 98% RAM usage. Not just that, I even saved 45 gigs of space for whatever reason. I only use couple of SDKs and Emulators when I checked the Android SDK folder, it occupies 45gig of space! I think the IDE is having a hard time accessing/IO on my SDK folder. If you've tried other given solutions and still experiencing the same issue, it may be time to remove Android IDE/SDKs altogether and start anew (it might take you sometime to setup that newly, but its worth it. Considering I've been suffering this sluggishness for months and cost me my productivity). I really guess that this might be caused by cumulative patches that has been done since then. Or the 45 gig SDK folder on my poorly defragmented drive. I don't know and I could be wrong. Thank you! HTH", "abstract": ""}, {"id": 37782784, "score": 4, "vote": 0, "content": "In case setting -Xmx4096m -XX:MaxHeapSize=256m (and etc.. mentioned in above answers) doest work, then do this manually: Step 1 : Start Android studio and close any open project (File > Close Project). Step 2 : On Welcome window, Go to Configure > Settings. Step 3 : Go to Build, Execution, Deployment > Compiler Step 4 : Change Build process heap size (Mbytes) to 1024 and Additional build process to VM Options to -Xmx512m. Step 5 : Close or Restart Android Studio. ", "abstract": ""}, {"id": 33672375, "score": 0, "vote": 0, "content": "Please add in setting.gradle (root folder)", "abstract": ""}, {"id": 35153254, "score": 49, "vote": 0, "content": "I detected another reason - Thumbs.db, which affected performance badly. Go to File > Settings > Editor > File Types and in field Ignore files and folders add this:  Thumbs.db; Now, Android Studio runs like a charm.", "abstract": ""}, {"id": 32366177, "score": 64, "vote": 0, "content": "Tips to make android studio fast: Enable Offline Work: Improve Gradle Performance gradle can be optimized too. The easy way is to modify the settings in global gradle.properties (create it if not exists in the following folders: Windows - C:\\users\\your_name\\.gradle\\; Linux- /home/<username>/.gradle/; Mac- /Users/<username>/.gradle/; ) and in that file, add these two lines: For More: http://www.viralandroid.com/2015/08/how-to-make-android-studio-fast.html", "abstract": ""}, {"id": 37957824, "score": 1, "vote": 0, "content": "Click Help > Edit Custom properties and add this line: ... worked successfully for me to fix the speed issues (Windows 10 64-bit). It's absolute voodoo as far as I'm concerned (I haven't done any research on why that should work), and there is a warning above that property that it can cause blinking and fail to repaint on some graphics cards, but there you go. (Inspired by LairdPleng's comment, further information)", "abstract": ""}, {"id": 36827015, "score": 2, "vote": 0, "content": "This worked for me!\nOpen build.gradle (it's inside your project) and change the both jcenter to mavenCentral  (you can do it in Global file too: C:\\Program Files\\AndroidStudio\\plugins\\android\\lib\\templates\\gradle-projects\\NewAndroidProject\\root\\build.gradle.ftl  however, you will need to do this modification again after AndroidStudio upgrade)", "abstract": ""}, {"id": 40850177, "score": 2, "vote": 0, "content": "I've quickly resolved this issue by upgrading gradle (Android Studio seems to use old version).  1) Download latest version (https://gradle.org/gradle-download/) and unpack somewhere.\n 2) Update path in Android Studio: File > Settings > Build, Ex../Gradle", "abstract": ""}, {"id": 40608255, "score": 1, "vote": 0, "content": "I noticed that AS transfers too much data from/to HDD. It is very annoying, especially when starting to write a new line of code. So, I think, better will be reinstalling a hard disk with SSD. I have i5 with 6 Gb of memory, and the CPU seldom loads more than 50% even at build time. So, the most weak place is HDD.", "abstract": ""}, {"id": 39963784, "score": 7, "vote": 0, "content": "As you are learning, performance problems with AS are not trivial to diagnose!  In my case, an array of 9215-character-long strings (see below) was causing AS to dump threads every time I typed a few characters.  The thread dump in turn caused AS to freeze for many seconds at a time.  This bug appeared in the Windows 64 bit release of AS 2.2, still occurs in 2.2.1, but was not present in 2.1. Finding out that long strings were causing my lockups involved a lot of trial and error.  But, I learned a lot in the process, to wit: BTW, for the present I have worked around the problem I describe above by moving my long strings into a separate file (a new class containing only the array itself).  I try not to edit this file with AS:", "abstract": ""}, {"id": 39592204, "score": 2, "vote": 0, "content": "There are many ways to speed up Android Studio. Speed up gradle build time. 1.Go to Project gradle.properties file and remove comment from both line. 2.copy gradle.properties file to your .gradle folder so that you don't need to setup for every project. Enable Work Offline so that Android studio/Gradle don't need to check for newer file over internet every time. ", "abstract": ""}, {"id": 38347076, "score": 2, "vote": 0, "content": "I just want to share my case: I'm using ubuntu 32bit 4GB RAM. that's all the issue I ever encounter with AS.", "abstract": ""}, {"id": 36248856, "score": 3, "vote": 0, "content": "Well, one thing that worked for me is using physical android device instead of emulator. As in my PC( i5 and 4GB RAM ) the android studio takes about 700MB of memory and the emulator takes another 700. Thus the whole performance of the computer goes down. Working with a physical device saves the strain from the emulator.", "abstract": ""}, {"id": 33225745, "score": 3, "vote": 0, "content": "Just for anyone looking, after upgrading to El Capitan, I noticed a huge lag with the IDE. After increasing a ton of RAM and using the suggestions above, it turned out that I needed to update the legacy Java, and reinstall via: https://support.apple.com/kb/DL1572?locale=en_US After installing this, all lag was gone.", "abstract": ""}, {"id": 32764358, "score": 5, "vote": 0, "content": "It's not compiling that's hurting me here, it's the typing. I could disable all the smart features and be back to notepad++ like TomTsagk suggested in a comment. For today I need more cores and RAM. Playing devil's advocate I'd argue that typing shouldn't require a 16Gb PC octacore PC. Liked Sajan Rana's advice but things are so slow here it felt mostly a placebo. To be fair I am using 1.4RC1, which is just short of being in the stable branch. Turning the internet off helped a little. The new feature of simultaneous Design (Preview) and Text views working with XML layouts is very helpful. No, it is ridiculous. Never leave the stable channel.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/76440408/my-code-run-very-very-slow-how-can-i-make-my-python-code-that-runs-faster", "keywords": [], "tags": ["python", "gpu", "cpu", "pyqt6", "conways-game-of-life"], "question": {"id": 76440408, "title": "My code run very very slow. How can I make my python code that runs faster?", "content": "please help me. I wrote a program to run \"Game of Life\" with PyQt6 but, it runs very very slow. How can I make it faster? main.py cell.py I want to write code that runs as fast as possible", "abstract": ""}, "answers": [{"id": 76444193, "score": 2, "vote": 0, "content": "You can do a lot better by changing the structure of the core to use a matrix of \"alive\" cells represented by a numpy array of 0/1.  If you do this, you can chop out the double loop you have and let numpy do the heavy lifting of neighbor counting.  You could do some work to index that and get summations, but the 2nd enhancement is to use the process of \"convolution with a kernel\" which is very common in image processing.  Basically you are taking a kernel (in this case a 3x3 kernel to hit the neighbors) and multiplying that by the appropriate grid in your matrix for every member.  scipy has an image processing package that makes this a snap.  Note that you can set up the kernel to ignore out-of-bounds by filling it with zero (zero padding is the term.) I modified your neighbor counting function a bit to separate it from the cell class for comparison, but didn't change any of the guts. In a 500 x 500 structure, your approach takes about 1.3 seconds to calculate the number of living neighbors.  So that looping costs roughly 1 second per frame to do.  Using convolution, I can get it done in 0.004 seconds, around a 1000x speed-up. Note that when I compared results I got a failed comparison because I don't think your modulo arithmetic is accurate for the edges (it is wrapping--not desired.)  You can see it with my code if you print the first neighbor matrix. After you \"neighbor count\" you can use a couple numpy functions to figure out what the alive matrix looks like for the next evolution and just incorporate that in your code.", "abstract": ""}, {"id": 76440738, "score": 1, "vote": 0, "content": "The simplest fix you can set for yourself is to pre-calculate your cell neighbors rather than running the calculation within an O(n^2) complexity. The modulo operation can be one of the slower operations to perform, so minimizing the number of times you run it will be good. Ultimately you want to minimize or eliminate regular O(n^2) calculations to minimize CPU strain. Given that you\u2019re not doing anything super complicated here, I think this is a simple and quick performance gain you can realize. Remember that Python passes values by reference, so just initialize your neighbors in __init__ rather than passing them to calculateNewState. If you\u2019re running into performance issues, a good helper is dis.dis to see the steps in assembly code. Find your bottlenecks as each step is something your CPU needs to manage. Then, if you can remove it, your code will have fewer steps and run faster. Sometimes without seeing the low level code, it can be hard to understand where your bottlenecks really are.", "abstract": ""}, {"id": 76440497, "score": -1, "vote": 0, "content": "You could try importing and using threading so that each task that doesn't necessarily need to be completed in order can be done simultaneously and speed things up.\nIt could look something like this", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71961571/my-code-run-very-slow-how-can-i-make-it-faster", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 71961571, "title": "My code run very slow, how can I make it faster", "content": "I wrote this code to see which numbers have the condition a**4 + b**4 + c**4 = d**4 But the code I typed is very slow. Do you have any suggestions to make it faster? (I know this code is not suitable for Python language but asking me to optimize this code in the language I know.)", "abstract": ""}, "answers": [{"id": 71964875, "score": 0, "vote": 0, "content": "Mathematics and feasibility aside, here's an O(n^2) approach to optimize your O(n^3) solution.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61768198/cython-what-makes-my-program-slow-and-how-to-speed-it-up", "keywords": [], "tags": ["python", "cython"], "question": {"id": 61768198, "title": "Cython - What Makes My Program Slow and How to Speed It Up?", "content": "I am trying to speed up my cython program but I get an error on everything that I add. Does anyone know what can I do? Here is the code: print(output) is not neccessary line, please let me know if that can slow down the program. Here is the image of html file that shows what parts of the program are slower(yellow lines) and what are faster(white lines): https://i.stack.imgur.com/dLn88.png I am new to cython and this program is just test for future bigger projects. Thanks in advenced!", "abstract": ""}, "answers": [{"id": 61768367, "score": 1, "vote": 0, "content": "You are brute forcing 72^8 = 722204136308736 password combinations. It is bound to take its sweet little time. (Also please don't use the same iterator \"i\" for all your nested loops)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/8624779/my-python-program-is-very-slow-how-can-i-speed-it-up-am-i-doing-something-wron", "keywords": [], "tags": ["python", "performance"], "question": {"id": 8624779, "title": "My Python program is very slow! How can I speed it up? Am I doing something wrong?", "content": "EDIT: I ran the python profiler and the two most time-consuming things (this is after I decided to comment out the webbrowser portion and Firefox portion of the code, because I knew they were going to be the slowest part...) , the slowest part of my program is re.findall and re.compile and also (len) and (append to list). I don't know if I should post all of my code on here at once because I worked really hard on my program (even if it isn't too good), so for now I'm just going to ask...How do I make my Python program faster? I have 3 suspects right now for it being so slow: Maybe my computer is just slow Maybe my internet is too slow (sometimes my program has to download the html of web pages and then it searches through the html for a specific piece of text) My code is slow (too many loops maybe? something else? I'm new to this so I wouldn't know!) If anyone could offer me advice, I would greatly appreciate it! Thanks! EDIT: My code uses lots of loops I think...also, another thing is that for the program to work you have to be logged in to this website: http://www.locationary.com/", "abstract": ""}, "answers": [{"id": 8624798, "score": 33, "vote": 0, "content": "The first thing to do when a program is slow is to identify bottlenecks; in fact, you want to optimize things that take a long time, not things that may actually be fast.  In Python, the most efficient way to do this is with one of the Python profilers, which are dedicated tools for performance analysis.  Here is a quickstart: runs your program and stores profiling information in prof.dat.  Then, runs the profiling information analysis tool pstats.  Important pstat commands include: which sorts functions by the time spent in them, and which you can use with a different key instead of time (cumulative,\u2026). Another important command is which print statistics (or stats 10 to print the first 10 most time-consuming functions).  You can obtain help with ?, or help <command>. The way to optimize your program then consists in dealing with the particular code that causes the bottlenecks.  You can post the timing results and maybe get some more specific help on the sections of the program that could be most usefully optimized.", "abstract": ""}, {"id": 8624793, "score": 3, "vote": 0, "content": "A good place to start would be in identifying places where the code has to perform many iterations (nested for loops, for example) or process large amounts of data. Place print statements before and after these and you'll be able to determine if that's what's taking ages. Then you can look at why. Or, if it's a small program, just post the entire thing.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/12264970/why-is-my-program-slow-when-looping-over-exactly-8192-elements", "keywords": [], "tags": ["c++", "performance", "memory-management", "gcc"], "question": {"id": 12264970, "title": "Why is my program slow when looping over exactly 8192 elements?", "content": "Here is the extract from the program in question. The matrix img[][] has the size SIZE\u00d7SIZE, and is initialized at: img[j][i] = 2 * j + i Then, you make a matrix res[][], and each field in here is made to be the average of the 9 fields around it in the img matrix. The border is left at 0 for simplicity. That's all there's to the program. For completeness' sake, here is what comes before. No code comes after. As you can see, it's just initialization. Basically, this program is slow when SIZE is a multiple of 2048, e.g. the execution times: The compiler is GCC.\nFrom what I know, this is because of memory management, but I don't really know too much about that subject, which is why I'm asking here. Also how to fix this would be nice, but if someone could explain these execution times I'd already be happy enough. I already know of malloc/free, but the problem is not amount of memory used, it's merely execution time, so I don't know how that would help.", "abstract": ""}, "answers": [{"id": 12268128, "score": 59, "vote": 0, "content": "The following tests have been done with Visual C++ compiler as it is used by the default Qt Creator install (I guess with no optimization flag). When using GCC, there is no big difference between Mystical's version and my \"optimized\" code. So the conclusion is that compiler optimizations take care off micro optimization better than humans (me at last). I leave the rest of my answer for reference. It's not efficient to process images this way. It's better to use single dimension arrays. Processing all pixels is the done in one loop. Random access to points could be done using: In this particular case, it's better to compute and cache the sum of three pixels groups horizontally because they are used three times each. I've done some tests and I think it's worth sharing. Each result is an average of five tests. Original code by user1615209: Mystical's version: Two pass using a 1D array: first pass for horizontal sums, second for vertical sum and average.\nTwo pass addressing with three pointers and only increments like this: Two pass using a 1D array and addressing like this: One pass caching horizontal sums just one row ahead so they stay in cache: Conclusion: I'm sure it's possible to do much better. NOTE\nPlease, note that I wrote this answer to target general performance issues rather than the cache problem explained in Mystical's excellent answer. At the beginning it was just pseudo code. I was asked to do tests in the comments... Here is a completely refactored version with tests.", "abstract": ""}, {"id": 12265928, "score": 1005, "vote": 0, "content": "The difference is caused by the same super-alignment issue from the following related questions: But that's only because there's one other problem with the code. Starting from the original loop: First notice that the two inner loops are trivial. They can be unrolled as follows: So that leaves the two outer-loops that we're interested in. Now we can see the problem is the same in this question: Why does the order of the loops affect performance when iterating over a 2D array? You are iterating the matrix column-wise instead of row-wise. To solve this problem, you should interchange the two loops. This eliminates all the non-sequential access completely so you no longer get random slow-downs on large powers-of-two. Core i7 920 @ 3.5 GHz Original code: Interchanged Outer-Loops:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/42824853/how-can-i-speed-up-my-code", "keywords": [], "tags": ["python", "json"], "question": {"id": 42824853, "title": "how can i speed up my code?", "content": "It's a program that suggests to the user a player's name if the user made a typo. It's extremely slow.  First it has to issue a get request, then checks to see if the player's name is within the json data, if it is, pass. Else, it takes all the players' first and last names and appends it to names. Then it checks whether the first_name and last_name closely resembles the names in the list using get_close_matches. I knew from the start this would be very slow, but there has to be a faster way to do this, it's just I couldn't come up with one. Any suggestions?", "abstract": ""}, "answers": [{"id": 42825884, "score": 1, "vote": 0, "content": "Well, since it turned out my suggestion in the comments worked out, I might as well post it as an answer with some other ideas included. First, take your I/O operation out of the function so that you're not wasting time making the request every time your function is run. Instead, you will get your json and load it into local memory when you start the script. If at all possible, downloading the json data beforehand and instead opening a text file might be a faster option. Second, you should get a set of unique candidates per loop because there is no need to compare them multiple times. When a name is discarded by get_close_matches(), we know that same name does not need to be compared again. (It would be a different story if the criteria with which the name is being discarded depends on the subsequent names, but I doubt that's the case here.) Third, try to work with batches. Given that get_close_matches() is reasonably efficient, comparing to, say, 10 candidates at once shouldn't be any slower than to 1. But reducing the for loop from going over 1 million elements to over 100K elements is quite a significant boost. Fourth, I assume that you're checking for last_name == ['LastName'] and first_name == ['FirstName'] because in that case there would have been no typo. So why not simply break out of the function? Putting them all together, I can write a code that looks like this:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/41086404/computing-speed-make-programs-faster", "keywords": [], "tags": ["c++", "c++11"], "question": {"id": 41086404, "title": "Computing speed / make programs faster", "content": "I've run the following program which took my pc 94 seconds to execute (I have an i5 3.2 GHz cpu with 4 Gb ram) . I think that 94 seconds for printing a million numbers is not fast. Is there a way to make it faster ? Also why does the program end in 0.016 seconds when I don't cout my counter variable ? ( Does it really loop a million times in that time period of 0.016 seconds ? ) ", "abstract": ""}, "answers": [{"id": 41086578, "score": 1, "vote": 0, "content": "This question has nothing to do about \"computing speed\" nor about \"making programs faster\".  Incrementing a counter hardly counts as computing, and the performance overhead of emitting text to a console (that is, invoking std::cout) overshadows the computational cost of incrementing a variable by several orders of magnitude. So, this question is about the slowness of emitting text to a console. Emitting text to a console is generally viewed as something that does not need to be terribly efficient, and for this reason it is kind of slow in most operating systems, under most scenarios.  This is kind of an unfortunate situation, because software is generally emitting text to a console when we are developing it, so it slows down the development process, but it is not too bad, because software in production environments generally does not do that: the logs are written into text files, and this is considerably faster. Also, keep in mind that the process of emitting text to a console involves auxiliary overhead factors such as scrolling: once your screen has filled up with text, every new line of text causes the console window to scroll.  That's quite expensive, too. So, wanna make your printing program run faster?  Immediately after starting it, minimize the console window;  then immediately restore it to its original dimensions; you will find that it will be done.  Almost all of the overhead is in displaying text and scrolling the window.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/40876604/python-program-with-permutations-too-slow-any-ways-to-speed-up-the-program", "keywords": [], "tags": ["python", "coding-efficiency"], "question": {"id": 40876604, "title": "Python program with permutations too slow,any ways to speed up the program?", "content": "https://www.ksp.sk/ulohy/zadania/1238/ Link to problem(In slovak) The simplest english translation:  The 1st,named signlist, variable is an input of an undefined number of \"<\" and \">\" symbols. The 2nd,named n,is the length of signlist + 1,because its the amount of numbers to go between those symbols(ex. 2>1<3,signlist has 2 symbols,n is 3,numbers are a list of the range 1-n+1 exclusivly). \nIm supposed to print out the correct order of numbers for the symbols(ex.  4 3 2 1 for the input >>>.)\nMy code works,but is slow according to the website.\nCommented out is the first version which i based the list compherehensions on.", "abstract": ""}, "answers": [{"id": 40877097, "score": 0, "vote": 0, "content": "I suspect that your most controllable source of slowdown is building that huge list.  Instead, take the permutations individually.  Handle each expression in order (which should save time when N is huge); alternately, generate a list of all the expressions and hit them with an all reduction. Perhaps better for huge lists is to take the list of numbers 1-n and the list of operators.  At each level, split the list into legal and illegal unused numbers for that operator.  Recur on each element of the legal list. For instance, let's just assume that you've been called with [2, 3, 4, 7, 8] and the current string \"5<>><>\".  You now need to accept only numbers x such that 5 < x.  You take the left-hand part of the list and recur on each of 2, 3, and 4.  The first one looks like: This will fail; the next one is See how that works?  On average, you'll recur on half the elements at each level, and prune the dead ends before you have to generate all of the permutations. Is that enough of a start to let you move ahead on the recursive algorithm?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16156130/why-is-my-program-so-slow", "keywords": [], "tags": ["c++", "benchmarking", "google-nativeclient"], "question": {"id": 16156130, "title": "Why is my program so slow?", "content": "Someone decided to do a quick test to see how native client compared to javascript in terms of speed. They did that by running 10 000 000 sqrt calculations and measuring the time it took. The result with javascript: 0.096 seconds, and with NaCl: 4.241 seconds... How can that be? Isn't speed one of the reasons to use NaCl in the first place? Or am i missing some compiler flags or something? Heres the code that was run: PS: This question is an edited version of something that appeared in the native client mailing list", "abstract": ""}, "answers": [{"id": 16156167, "score": 21, "vote": 0, "content": "NOTE: This answer is an edited version of something that appeared in the native client mailing list Microbenchmarks are tricky: unless you understand what you are doing VERY well it's easy to produce apples-to-oranges comparisons which are not relevant to the behavior you want to observe/measure at all. I'll elaborate a bit using your own example (I'll exclude NaCl and stick to the existing, \"tried and true\" technologies). Here is your test as native C program: Ok. We can do billion cycles in 25.43 seconds. But let's see what takes time: let's replace \"result += sqrt(i);\" with \"result += i;\" Wow! 95% of time was actually spend in CPU-provided sqrt function, everything else took less then 5%. But what if we'll change the code just a bit: replace \"printf(\"%g %g\\n\", result, tt);\" with \"printf(\"%g\\n\", tt);\" ? Hmm... Looks like now \"sqrt\" is almost as fast as \"+\". How can this be? How can printf affect the previous cycle AT ALL? Let's see: First version actually calls sqrt billion times, but second one does not do that at all! Instead it checks if the number is negative and calls sqrt only in this case! Why? What the compiler (or, rather, compiler authors) are trying to do here? Well, it's simple: since we've not used \"result\" in this particular version it can safely omit \"sqrt\" call... if the value is not negative, that is! If it's negative then (depending on FPU flags) sqrt can do different things (return nonsensical result, crash the program, etc). That's why this version is dozen of times faster - but it does not calculate square roots at all! Here is final example which shows how wrong microbenchmarks can go: Execution time is... ZERO? How can it be? Billion calculations in less then blink of eye? Let's see: Uh, oh, cycle is completely eliminated! All calculations happened at compile time and to add insult to injury both \"clock\" calls were executed before body of the cycle to boot! What if we'll put it in separate function? Still the same??? How can this be? Uh-oh: compiler is clever enough to replace cycle with a multiplication! Now if you'll add NaCl on one side and JavaScript on the other side you'll get such a complex system that results are literally unpredictable. The problem here is that for microbenchmark you are trying to isolate piece of code and then evaluate it's properties, but then compiler (no matter JIT or AOT) will try to thwart your efforts because it tries to remove all the useless calculations from your program! Microbenchmarks useful, sure, but they are FORENSIC ANALYSIS tool, not something you want to use to compare speed of two different systems! For that you need some \"real\" (in some sense of the world: something which can not be optimized to pieces by over-eager compiler) workload: sorting algorithms are popular, in particular. Benchmarks which use sqrt are especially nasty because, as we've seen, usually they spend over 90% of time executing one single CPU instruction: sqrtsd (fsqrt if it's 32-bit version) which is, of course, identical for JavaScript and NaCl. These benchmarks (if properly implemented) may serve as a litmus test (if speed of some implementation differs too much from what simple native version exhibits then you are doing something wrong), but they are useless as comparison of speeds of NaCl, JavaScript, C# or Visual Basic.", "abstract": ""}]}]