[{"link": "https://stackoverflow.com/questions/3536620/how-to-change-a-module-variable-from-another-module", "keywords": [], "tags": ["python", "import", "module"], "question": {"id": 3536620, "title": "How to change a module variable from another module?", "content": "Suppose I have a package named bar, and it contains bar.py: and __init__.py: Then I execute this script: Here's what I expect: Here's what I get: Can anyone explain my misconception?", "abstract": ""}, "answers": [{"id": 76746593, "score": 0, "vote": 0, "content": "When I need to change certain configuration variables in a module or package, I normally utilize it into a mutable object. I think it is the namespace and reference concept in Python. In your case, I'll make the following changes. bar/bar.py bar/__init__.py main.py", "abstract": ""}, {"id": 3537045, "score": 33, "vote": 0, "content": "One source of difficulty with this question is that you have a program named bar/bar.py: import bar imports either bar/__init__.py or bar/bar.py, depending on where it is done, which makes it a little cumbersome to track which a is bar.a. Here is how it works: The key to understanding what happens is to realize that in your __init__.py, in effect does something like and defines a new variable (bar/__init__.py:a, if you wish).  Thus, your from bar import a in __init__.py binds name bar/__init__.py:a to the original bar.py:a object (None).  This is why you can do from bar import a as a2 in __init__.py: in this case, it is clear that you have both bar/bar.py:a and a distinct variable name bar/__init__.py:a2 (in your case, the names of the two variables just happen to both be a, but they still live in different namespaces: in __init__.py, they are bar.a and a). Now, when you do you are accessing variable bar/__init__.py:a (since import bar imports your bar/__init__.py). This is the variable you modify (to\u00a01). You are not touching the contents of variable bar/bar.py:a. So when you subsequently do you call bar/bar.py:foobar(), which accesses variable a from bar/bar.py, which is still None (when foobar() is defined, it binds variable names once and for all, so the a in bar.py is bar.py:a, not any other a variable defined in another module\u2014as there might be many a variables in all the imported modules).  Hence the last None output. Conclusion: it is best to avoid any ambiguity in import bar, by not having any bar/bar.py module (since bar.__init__.py makes directory bar/ a package already, that you can also import with import bar).", "abstract": ""}, {"id": 3536638, "score": 151, "vote": 0, "content": "You are using from bar import a. a becomes a symbol in the global scope of the importing module (or whatever scope the import statement occurs in).  When you assign a new value to a, you are just changing which value a points too, not the actual value. Try to import bar.py directly with import bar in __init__.py and conduct your experiment there by setting bar.a = 1. This way, you will actually be modifying bar.__dict__['a'] which is the 'real' value of a in this context. It's a little convoluted with three layers but bar.a = 1 changes the value of a in the module called bar that is actually derived from __init__.py. It does not change the value of a that foobar sees because foobar lives in the actual file bar.py. You could set bar.bar.a if you wanted to change that. This is one of the dangers of using the from foo import bar form of the import statement: it splits bar into two symbols, one visible globally from within foo which starts off pointing to the original value and a different symbol visible in the scope where the import statement is executed. Changing a where a symbol points doesn't change the value that it pointed too. This sort of stuff is a killer when trying to reload a module from the interactive interpreter.", "abstract": ""}, {"id": 43855120, "score": 21, "vote": 0, "content": "To put another way:\nTurns out this misconception is very easy to make. \nIt is sneakily defined in the Python language reference: the use of object instead of symbol. I would suggest that the Python language reference make this more clear and less sparse.. The from form does not bind the module name: it goes through the\n  list of identifiers, looks each one of them up in the module found in\n  step (1), and binds the name in the local namespace to the object thus\n  found. HOWEVER: When you import, you import the current value of the imported symbol and add it to your namespace as defined. You are not importing a reference, you are effectively importing a value. Thus, to get the updated value of i, you must import a variable that holds a reference to that symbol. In other words, importing is NOT like an import in JAVA, external declaration in C/C++ or even a use clause in PERL. Rather, the following statement in Python: is more like the following code in K&R C: (caveat: in the Python case, \"a\" and \"x\" are essentially a reference to the actual value: you're not copying the INT, you're copying the reference address) ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/24722212/python-cant-find-module-in-the-same-folder", "keywords": [], "tags": ["python", "module"], "question": {"id": 24722212, "title": "Python can&#39;t find module in the same folder", "content": "My python somehow can't find any modules in the same directory.\nWhat am I doing wrong? (python2.7) So I have one directory '2014_07_13_test', with two files in it:  where hello.py: and test.py: Still python gives me  What's wrong?", "abstract": ""}, "answers": [{"id": 76308045, "score": 1, "vote": 0, "content": "The imports only worked for me when I recreated a new file using the command line instead of Visual Studio Code's \"Create New File\" command. In the command line: then, import as per the other's recommendation", "abstract": ""}, {"id": 76279697, "score": 0, "vote": 0, "content": "It is likely that your working directory is still set to the parent folder. To solve this issue, you need to first check your current working directory as follows: If it's different from the directory containing the modules set your correct directory as follows:", "abstract": ""}, {"id": 76068483, "score": 0, "vote": 0, "content": "I just ran into this. I have a flask app that starts in an app.py file. I had lots of other files scattered around in the same directory when I decided that I wanted to clean it up a bit so I created a sub-directory called \"local_lib\" and moved all of the .py files except for app.py into it. Then I changed the import lines in app.py to look like this... from local_lib.user import User But I couldn't seem to import files into each other inside the local_lib directory. My directory structure looks like this... It eventually dawned on me that the application was running in the context of the directory where app.py lives so I had to change my imports to ALL look like this... which ficksed it. PyCharm doesn't like it, because it has all of the imports underline din red wavy lines, but it works. I'm still learning Python so this is annoying, but it is what it is.", "abstract": ""}, {"id": 74277429, "score": -1, "vote": 0, "content": "The same error, but I didn't find an answer to my case, maybe someone need my solution. It appears that in PyCharm I've created .py file, but somehow in windows directory of my project file was blank and without .py. So I rename extension right in derictory and it worked. Picture before changing an extension", "abstract": ""}, {"id": 73162853, "score": 0, "vote": 0, "content": "This kind of problems happens when your project path is changed. You need to use: cd path\\to\\the\\files_path simply", "abstract": ""}, {"id": 72143941, "score": 0, "vote": 0, "content": "Also recheck spelling of both the file and the module for typos. For example When the file name has been saved as password missing an s. It might sound obvious but it can sometimes be something as simple as this when all other advice above not working :)", "abstract": ""}, {"id": 71142082, "score": 1, "vote": 0, "content": "After spending hours to get imports working like: ...\nI got finally rid of my embedded python installation and installed python from the scratch by be the .exe file for all users like in then I made sure my PATH Variable is up to date with the new installation (so what we want to see or make are entries like c:\\Program Files\\Python310 and c:\\Program Files\\Python310\\Scripts and %USERPROFILE%\\AppData\\Roaming\\Python\\Python310\\Scripts) and started a cmd with administrator privileges, downloaded the get-pip.py file and run it in the elivated cmd like python get-pip.py and finaly everything worked as expected... I don't know why or what I did wrong or so, but python really seems that it need to be integrated deeply into windows or it just do not work the easy way. It doesn't happen too often, but in this case it worked a lot better in linux ;)", "abstract": ""}, {"id": 68988427, "score": 2, "vote": 0, "content": "I had somewhat of a similar problem. I could not import modules even though they all were in the same directory (importError). I tried out the solutions above but none of them worked for me. I had to set up the path myself (manually). Also, the code was run on my university server, perhaps that's why I had to set the path manually. I recommend reading The Module Search Path", "abstract": ""}, {"id": 64782745, "score": 1, "vote": 0, "content": "If you are sure that all the modules, files you're trying to import are in the same folder and they should be picked directly just by giving the name and not the reference path then your editor or terminal should have opened the main folder where all the files/modules are present. Either, try running from Terminal, make sure first you go to the correct directory. cd path to the root folder where all the modules are python script.py Or if running [F5] from the editor i.e VsCode then open the complete folder there and not the individual files.", "abstract": ""}, {"id": 64626980, "score": 1, "vote": 0, "content": "The following doesn't solve the OP's problem, but the title and error is exactly what I faced. If your project has a setup.py script in it, you can install that package you are in, with python3 -m pip install -e . or python3 setup.py install or python3 setup.py develop, and this package will be installed, but still editable (so changes to the code will be seen when importing the package). If it doesn't have a setup.py, make sense of it. In the case of OP with 2 test files, modifying them to work is probably fine. However, in other real scenarios, the methods listed in the other answers is probably not recommended. They require you to modify the python code or restrict your flexibility (running the python file from a specific directory) and generally introduce annoyances. What if you've just cloned a project, and this happens? It probably already works for other people, and making code changes is unnecessary. The chosen answer also wants people to run a script from a specific folder to make it work. This can be a source of long term annoyance, which is never good. It also suggests adding your specific python folder to PATH (can be done through python or command line). Again, what happens if you rename or move the folder in a few months? You have to hunt down this page again, and eventually discover you need to set the path (and that you did exactly this a few months ago), and that you simply need to update a path (sure you could use sys.path and programmatically set it, but this can be flaky still). Many sources of great annoyance.", "abstract": ""}, {"id": 55524402, "score": 2, "vote": 0, "content": "I ran into this issue. I had three folders in the same directory so I had to specify which folder.\n        Ex: from Folder import script", "abstract": ""}, {"id": 53151701, "score": 14, "vote": 0, "content": "In my case, Python was unable to find it because I'd put the code inside a module with hyphens, e.g. my-module. When I changed it to my_module it worked.", "abstract": ""}, {"id": 44713846, "score": 37, "vote": 0, "content": "Here is the generic solution I use. It solves the problem for importing from modules in the same folder:  Put this at top of the module which gives the error \"No module named xxxx\"", "abstract": ""}, {"id": 44230992, "score": 40, "vote": 0, "content": "I had a similar problem, I solved it by explicitly adding the file's directory to the path list: After that, I had no problem importing from the same directory.", "abstract": ""}, {"id": 41765408, "score": 202, "vote": 0, "content": "Change your import in test.py to:", "abstract": ""}, {"id": 24722419, "score": 116, "vote": 0, "content": "Your code is fine, I suspect your problem is how you are launching it. You need to launch python from your '2014_07_13_test' directory. Open up a command prompt and 'cd' into your '2014_07_13_test' directory. For instance: If you cannot 'cd' into the directory like this you can add it to sys.path  In test.py: Or set/edit the PYTHONPATH And all should be well... ...well there is a slight mistake with your 'shebang' lines (the first line in both your files), there shouldn't be a space between the '#' and the '!' There is a better shebang you should use. Also you don't need the shebang line on every file... only the ones you intend to run from your shell as executable files.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/5296977/what-will-happen-if-i-modify-a-python-script-while-its-running", "keywords": [], "tags": ["python"], "question": {"id": 5296977, "title": "What will happen if I modify a Python script while it&#39;s running?", "content": "Imagine a python script that will take a long time to run, what will happen if I modify it while it's running? Will the result be different?", "abstract": ""}, "answers": [{"id": 74911284, "score": 1, "vote": 0, "content": "Nothing, as this answer. Besides, I did experiment when multiprocessing is involved. Save the script below as x.py: After python3 x.py and after the first two 'hello' being printed out, I modified ['hello'] to ['world'] and observed what happend. Nothing interesting happened. The result was still:", "abstract": ""}, {"id": 70109510, "score": 1, "vote": 0, "content": "If you run the following script: Then change \"Hello World!\" to \"Hello StackOverflow!\" while it's counting down, it will still output \"Hello World\".", "abstract": ""}, {"id": 70131599, "score": -3, "vote": 0, "content": "This is slightly different from what you describe in your question, but it works: Test run: See, you can change the behavior of your \"loaded\" code dynamically.", "abstract": ""}, {"id": 70108346, "score": 1, "vote": 0, "content": "No, the result will not reflect the changes once saved. The result will not change when running regular python files. You will have to save your changes and re-run your program.", "abstract": ""}, {"id": 70098693, "score": 17, "vote": 0, "content": "This is a fun question. The answer is that \"it depends\". Consider the following code: Try saving the above as \"/tmp/bad.py\" then do \"cd /tmp\" and finally \"python3 bad.py\" and see what happens. On my ubuntu 20 system I see the output: So again, the answer to your question is \"it depends\". If you don't do anything funky then the script is in memory and you are fine. But python is a pretty dynamic language so there are a variety of ways to modify your \"script\" and have it affect the output. If you aren't trying to do anything funky, then probably one of the things to watch out for are imports inside functions. Below is another example which illustrates the idea (save as \"/tmp/modify.py\" and do \"cd /tmp\" and then \"python3 modify.py\" to run). The fiddle function defined below simulates you modifying the script while it is running (if desired, you could remove the fiddle function, put in a time.sleep(300) at the second to last line, and modify the file yourself). The point is that since the show function is doing an import inside the function instead of at the top of the module, the import won't happen until the function is called. If you have modified the script before you call show, then your modified version of the script will be used. If you are seeing surprising or unexpected behavior from modifying a running script, I would suggest looking for import statements inside functions. There are sometimes good reasons to do that sort of thing so you will see it in people's code as well as some libraries from time to time. Below is the demonstration of how an import inside a function can cause strange effects. You can try this as is vs commenting out the call to the fiddle function to see the effect of modifying a script while it is running.", "abstract": ""}, {"id": 70094574, "score": 23, "vote": 0, "content": "When you run a python program and the interpreter is started up, the first thing that happens is the following: When a module is initialized, it's code is run, defining classes, variables, and functions in the process. The first step of your module (i.e. main file) will probably be to import other modules, which will again be initialized in just the same way; their resulting namespaces are then made available for your module to use. The result of an importing process is in part a module (python-) object in memory. This object does have fields that point to the .py and .pyc content, but these are not evaluated anymore: module objects are cached and their source never run twice. Hence, modifying the module afterwards on disk has no effect on the execution. It can have an effect when the source is read for introspective purposes, such as when exceptions are thrown, or via the module inspect. This is why the check if __name__ == \"__main__\" is necessary when adding code that is not intended to run when the module is imported. Running the file as main is equivalent to that file being imported, with the exception of __name__ having a different value. Sources:", "abstract": ""}, {"id": 70072657, "score": -5, "vote": 0, "content": "depending. if a python script links to other modified file, then will load newer version ofcourse. but if source doesnt point to any other file it'll just run all script from cache as long as its run. changes will be visible next time... and if about auto-applying changes when they're made - yes, @pcbacterio was correct. its possible to do thar but script which does it just remembers last action/thing what was doing and checks when the file is modified to rerun it (so its almost invisible) =]", "abstract": ""}, {"id": 70066818, "score": -2, "vote": 0, "content": "It happens nothing. Once the script is loaded in memory and running it will keep like this. An \"auto-reloading\" feature can be implemented anyway in your code, like Flask and other frameworks does.", "abstract": ""}, {"id": 5296992, "score": 429, "vote": 0, "content": "Nothing, because Python precompiles your script into a PYC file and launches that. However, if some kind of exception occurs, you may get a slightly misleading explanation, because line X may have different code than before you started the script.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64158622/jupyter-does-not-see-changes-in-the-imported-module", "keywords": [], "tags": ["python-3.x", "jupyter-notebook"], "question": {"id": 64158622, "title": "Jupyter does not see changes in the imported module", "content": "I have a file called \"Notebook.ipynb\". I want to import my own module into it patterns.py. Let's say in patterns.py I have a variable a=1. If I print it in Jupyter after importing it, I expect to get 1. But if I change the value of the variable to patterns.py Jupyter will continue to think that the variable a is equal to one. At the same time, of course, I restart the cell in which the variable is imported from patterns.py What do I need to do to make Jupyter understand that the value of the variable has changed?", "abstract": ""}, "answers": [{"id": 70943990, "score": 2, "vote": 0, "content": "Just in addition to @ilia post:\nLet's say the module's name is main.py\nThat's the code I put in the Jupiter's notebook cell, just before calling functions from the main module", "abstract": ""}, {"id": 64166391, "score": 5, "vote": 0, "content": "There's actually a nifty IPython extension for this called autoreload.  This answer shows how to use it in an IPython shell, but you can do the same in a Jupyter notebook.  Just add: before you import the module whose changes you want to have tracked, and it'll be re-imported before every cell you execute.", "abstract": ""}, {"id": 64294886, "score": 7, "vote": 0, "content": "Suppose we have a file at folder_name/filename.py and call it in some .ipynb which was modified like this In this case, second call of the following code in .ipynb returns test To update the function, you need to reload the module: This code will return test2 \nDon't forget to import importlib before you run reload", "abstract": ""}, {"id": 64158748, "score": 4, "vote": 0, "content": "This has happened to me. You need to restart the python kernel so jupyter can read the new state of the python scripts located in the working directory. Then the variable a should print the new assigned value.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/32972902/does-python-detect-updating-of-an-imported-module", "keywords": [], "tags": ["python", "python-module"], "question": {"id": 32972902, "title": "Does Python detect updating of an imported module?", "content": "Module A imports a class C from B. A has a 'run' procedure which inter alia creates an instance of C.\nAfter the first run, module B is updated without exiting A; then a second run is done. Will the new instance of C be from the updated version of B or the original?", "abstract": ""}, "answers": [{"id": 32987149, "score": 0, "vote": 0, "content": "No, it will probably use the original. When you import the class C from B in A you will create a reference to an object in A (happens to be a class) called C. If you don't reassign to C it will still refer to the same object, so unless you actually modify the very same object during the update of B the changes wouldn't be visibly from A via the use of C. Now for some examples of how you might have done: If you just edit the source of B (after the input in the below code) and have the following python code: Then you haven't modified anything as far as A is concerned, it even didn't bother to look at your modified source. Now let's try to reimport: Now you do reassign to C, but still Python does not bother to look at your modification. The second import first checks if it has loaded the B module, and it has and then it just grabs C from it and puts into As namespace. Now let's try a little bit harder: Then still no luck; the reload(B) only tells the interpreter to reload the module, so now B refers to the new module, but C wasn't updated in this process. Now for the nearest you get: Now c2 = C() will use the class definition from the modified B, but be aware that the c1 did use the old definition and its type is still the old version of the class C. Last, as I mentioned, actually modifying the very same object I guess I'd give an example: Here the class C is first defined and an object is created. Then I modify the class C by adding a method to it. The type of c hasn't changed. It's the very same class, but now that class have got a new method since c was created.", "abstract": ""}, {"id": 32973360, "score": 0, "vote": 0, "content": "That depends on you notion of update: Remember that Python is a compiled language: A module is read and compiled into byte code. So when you change the source file, nothing happens because the code was already compiled. Simply importing a module repeatedly also does nothing, the importer simply checks sys.modules and returns the already existing module from there. A module load is only triggered when you load an unknown module (according to sys.modules). There is also no auto-check for changed source files, so source files are not automatically recompiled when they have changed. However, compiled files (.pyc, .pyo) are checked against their source files before they are used. If the corresponding source files are newer or have a different size, recompilation happens for fresh loads (not on import, on load). Note, however, that the .pyc timestamp resolution is only 32 bits, so the actual file system timestamp is truncated. You can jump through some serious hoops to make Python import a changed source file: This is actually by coincidence, but the code shows one of the real problems that occur with reimporting and recompilation. Because the two B.pys are created quickly after another, their timestamps more often than not compare equal to the .pyc timestamp. You might get lucky and hit the actual timestamp flip, but that's just luck. Since the files are also the same size on Unix (note the extra newline for the second version), the file size check also reports both source files to be equal. If you remove the unlink() operations, you --most of the time-- get no module recompile. Instead you get the version version of B loaded from the .pyc file, even though it does not match B.py any more. In any case, the code objects from the initial import are retained. In this example, first_class is from the initial version of B.py, second_class is from the updated version. The first class is already compiled into byte code and in memory, it does not change just because you change its source file. For all practical purposes, both classes are from different modules that incidentally happen to have the same source file. This is probably only useful for debugging and I strongly advise against using it for anything productive. This is especially true, if your module has more than the single source file. That said, reload() doesn't exist any more in Python 3, because it never worked as expected even in Python 2.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/45405600/how-to-reload-all-imported-modules", "keywords": [], "tags": ["python", "python-3.x", "module", "python-import"], "question": {"id": 45405600, "title": "How to reload all imported modules?", "content": "I have several modules, I would like to reload without having to restart Sublime Text, while I am developing a Sublime Text package. I am running Sublime Text build 3142 which comes with python3.3 running continuously its packages/plugins. However while developing a plugin, I import a third part module I added to path as: But when I edit the source code of the module six I need to close and open Sublime Text again, otherwise Sublime Text does not gets the changes to the six python module. Some code I have tried so far:", "abstract": ""}, "answers": [{"id": 45405667, "score": 12, "vote": 0, "content": "To list all imported modules, you can use sys.modules.values(). sys.modules is a dictionary that maps the string names of modules to their references. To reload modules, you can loop over the returned list from above and call importlib.reload on each one:", "abstract": ""}, {"id": 61019586, "score": 9, "vote": 0, "content": "I imagine in most situations, you want to reload only the modules that you yourself are editing. One reason to do this is to avoid expensive reloads, and another is hinted in @dwanderson's comment, when reloading pre-loaded modules might be sensitive to the order in which they are loaded. It's particularly problematic to reload importlib itself. Anyways, the following code reloads only the modules imported after the code is run: The code is not exactly correct because of the except block, but it seems robust enough for my own purposes (reloading imports in a REPL).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/33862420/ipython-notebook-how-to-reload-all-modules-in-a-specific-python-file", "keywords": [], "tags": ["python", "ipython", "jupyter-notebook"], "question": {"id": 33862420, "title": "IPython notebook: how to reload all modules in a specific Python file?", "content": "I define many modules in a file, and add from myFile import * to the first line of my ipython notebook so that I can use it as dependency for other parts in this notebook. Currently my workflow is: Does anyone know if there is a way to reload all modules in myFile without need to restart the Ipython kernel?  Thanks!", "abstract": ""}, "answers": [{"id": 59440388, "score": 16, "vote": 0, "content": "Use importlib! So when you do changes in your my_awesome_python_script in the backend, no need to restart the kernel or re-run the entire notebook again. Just re-run this cell.\nThis is extremely useful if you did a lot of work on memory heavy datasets ", "abstract": ""}, {"id": 33862495, "score": 66, "vote": 0, "content": "From the ipython docs: You can also configure the auto reload to happen automatically by doing this:\nipython profile create and adding the following to ~/.config/ipython/profile_default/ipython_config.py Note:  If you rename a function, you need to rerun your import statement", "abstract": ""}, {"id": 33862460, "score": -8, "vote": 0, "content": "You should you start your workflow after restarting and opening a notebook again by running all cells. In the top menu, before you do anything else, first select \"Cell->Run all\"", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/29292029/python-changes-to-imported-file-do-not-take-effect", "keywords": [], "tags": ["python", "python-2.7", "debugging", "enthought"], "question": {"id": 29292029, "title": "Python - Changes to imported file do not take effect", "content": "I have a file called test_file, which is designed to test another file, called file. 'test_file' also contains a .txt file in the same directory.  When I update file, save, select 'Change to Editor Directory...', then run test_file, Enthought does not seem to recognize that file was updated. Initially I thought I had to select the 'Change to Editor Directory' option every time I updated file, and so I did, but test_file was still printing 'success', even after I deliberately edited file so that test_file should print false. (Yes, I'm sure that it should have printed false as I added a bunch of gibberish code into file, and even code that shouldn't run, such as throwing in return statements with blatantly incorrect indentation). So, essentially, Enthought Canopy isn't realizing that I've updated file. However, if I save and quit everything, reopen Enthought, select 'Change to Editor Directory', then run test_file, it prints the correct outcome. This is very frustrating, because I spent days debugging correct code before I realized this. It has me very concerned because I don't know if what I tested in the past is actually correct, and I don't want this to happen in the future. What is the possible cause of this? (Note: I don't know if this is an Enthought issue or a Python issue)", "abstract": ""}, "answers": [{"id": 55417917, "score": 4, "vote": 0, "content": "With Python 2.x, @pberkes' answer works. For the other Python versions, you may want to see this answer to another SO post.", "abstract": ""}, {"id": 29296139, "score": 9, "vote": 0, "content": "It's hard to say without seeing the code, but I suspect that file is being imported with a command equivalent to import file. Python caches imported modules, and so it would not pick up the changes in file. This is a Python feature, and is independent of Enthought Canopy. If that's the case, you can solve the problem by adding a call to reload (http://bit.ly/1E97V4n) after the import in test_file, to explicitly force a reload of the module:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/684171/how-to-re-import-an-updated-package-while-in-python-interpreter", "keywords": [], "tags": ["python"], "question": {"id": 684171, "title": "How to re import an updated package while in Python Interpreter?", "content": "I often test my module in the Python Interpreter, and when I see an error, I quickly update the .py file. But how do I make it reflect on the Interpreter ? So, far I have been exiting and reentering the Interpreter because re importing the file again is not working for me.", "abstract": ""}, "answers": [{"id": 22894171, "score": 236, "vote": 0, "content": "All the answers above about reload() or imp.reload() are deprecated. reload() is no longer a builtin function in python 3 and imp.reload() is marked deprecated (see help(imp)). It's better to use importlib.reload() instead.", "abstract": ""}, {"id": 684186, "score": 398, "vote": 0, "content": "Update for Python3: (quoted from the already-answered answer, since the last edit/comment here suggested a deprecated method) In Python 3, reload was moved to the imp module. In 3.4, imp was deprecated in favor of importlib, and reload was added to the latter. When targeting 3 or later, either reference the appropriate module when calling reload or import it. Takeaway: Use the reload builtin function: https://docs.python.org/2/library/functions.html#reload When reload(module) is executed: Example:", "abstract": ""}, {"id": 8637233, "score": 10, "vote": 0, "content": "Short answer: try using reimport: a full featured reload for Python. Longer answer: It looks like this question was asked/answered prior to the release of reimport, which bills itself as a \"full featured reload for Python\": This module intends to be a full featured replacement for Python's reload function. It is targeted towards making a reload that works for Python plugins and extensions used by longer running applications. Reimport currently supports Python 2.4 through 2.6. By its very nature, this is not a completely solvable problem. The goal of this module is to make the most common sorts of updates work well. It also allows individual modules and package to assist in the process. A more detailed description of what happens is on the overview page. Note: Although the reimport explicitly supports Python 2.4 through 2.6, I've been trying it on 2.7 and it seems to work just fine.", "abstract": ""}, {"id": 36375742, "score": 21, "vote": 0, "content": "No matter how many times you import a module, you'll get the same copy of the module from sys.modules - which was loaded at first import mymodule I am answering this late, as each of the above/previous answer has a bit of the answer, so I am attempting to sum it all up in a single answer. Using built-in function: For Python 2.x - Use the built-in reload(mymodule) function. For Python 3.x - Use the imp.reload(mymodule). For Python 3.4 - In Python 3.4 imp has been deprecated in favor of importlib i.e. importlib.reload(mymodule) Few caveats:  External packages: reimport - Reimport currently supports Python 2.4 through 2.7. xreload- This works by executing the module in a scratch namespace, and then\npatching classes, methods and functions in place.  This avoids the\nneed to patch instances.  New objects are copied into the target\nnamespace. livecoding - Code reloading allows a running application to change its behaviour in response to changes in the Python scripts it uses. When the library detects a Python script has been modified, it reloads that script and replaces the objects it had previously made available for use with newly reloaded versions. As a tool, it allows a programmer to avoid interruption to their workflow and a corresponding loss of focus. It enables them to remain in a state of flow. Where previously they might have needed to restart the application in order to put changed code into effect, those changes can be applied immediately.", "abstract": ""}, {"id": 34201014, "score": 2, "vote": 0, "content": "dragonfly's answer worked for me (python 3.4.3). Here is a lower level solution :", "abstract": ""}, {"id": 30608568, "score": 5, "vote": 0, "content": "", "abstract": ""}, {"id": 684229, "score": 39, "vote": 0, "content": "So, far I have been exiting and reentering the Interpreter because re importing the file again is not working for me. Yes, just saying import again gives you the existing copy of the module from sys.modules. You can say reload(module) to update sys.modules and get a new copy of that single module, but if any other modules have a reference to the original module or any object from the original module, they will keep their old references and Very Confusing Things will happen. So if you've got a module a, which depends on module b, and b changes, you have to \u2018reload b\u2019 followed by \u2018reload a\u2019. If you've got two modules which depend on each other, which is extremely common when those modules are part of the same package, you can't reload them both: if you reload p.a it'll get a reference to the old p.b, and vice versa. The only way to do it is to unload them both at once by deleting their items from sys.modules, before importing them again. This is icky and has some practical pitfalls to do with modules entries being None as a failed-relative-import marker. And if you've got a module which passes references to its objects to system modules\u2009\u2014\u2009for example it registers a codec, or adds a warnings handler\u2009\u2014\u2009you're stuck; you can't reload the system module without confusing the rest of the Python environment. In summary: for all but the simplest case of one self-contained module being loaded by one standalone script, reload() is very tricky to get right; if, as you imply, you are using a \u2018package\u2019, you will probably be better off continuing to cycle the interpreter.", "abstract": ""}, {"id": 13121908, "score": 27, "vote": 0, "content": "In Python 3, the behaviour changes.   ... do something with my_stuff, then later: and you get a brand new, reloaded my_stuff.", "abstract": ""}, {"id": 684311, "score": 3, "vote": 0, "content": "See here for a good explanation of how your dependent modules won't be reloaded and the effects that can have: http://pyunit.sourceforge.net/notes/reloading.html The way pyunit solved it was to track dependent modules by overriding __import__ then to delete each of them from sys.modules and re-import.  They probably could've just reload'ed them, though.", "abstract": ""}, {"id": 685040, "score": 6, "vote": 0, "content": "Not sure if this does all expected things, but you can do just like that:", "abstract": ""}, {"id": 685004, "score": 9, "vote": 0, "content": "Basically reload as in allyourcode's asnwer. But it won't change underlying the code of already instantiated object or referenced functions. Extending from his answer:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/46507961/changes-in-python-module-is-not-working", "keywords": [], "tags": ["python", "module", "anaconda", "python-3.6"], "question": {"id": 46507961, "title": "Changes in python module is not working?", "content": "I have two python files, one is calling (importing) the other. But when I make a change in the module which is called, change is not applied unless I quit from Python and re-open it. Then I can see that changes are working. Here is a short example: mainfile.py: otherfile.py: when I run mainfile.py, it prints 8 as expected. But when I change the last line in otherfile.py to print(x+4), and save it, running mainfile.py still prints 8! After quitting from Python and re-enter it, now it prints 9. I googled this issue but couldn't find anything. Some people talks about \"init\", I have no idea what it is. I am very new to Python, so I appreciate if you explain this in a very basic way. Thanks! Note: I am using Python 3.6.1 on Anaconda 4.4.0 with Spyder 3.1.4", "abstract": ""}, "answers": []}]