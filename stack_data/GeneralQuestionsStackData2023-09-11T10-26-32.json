[{"link": "https://stackoverflow.com/questions/25385173/what-is-a-debugger-and-how-can-it-help-me-diagnose-problems", "keywords": [], "tags": ["debugging", "language-agnostic"], "question": {"id": 25385173, "title": "What is a debugger and how can it help me diagnose problems?", "content": "This is intended to be a general-purpose question to assist new programmers who have a problem with a program, but who do not know how to use a debugger to diagnose the cause of the problem. This question covers three classes of more specific question:", "abstract": ""}, "answers": [{"id": 76841042, "score": 0, "vote": 0, "content": "By Definition: A debugger is a software application that allows programmers to inspect the state of a program while it is running, enabling them to understand its behavior and track down errors and bugs. Debugging is an essential part of the software development process\nbecause Let's dive into each of the scenarios mentioned in your question to understand how a debugger can help in each case: 1- Program Output Mismatch: When you run your program and the output does not match your expectations for a given input, a debugger can help you investigate the root cause. The debugger allows you to pause the program's execution at specific points, known as breakpoints, and inspect the program's state, including variable values, function call stack, and more. By examining the variables and their values, you can identify where the program deviates from the expected behavior. This process is particularly helpful when dealing with complex conditions or loops that may cause unexpected results. 2- Crashes and Stack Traces: When a program crashes and produces a stack trace, it indicates that an unhandled exception or error has occurred. The stack trace provides information about the sequence of function calls that led to the crash but may not directly reveal the exact cause of the issue. A debugger helps by allowing you to attach to the program when it crashes, examine the stack trace in real-time, and interactively step through the code to find the point where the crashing occurs. By observing the variable values and the program's state at that specific moment, you gain insights into what went wrong and identify potential null pointers, memory corruption, or other lot more issues that led to the crash. 3- Segmentation Fault (SEGV): A segmentation fault occurs when a program attempts to access a restricted memory region, often due to null pointers or accessing an invalid memory location. Debugging segmentation faults can be particularly challenging without a debugger. A debugger assists in locating the exact line of code that triggered the segmentation fault and provides insights into the memory addresses being accessed. It allows you to inspect the memory at the faulting address and nearby locations, helping you understand what caused the memory violation. - Stepping through Code: As Debuggers allow you to step through your code line-by-line, executing it one step at a time. This feature helps you understand the program's flow and behavior more effectively. - Variable Inspection: You can also inspect the values of variables at any point during program execution. This ability allows you to identify when variables are not holding the expected values, helping you track down logic errors. - Conditional Breakpoints: You can also set breakpoints that trigger only when specific conditions are met. This functionality is useful when you want to investigate specific situations or iterations in loops. - Watchpoints: The Watchpoints let you monitor the value of a variable and stop the program's execution when that value changes. This feature is valuable for tracking changes to critical variables in large codebases. - Backtrace and Call Stack: A debugger can display the call stack, showing the sequence of function calls that led to the current point of execution. This information is immensely helpful in understanding how the program reached its current state. - Memory Inspection: Debuggers allow you to inspect memory contents, which can be crucial for understanding and fixing issues related to data corruption or pointer manipulation. Overall, using a debugger is an essential skill for any programmer. It helps you identify and resolve issues efficiently, leading to more robust and reliable software. Familiarizing yourself with the debugger relevant to your programming language and environment is highly recommended. Common debuggers include: Invest your time in debugging: because it will improve your ability to diagnose and fix problems in your code, ultimately making you a more proficient and confident programmer. Hope it helps.", "abstract": ""}, {"id": 25385174, "score": 102, "vote": 0, "content": "A debugger is a program that can examine the state of your program while your program is running. The technical means it uses for doing this are not necessary for understanding the basics of using a debugger. You can use a debugger to halt the execution of your program when it reaches a particular place in your code, and then examine the values of the variables in the program. You can use a debugger to run your program very slowly, one line of code at a time (called single stepping), while you examine the values of its variables. A debugger is a very powerful tool for helping diagnose problems with programs.  And debuggers are available for all practical programming languages. Therefore, being able to use a debugger is considered a basic skill of any professional or enthusiast programmer. And using a debugger yourself is considered basic work you should do yourself before asking others for help. As this site is for professional and enthusiast programmers, and not a help desk or mentoring site, if you have a question about a problem with a specific program, but have not used a debugger, your question is very likely to be closed and downvoted. If you persist with questions like that, you will eventually be blocked from posting more. By using a debugger you can discover whether a variable has the wrong value, and where in your program its value changed to the wrong value. Using single stepping you can also discover whether the control flow is as you expect. For example, whether an if branch executed when you expect it ought to be. The specifics of using a debugger depend on the debugger and, to a lesser degree, the programming language you are using. You can attach a debugger to a process already running your program. You might do it if your program is stuck. In practice it is often easier to run your program under the control of a debugger from the very start. You indicate where your program should stop executing by indicating the source code file and line number of the line at which execution should stop, or by indicating the name of the method/function at which the program should stop (if you want to stop as soon as execution enters the method). The technical means that the debugger uses to cause your program to stop is called a breakpoint and this process is called setting a breakpoint. Most modern debuggers are part of an IDE and provide you with a convenient GUI for examining the source code and variables of your program, with a point-and-click interface for setting breakpoints, running your program, and single stepping it. Using a debugger can be very difficult unless your program executable or bytecode files include debugging symbol information and cross-references to your source code. You might have to compile (or recompile) your program slightly differently to ensure that information is present. If the compiler performs extensive optimizations, those cross-references can become confusing. You might therefore have to recompile your program with optimizations turned off.", "abstract": ""}, {"id": 29457171, "score": 66, "vote": 0, "content": "I want to add that a debugger isn't always the perfect solution, and shouldn't always be the go-to solution to debugging. Here are a few cases where a debugger might not work for you: In all of these cases, either having your program stop abruptly could cause the end results to differ, or stepping through manually in search of the one line where the bug is caused is too much of a hassle. This can equally happen whether your bug is incorrect behavior, or a crash. For instance, if memory corruption causes a crash, by the time the crash happens, it's too far from where the memory corruption first occurred, and no useful information is left. So, what are the alternatives? Simplest is simply logging and assertions. Add logs to your program at various points, and compare what you get with what you're expecting. For instance, see if the function where you think there's a bug is even called in the first place. See if the variables at the start of a method are what you think they are. Unlike breakpoints, it's okay for there to be many log lines in which nothing special happens. You can simply search through the log afterward. Once you hit a log line that's different from what you're expecting, add more in the same area. Narrow it down farther and farther, until it's small enough to be able to log every line in the bugged area. Assertions can be used to trap incorrect values as they occur, rather than once they have an effect visible to the end-user. The quicker you catch an incorrect value, the closer you are to the line that produced it. Refactor and unit test. If your program is too big, it might be worthwhile to test it one class or one function at a time. Give it inputs, and look at the outputs, and see which are not as you're expecting. Being able to narrow down a bug from an entire program to a single function can make a huge difference in debugging time. In case of memory leaks or memory stomping, use appropriate tools that are able to analyze and detect these at runtime. Being able to detect where the actual corruption occurs is the first step. After this, you can use logs to work your way back to where incorrect values were introduced. Remember that debugging is a process going backward. You have the end result - a bug - and find the cause, which preceded it. It's about working your way backward and, unfortunately, debuggers only step forwards. This is where good logging and postmortem analysis can give you much better results.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/7430123/debugging-python-code-in-notepad", "keywords": [], "tags": ["python", "debugging", "notepad++"], "question": {"id": 7430123, "title": "Debugging Python code in Notepad++", "content": "I use Notepad++ for writing and running Python scripts. It is a great text editor, except for debugging. Is there a way to step through the code, use break points, view variable values etc. in Notepad++ like you can in Visual Studio?", "abstract": ""}, "answers": [{"id": 75354980, "score": 0, "vote": 0, "content": "I know it's 11 years on, and I'm a bit late to the game, and I know it's not Notepad++ but please do consider Visual Studio Code. It's free, easy to install (both the editor itself plus any python interpreters it uses) and it's widely used and nowhere near as bloated as it's Visual Studio counterpart.  It also appears to be the IDE of choice for a lot of Cisco-related course material. Write your code, click to the left of code pane to insert your breakpoints click the Debugger icon (highlighted), and you're away: ", "abstract": ""}, {"id": 7433655, "score": 10, "vote": 0, "content": "Does such a plug-in exist?  Not that I know of.  I agree completely with qor72 on that note.   Is it possible to create such a plugin / functionality?  Possibly. After doing some quick digging, I did find a plugin that looks promising, Python Script.  In short it allows you to run python scripts that can access the NPP modules (file menus etc...) as well as the Scintilla Methods which appear to give access to things like the markers on the pages. To accomplish such a feat I could see the task being broken into a few large blocks (I feel a new open-source project coming on...)   Closing Thoughts\nWhile I think it's possible to create such a plug in, it would be quite an undertaking.  Along that line, you might be better off trying to find a different editor that has this built into it already and just create macros (or whatever the IDE calls them) to add in the things you like most about NPP.   Please note that I am a daily user of NPP and have been for many years so I definitely understand why you'd like to have the functionally added to NPP.  One of my favorite things about NPP is the speed in which it opens and searches files... moving to a bloated IDE, IMO, would not be worth it to me.   My current work flow is to do all of my editing in NPP and just double click to run the modules.  If it fails or goes off in the weeds, I launch IDLE to debug it.", "abstract": ""}, {"id": 10376549, "score": 2, "vote": 0, "content": "I don't really see why Shashi's answer hasn't been upvoted. For the link that he has given supplies a way to step through python scripts as the OP has requested. So for all who don't know about the pdb module, upon importing it the pdb.set_trace() function allows one to step through the area of code after it. And it is very much similar to the visual studios method of debugging. While you're stepping through the code you are able to input a variety of commands. One of them is p <expression> and that allows the user to print the current state of variables within the local and global scope. ", "abstract": ""}, {"id": 7430222, "score": 7, "vote": 0, "content": "I think python debugger\nis the best option if editor is not providing facility :) Quick guide: At the (Pdb) prompt, enter s to step, p foo to print foo, and c to continue executing the code until hitting another breakpoint.", "abstract": ""}, {"id": 7431347, "score": 2, "vote": 0, "content": "Have you thought of using Komodo.\nIt's open source and has ports for Windows, Linux and MAC (I think). This may be an alternative, and if you want some advice from notepad++ users, have a look at the following post on this very site: Komodo Edit and Notepad++ ::: Pros & Cons ::: Python dev Some npp users here seemed to have made the switch for python editing running etc... personally don't know much about debugging on Komodo but as it's an IDE so would be surprised if you couldn't do it easily", "abstract": ""}, {"id": 7430185, "score": 8, "vote": 0, "content": "I really hope someone tells me I'm wrong (I'd love to have that feature in Notepad++) but, Notepad++ is designed as a programmers editor, not an IDE. While it has a lot of cool functionality, that level of debugging isn't part of the core tool.  Not seeing anything in the npp-plugins either. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/69436238/fast-way-to-find-javascript-source-file-in-debugger", "keywords": [], "tags": ["google-chrome-devtools", "rstudio"], "question": {"id": 69436238, "title": "Fast way to find Javascript source file in debugger?", "content": "RStudio uses Chrome Devtools for debugging support in its Viewer pane.  (It is labelled as \"RStudio Devtools\", but I'm not sure to what extent it is customized besides that).  You can open its window using Right-click \"Inspect Element\". When developing a display that uses Javascript, the source pane in Devtools is very useful for setting breakpoints, single stepping, etc. One thing that is fairly inconvenient is finding the line where I want to set a breakpoint.  Once I have the source file open searching it is easy, but getting to the right source file is hard.  Typically after I go to the source pane, I see something like this:  I know the name of the file I want to debug, but it's buried several levels below index.html in the list of files on the left.  Is there a way to quickly search this hierarchy of files for a filename, so that I don't need to open all the levels down to the file I want?  For example, I might want to debug htmlwidgets.js: ", "abstract": ""}, "answers": [{"id": 69441751, "score": 2, "vote": 0, "content": "You'll note in the \"sources\" pane that, if you have no open files, you'll see a message in the middle that indicates you can type Command + P (or Ctrl + P on Windows/Linux) to open a file.  When clicked, this will open a text box that will fuzzy search across the names of all source files.  Type the filename there and it should be in the first results.  You can navigate to it with the keyboard and select it with <Enter>/<return>, or simply clicked with the mouse. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/7941988/why-single-stepping-instruction-on-x86", "keywords": [], "tags": ["debugging", "gdb", "x86"], "question": {"id": 7941988, "title": "Why Single Stepping Instruction on X86?", "content": "So there is \"int 3\" which is an interrupt instruction used for breakpoints in debuggers. But then there is also \"int 1\" which is used for single stepping. But why is this needed? I've read that setting the Trap Flag (TF) in EFLAGS register will enable single stepping and will trap into the OS for each instruction. So why is a separate interrupt type needed? Thanks!", "abstract": ""}, "answers": [{"id": 55806185, "score": 1, "vote": 0, "content": "Below are some quote from the Intel Software Developer Manual Vol. 3B, Chapter 17: Intel 64 and IA-32 architectures provide debug facilities for use in debugging code and monitoring performance. The Intel 64 and IA-32 architectures dedicate two interrupt\nvectors to handling debug exceptions: vector 1 (debug exception,\n#DB) and vector 3 (breakpoint exception, #BP). Both Debug Exception (#DB) and Breakpoint Instruction (triggeres #BP) are among such facilities. And both of them are meant for: ...transfers program control to a debug procedure or task... Debug Exception (#DB) relies on the several debug registers (DR0~DR7). While the breakpoint instruction (#BP) is: ... an alternative way to set code breakpoints....especially useful when more than four breakpoints are desired, or when breakpoints are being placed in the source code. The breakpoint instruction doesn't have as much power as the debug exception which is backed by DR0~DR7. Breakpoint instruction cannot be placed in ROM code. But and debug exception can be generated for ROM code as long as the DR0-DR7 are properly configured. For the debug exception: The debug-exception handler is usually a debugger program or part of a\nlarger software system. The processor generates a debug exception for\nany of several conditions. The debugger checks flags in the DR6 and DR7 registers to determine which condition caused the exception\nand which other conditions might apply. The conditions that may trigger a debug-exception can be many. Such as by setting EFLAGS[TF] the single-step debug-exception will be triggered.\nBy checking the DR6 (debug status register) and configuring the DR7 (debug control register), a Debug Exception handler can get the details of how a debug exception is triggered. For the breakpoint exception: The breakpoint exception (interrupt 3) is caused by execution of an\nINT 3 instruction. Debuggers use breakpoint exceptions ... as a\nmechanism for suspending program execution to examine registers and\nmemory locations. With the Intel386 and later IA-32 processors, it is more convenient to\nset breakpoints with the breakpoint-address registers (DR0 through\nDR3). However, the breakpoint exception still is useful for\nbreakpointing debuggers, because a breakpoint exception can call a\nseparate exception handler. The breakpoint exception is also useful\nwhen it is necessary to set more breakpoints than there are debug\nregisters or when breakpoints are being placed in the source code of a\nprogram under development. So we can see, breakpoint exception enables you to suspend the program execution, while the debug exception checks for several conditions and treat them differently. Only after you break at some location, you can then configure the processor for single-step or other things. You can configure the debug registers to specify the condition (such as code, memory or I/O locations, etc.) you want to break into, which will trigger #DB. Or place the breakpoint instruction in the code where you want to break into, which will trigger #BP. INT 3 is a single-byte op-code. So it can over-write any existing instruction with controllable side-effect to break into the execution of current program flow. Without it, how could you have the chance to set the single-step flag in EFLAGS at an appropriate time with no side-effect? So it is a two-step break-and-then-debug mechanism. The whole flow is: First, wire a debugger as the handler to both int 1(#DB) and int 3(#BP). Then put int3 to where you want to break in. Then debugger has the chance to step in. Once debugger starts to handle the int3 (#BP), if you want single-stepping, tell the debugger to set the Trap Flag (TF) in EFLAGS. Then CPU will generate a int 1 (#DB) after each single instruction. Since debugger is also wired to int 1 (#DB), it will have a chance to step in, too. (I discussed with one of my friends about how debugger works. He wrote a debugger before.) It seems the INT 3 (#BP) is the most important one. You can explicitly place an INT 3 instruction at the location you want to break into. Or you can let the debugger to do that for you. Once the INT 3 is hit, CPU will save the context of the broken program and switch to the INT 3 handler, which is usually part of the debugger. Now, the broken program is suspended because the execution is in the exception #3 handler now. The debugger is just a normal Windows or whatever desktop application. It can use the normal desktop message-loop to wait for user's commands to decide how to treat the program being debugged. So it seems both the debugee and the debugger are waiting now. But the reasons are very different. Then programmer (the human) can instruct the debugger (the software) to examine the saved context of the debugee. Or just restore debugee's saved context and let it resume. Or it may set the TF flag in EFLAGS so that a #DB will be generated by the processor after each instruction. But often, users may not want single-stepping at the instruction level. They may want to debug at the C statements level, which can be composed of many instructions. So the debugger can use the debug information, such as the PDB file, to find the location info. If users want to single-step at the C statement level, the debugger can find the beginning instruction of next C statement and rewrite the 1st byte of it with an INT 3. And then everything starts all over again. It's just a delicate cooperation between human, the debugger software and the processor. A related thread: Strange memory content display in Visual Studio debug mode", "abstract": ""}, {"id": 36154270, "score": 3, "vote": 0, "content": "int 3 is used to set a breakpoint so that the code can execute freely until a particular point (the breakpoint) is reached. this speeds up the debugging process so it is not necessary to trap through known good code. int 1 is used to unconditionally halt after every instruction. this can be handy when conditional branch instructions are executed and the condition of the status flags is not known. otherwise, a breakpoint would need to be set at branch address and the address of the instruction following the branch. int 1 is can also be used at board bring-up when both the board hardware and the bring-up are new and untested.", "abstract": ""}, {"id": 7943860, "score": 3, "vote": 0, "content": "Others have already explained the distinction between the interrupt vector 1 and int 3 instruction. Now, if you wonder why there're multiple interrupt vectors involved in handling of debug interrupts, I think it's just because the original 8086/8088 circuitry was intended to be relatively simple and to execute relatively simple software. It had very few special interrupt vectors and the int vector 1 was only used for the single-step trap and distinguishing it from the breakpoint trap was trivial, by the interrupt vector number, that is, it was sufficient to just have distinct handlers for the vector 1 and 3. That design was carried over to the x86 CPUs that followed. The newer CPUs substantially and \"quickly\" extended the set of the special interrupt vectors up to about 20 to handle new exceptions and extended the debugging functionality adding several other useful interrupt vector 1 triggers on top of the original single-step trap (e.g. instruction fetch, memory/port I/O, task switch, etc). It was logical to house most of them under the same interrupt vector since they're related and not consume more vectors.", "abstract": ""}, {"id": 7942057, "score": 8, "vote": 0, "content": "You are confusing the INT and INT 3 instructions with the interrupt vectors through which those instructions would call if the instruction were invoked. There is no single-step instruction.  The INT 3 (or \"breakpoint instruction\") will call the debugger if it is present (or rather, the debugger will hook the INT 3 vector so that when an INT 3 happens, the debugger will be called). If the debugger sets the TF (trace flag), then every instruction will cause the #1 interrupt to occur. This will cause whatever address is in that interrupt vector to be called. Hopefully, this will be the single-step routine of a debugger. Eventually, the debugger will clear the TF, causing single-step interrupts to cease.", "abstract": ""}, {"id": 7942117, "score": 12, "vote": 0, "content": "int 3 is a special 1-byte interrupt. Invoking it will break into the debugger if one is present, otherwise the application will typically crash. When the debugger sets the trap flag, this causes the processor to automatically execute an int 1 interrupt after every instruction. This allows the debugger to single-step by instructions, without having to insert an int 3 instruction. You do not have to invoke this interrupt explicitly.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65492779/how-to-track-a-flow-of-a-c-program", "keywords": [], "tags": ["c", "testing", "program-flow"], "question": {"id": 65492779, "title": "How to track a flow of a c program?", "content": "I'ts more of a general question: how to handle the execution path of a c program, which consist of multiple functions?\nFor example, i have a following c program: Currently i'm using something like this to see where did my function go in if statements: How can I keep it simple and more universal?;)\nPutting printf in every if-else pair seems unreasonably bulky...", "abstract": ""}, "answers": [{"id": 65492974, "score": 0, "vote": 0, "content": "There is nothing wrong using printf statements to track or log program flow for the purpose of learning, or testing during development.  But a good debugger will probably serve the purpose just as well without having to add in-line code.\nDepending on your environment there is a large list of debugger options available. Following is an overview of debugging programs: A debugger is a program that allows you to step through another\nprogram one line at a time. This is very useful when trying to\nidentify incorrect code and analyze how a program \"flows\". Key\nconcepts include: Breakpoints, Stepping, and Viewing data. Key things that you can use the debugger to determine are: Much more detail here", "abstract": ""}, {"id": 65493024, "score": 0, "vote": 0, "content": "If you are using an IDE for purpose of writing code then it would have built-in facilities for debuggers, the only thing you would need to do is set break-points and then when the program is run your code would pause whenever a break-point is hit. IDEs also provide facilities to look up variable values at that instant. If you are not using an IDE and your question is specifically w.r.t C you could consider using GDB. Have a look here to get a better idea of how to use GDB to debug programs.", "abstract": ""}, {"id": 65492988, "score": 0, "vote": 0, "content": "This is usually a job for a debugger, most of which allow to step through the code one statement at a time.  They also allow you to set breakpoints to pause execution at specific locations, watchpoints that pause execution when a variable changes, etc. Without knowing your environment I can\u2019t recommend a specific debugger to use.  If you\u2019re building code with gcc, then the companion debugger is (usually) gdb.  You will need to use the -g flag when compiling to enable source-code level debugging.  It\u2019s not the friendliest debugger to use, but it\u2019s pretty comprehensive.  If you\u2019re building in the Visual Studio environment on Windows, there should be a debugger as part of the IDE.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55621838/hardware-breakpoints-vs-software-breakpoints-in-embedded-systems", "keywords": [], "tags": ["debugging", "embedded", "interrupt", "breakpoints", "jtag"], "question": {"id": 55621838, "title": "Hardware breakpoints vs Software breakpoints in embedded systems", "content": "My understanding is that inserting software breakpoints involves replacing the next instruction in code to be executed by a software interrupt instruction which will cause the CPU to halt when it reaches that instruction.  Hardware breakpoints involve putting the address of the next instruction after the breakpoint to be executed into a register and when the addresses match, via the use of a hardware comparator, this then causes the CPU to halt (Correct me if i'm wrong). What i'm confused about is, do we only use hardware breakpoints when using a hardware debugger to debug a board via JTAG for example? Or can JTAG use software breakpoints also?  Is GDB only used with software breakpoints, or can it be used also in conjunction with JTAG? Sorry if the question is a bit broad.", "abstract": ""}, "answers": [{"id": 55867982, "score": 8, "vote": 0, "content": "In the context of this article, let's agree on a unified definition of a breakpoint. The breakpoints discussed here are Program locations where we want the processor to halt so that we can do some sort of debugging. There could be other types of breakpoints, such as ones that are triggered by a data access, but in this article, we will discuss only Program Breakpoints, locations in our application code where we want to halt every time that code is encountered.  What's the difference between a hardware and a software breakpoint? Well, the obvious answer is \"A hardware breakpoint is implemented in hardware\" and \"A software breakpoint is implemented in software\". But what exactly does that mean, and what are the ramifications of it? Why would I choose one over the other?  A Hardware Breakpoint is really implemented by special logic that is integrated into the device. You can think of a hardware breakpoint as a set of programmable comparators that are connected to the program address bus. These comparators are programmed with a specific address value. When the code is executing, and all of the bits in the address on the program address bus match the bits programmed into the comparators, the Hardware breakpoint logic generates a signal to the CPU to Halt. \nThe advantage of using a hardware breakpoint is that it can be used in any type of memory. This might make more sense after Software breakpoints are discussed. When we discuss software breakpoints, we will find that they are only usable in Volatile memory. Hardware Breakpoints can be used regardless of whether the code being executed is in RAM or ROM, because to the hardware breakpoint logic, there is no difference. It's just matching an address on the PAB and halting the CPU when it finds one. \nThe disadvantage of the HWBP is, because they are implemented in hardware, there are a limited number available. The number of HWBPs available differ from architecture to architecture, but in most cases there are only 2-8 available. The simplest way to figure out how many a device has is to connect to it in CCS and keep setting HWBPs until you get an error message that there are none available.  As mentioned, a Software Breakpoint is implemented in software. But how is that done? There are actually a 2 different implementations. \nSome devices reserve a specified bit in their opcode definition that indicates a Software breakpoint. As an example, in one architecture of the C6000 family, all instructions are 32 bits long, and bit 28 is reserved to indicate a software breakpoint, so all instructions in that instruction set have bit 28 as a zero. In this case, when a software breakpoint is set in CCS, it will actually modify the opcode of the instruction at that location and set bit 28 to a 1. The Emulation logic then monitors the Program Opcode for whenever bit 28 is a 1, and halts the CPU when that occurs. Note that this is a minority case. Most architectures don't do it this way. The reason is that it limits the flexibility of the instruction set. Also, it doesn't work for architectures that have variable length instructions, so it also limits code density. \nThe more popular way of implementing a software breakpoint is also much more complex. In this scenario, there is a specified breakpoint opcode. Typically, the opcode is 8-bits. Whenever a breakpoint is set, the leading 8 bits of the instruction at that location are removed and replaced with this 8-bit breakpoint opcode. The original 8-bits of the instruction are then stored in a breakpoint table. Whenever a breakpoint is encountered, the CPU halts and CCS replaces the breakpoint opcode with the original 8-bits of the instruction. When execution is restarted, CCS must do a bit of trickery because the instruction in the actual CPU pipeline isn't correct. It still has the breakpoint opcode. So CCS flushes the CPU pipeline and then re-fetches the instructions that were pending in them to their original state, with the next function to be executed being the one where the breakpoint was set. At the same time, CCS re-loads the instruction at that location with the breakpoint opcode so that the next time this code is encountered, it will again halt. \nThe advantage of the SWBP is that there is an unlimited number of them, so you can put them in as many places as you like. The disadvantage is that you can't put them in non-volatile memory like ROM/FLASH, etc, because CCS can't write the opcode to the location. http://processors.wiki.ti.com/index.php/How_Do_Breakpoints_Work ", "abstract": ""}, {"id": 55622375, "score": 5, "vote": 0, "content": "\"correct me if I'm wrong\"   A breakpoint is set on the instruction, not after it - the break occurs before the instruction is executed, not after - otherwise setting a breakpoint on a jump, call or branch instruction would fail. \"do we only use hardware breakpoints when using a hardware debugger to debug a board via JTAG for example?\" JTAG is a simple communication interface to the on-chip debug (and is used for other purposes such as in-circuit memory and FPGA programming and boundary-scan for example).   While it may vary between architectures on ARM Cortex-M for example, you can access the on-chip debug registers from the target code and set hardware breakpoints.  Yoiu can also place software break points in your code using the BKPT instruction (as opposed to a SWI as you suggest). Or can JTAG use software breakpoints also? As I said, JTAG is just a communication interface to the on-chip debug, however through the on-chip debug, you can directly set any RAM content, so the JTAG connected debugger software running on the development host can temporarily modify code in RAM to set a software breakpoint (by replacing the target instruction with a BKPT, then when the breakpoint is hit, reverting back to the original instruction so it can be executed.  Software breakpoints are not so straightforward for code running from ROM, though some debuggers support unlimited ROM breakpoints (for a price) - the manufacturers of such hardware do not necessarily publicise the methods they use to do that. Before JTAG and on-chip debug became widely available on evebnlow-end parts, technologies such as In-Circuit Emulation and ROM emulators were used.  These were generally expensive and complex solutions. Is GDB only used with software breakpoints, or can it be used also in conjunction with JTAG?  GDB can be used in a number of ways.  It requires a \"debug stub\" - a software layer mapping the debugger software to the available hardware - the nature of which will depend on the debug interface and target device used.  When using a UART or Ethernet port for example, the stub is actually code running on the target itself (such as Linux's gdbserver).  In that case it is less reliable since software errors may prevent the debug port driver from actually running especially in targets lacking MMU protection.  Simpler JTAG devices interface with GDB through a stub running on the development host, for example the commonly used OpenOCD software.  More expensive JTAG debug hardware may run the stub on the JTAG hardware itself - such as Abatron's bdi2000 for example.   Either way the debug stub will be able to use hardware and software breakpoints depending on the target capabilities. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16492509/does-any-golang-interactive-debugger-exist", "keywords": [], "tags": ["debugging", "go"], "question": {"id": 16492509, "title": "Does any golang interactive debugger exist?", "content": "The title pretty much sums it up. I am trying out Go and I really miss being able to set breakpoints and step in/over/out as much as I want within an interactive environment. I know I can use gdb to debug Go but that is quite annoying compared to using an IDE that can plug into gdb for breakpointing. I tried searching for one and could only find plugins or small IDEs that have syntax highlighting but no debugging.", "abstract": ""}, "answers": [{"id": 43219667, "score": 0, "vote": 0, "content": "I've been pretty happy with Gogland (https://www.jetbrains.com/go/) which is basically Intellij with Go support. It's got a working Debugger that keeps getting better as they've been developing this. I've been using it since Jan 2017 and it's been mostly stable for me on a 2016 MBP. Goland is the codename for a new commercial IDE by JetBrains aimed at\n  providing an ergonomic environment for Go development.", "abstract": ""}, {"id": 29242504, "score": 24, "vote": 0, "content": "Update 2017: the godebug project mentions below is now official replaced by derekparker/delve. Original answer: You now (March 2015) have another approach, based on instrumenting the code.  mailgun/godebug: godebug uses source code generation to instrument your program with debugging calls.\ngo tool cover takes a similar approach to code coverage.  Coming later: evaluate arbitrary Go expressions and write to variables. Update June 2015: While it might not be as interactive as \"some\" might hope, it is still appreciated (and has \"step into\" feature).\nSee \"Go has a debugger\u2014and it's awesome!\" (Cloudfare) here's the cool bit: instead of wrestling with half a dozen different ptrace interfaces that would not be portable, godebug rewrites your source code and injects function calls like godebug.Line on every line, godebug.Declare at every variable declaration, and godebug.SetTrace for breakpoints (i.e. wherever you type _ = \"breakpoint\"). I find this solution brilliant.\nWhat you get out of it is a (possibly cross-compiled) debug-enabled binary that you can drop on a staging server just like you would with a regular binary.  When a breakpoint is reached, the program will stop inline and wait for you on stdin.  It's the single-binary, zero-dependencies philosophy of Go that we love applied to debugging. Builds everywhere, runs everywhere, with no need for tools or permissions on the server. Debugging is just a make bin/rrdns GODEBUG=rrdns/... away.", "abstract": ""}, {"id": 34476952, "score": 9, "vote": 0, "content": "EDIT The GO debugger is now a simple plugin in IntelliJ or PyCharm, no need\n  to install anything else. Just look for the Go plugin in the plugin\n  preferences. Original answer (Nov 2015) for those looking for the latest as of end of Nov 2015: get delve  and follow the build / setup instructions: Get the latest IntelliJ (15) or PyCharm (5) and get the go-lang-plugin in the IDE of your choice: Define you package or file to run. Once done with the setup, the Play icon and Debug icon should now be active, and you can set breakpoint, watches etc... as usual. Cheers", "abstract": ""}, {"id": 38471807, "score": 8, "vote": 0, "content": "Option one - GDB https://golang.org/doc/gdb Delve Visual Studio Code with its go plugin (still uses delve). I personally use option 3. For it you will need to have delve installed. This video shows the debugging in action: https://youtu.be/uBjoTxosSys?t=16m11s (the entire video is very interesting).", "abstract": ""}, {"id": 27725999, "score": 15, "vote": 0, "content": "UPDATE: I have checked it out and am happy to report that Version: 2016.1.3, Build: 145.1617.8, Released: June 5, 2016 works with Delve!  You can download it here: https://www.jetbrains.com/idea/download/.  Also follow the Delve install instructions here: https://github.com/derekparker/delve/tree/master/Documentation/installation It's a bit flaky.  Just after I got the OSX login prompt the interactive debugging started working.  Sometimes, I have to debug a simple .go program to kick start it.  But it does work and is the best interactive debugging experience for Go that I've seen. ORIGINAL POST:  Does any golang interactive debugger exist?\nYes. Does any golang interactive debugger, that is worth using, exist?\nNo. Configuring GDB on the mac is tedious, but doable. However, once you start using it you'll soon realize that you just wasted your time installing it. You can even configure IntelliJ to use it. The only value that IntelliJ, LiteIDE, CGDB, etc. seem to provide is that you can more quickly ascertain that GDB debugging support for Go is extremely poor.  You can use it to step through some Go code, but try to print the value of anything other than very simple variable values and you'll be wasting your time wishing for a decent debugger.  Here's an example of what happens when you try to print the value of a map[string]string data structure using CGDB: ...which is completely useless. Next, try this: ...and you'll get \"Bus error\". Delve (https://github.com/derekparker/delve) looks promising, since it is written in Go, but you drive it using the console, not via an IDE. I would gladly pay for the enterprise version of IntelliJ (or any other IDE) that did a decent job supporting interactive debugging in Go. As of now, fmt.Printf(\"%v\", variable) is about as good as it gets.", "abstract": ""}, {"id": 33345169, "score": 7, "vote": 0, "content": "IDE DEBUG ON GO IS POSSIBLE (AGAIN), ACTUALLY WORKS! Delve works rather well on Mac OS X and is supported by IntelliJ IDEA Go Lang plugin. I tested that on Mac OSX, IntelliJ Idea 14, Go 1.5.1, Delve 0.5 I had to run thru the usual loops of creating a self-signed cert, adding it to the system ring, etc (required in order to run a debugger in Mac OS X).\nAt the end, I set a GO project inside IntelliJ and was repaid in regaining the usual IDE+debugger features: setting breakpoints, inspecting variables, single stepping. That's way better than printing out values in order to debug code.", "abstract": ""}, {"id": 16492524, "score": 37, "vote": 0, "content": "Update: Personally, while GDB works I'm not a fan of using it in Go and it will make you spit some blood. Check out some of the other answers for good alternatives.  Yes, of course :) Go has a debugger (GDB) Here is the official tutorial on how to use it. If you'd like 'graphical debugging' (that is, setting breakpoints in the editor) some IDEs let you do that (with GDB in the background). In specific, Eclipse, LiteIDE and Zeus all let you set breakpoints and debug from your coding environment (source). Here is a video on how to do it with Zeus.", "abstract": ""}, {"id": 23387017, "score": 28, "vote": 0, "content": "GDB support for go has lots of issues that won't be fixed by the go team. For more information, read the post by Rob Pike: Although we will endeavor to keep basic gdb functionality (stack\n  traces, printing values) working on supported platforms, the ability\n  to use the debugger to understand a Go program's full environment will\n  likely never work, and improving gdb support is not a priority for the\n  team.  They are looking for other debugging options but have no concrete plans by now.\nThe documentation is outdated and the runtime-gdb.pyscript coming with go 1.2\ndoes not work for a GDB that was compiled with python3 support (current Ubuntu for example).", "abstract": ""}, {"id": 22780617, "score": 8, "vote": 0, "content": "I am happily using CGDB, a little curses wrapper around GDB.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/41135561/how-does-adding-a-run-time-breakpoint-in-visual-studio-work", "keywords": [], "tags": ["visual-studio", "debugging", "x86", "breakpoints"], "question": {"id": 41135561, "title": "How does adding a run-time breakpoint in Visual Studio work?", "content": "When I add a breakpoint to some C# code during run-time, it gets hit. How does this actually happen? I want to say that when running in debug mode, Visual Studio has references for code blocks, and when a breakpoint is added during run-time, it would be activated once that reference is called in the compiled code.  Is that a correct assumption? If so, can you please provide more details about how that works? ", "abstract": ""}, "answers": [{"id": 41179799, "score": 27, "vote": 0, "content": "This is actually a rather large and complicated topic, and it is also architecture-specific, so I'll only aim in this answer to provide a summary of the common approaches on the Intel (and compatible) x86 microarchitecture. The good news is, it is language-independent, so the debugger is going to work the same way whether it's debugging VB.NET, C#, or C++ code. The reason why this is true is that all code is ultimately going to compile (whether statically [i.e., ahead-of-time like C++ or with a JIT compiler like .NET]) or dynamically [e.g., via a run-time interpreter]) to object code that can be natively executed by the processor. It is this native code that the debugger ultimately works on. Furthermore, this isn't limited to Visual Studio. Its debugger certainly works in the way that I'll describe, but so does any other Windows debugger, like the Debugging Tools for Windows debuggers (WinDbg, KD, CDB, NTSD, etc.), GNU's GDB, IDA's debugger, the open-source x64dbg, and so on. Let's start with a simple definition\u2014what is a breakpoint? It's just a mechanism that allows execution to be paused so that you can conduct further analysis, whether that's examining the call stack, printing the values of variables, modifying the contents of memory or registers, or even modifying the code itself. On the x86 architecture, there are several fundamental ways that breakpoints can be implemented. They can be divided into the two general categories of software breakpoints and hardware breakpoints. Although a software breakpoint uses features of the processor itself, it is primarily implemented within software, hence the name. Specifically, interrupt #3 (the assembly language instruction INT 3) provides a breakpoint interrupt. This can be placed anywhere in the executable code, and when the CPU hits this instruction during execution, it will trap. The debugger can then catch this trap and do whatever it wants to do. If the program is not running under a debugger, then the operating system will handle the trap; the OS's default handler will simply terminate the program. There are two possible encodings for the INT 3 instruction. Perhaps the most logical encoding is 0xCD 0x03, where 0xCD means INT and 0x03 specifies the \"argument\", or the number of the interrupt that is to be triggered. However, because breakpoints are so important, the designers at Intel also added a special-case representation for INT 3\u2014the single-byte opcode 0xCC. The nice thing about this being a one-byte instruction is that it can be inserted pretty much anywhere in a program without much difficulty. Conceptually, this is simple, but the way it actually works is somewhat tricky. Basically, there are two options: If it's a fixed breakpoint, then the debugger can insert this INT instruction into the code when it is compiled. Then, every time you hit that point, it will execute that instruction and break. In C/C++, a fixed breakpoint might be inserted via a call to the DebugBreak API function, with the __debugbreak intrinsic, or using inline assembly to insert an INT 3 instruction. In .NET code, you would use System.Diagnostics.Debugger.Break to emit a fixed breakpoint. At runtime, a fixed breakpoint can be easily removed by replacing the one-byte INT instruction (0xCC) with a one-byte NOP instruction (0x90). NOP is the mnemonic for no-op: it just causes the processor to waste a cycle without doing anything. But if it's a dynamic breakpoint, then things get more complicated. The debugger must modify the binary in-memory and insert the INT instruction. But where is it going to insert it? Even in a debugging build, a compiler cannot reasonably insert a NOP between every single instruction, and it doesn't know in advance where you might want to insert a breakpoint, so there won't be space to insert even a one-byte INT instruction at an arbitrary location in the code. So what it does instead is insert the INT instruction (0xCC) at the requested location, writing over whatever instruction is currently there. If this is a one-byte instruction (such as an INC), then it is simply replaced by an INT. If this is a multi-byte instruction (most of them are), then only the first byte of that instruction is replaced by 0xCC. The original instruction then becomes invalid because it's been partially overwritten. But that's okay, because once the processor hits the INT instruction, it will trap and stop executing at precisely that point. The partial, corrupted, original instruction will not be hit. Once the debugger catches the trap triggered by the INT instruction and \"breaks\" in, it undoes the in-memory modification, replacing the inserted 0xCC byte with the correct byte representation for the original instruction. That way, when you resume execution from that point, the code is correct and you don't hit the same breakpoint over and over. Note that all of this modification happens to the current image of the binary executable stored in memory; it is patched directly in memory, without ever modifying the file on disk. (This is done using the ReadProcessMemory and WriteProcessMemory API functions, specifically designed for debuggers.) Here it is in machine code, showing both the raw bytes as well as the assembly-language mnemonics: If we were to set a breakpoint on the line of source code that added the values (the ADD instruction in the disassembly), the first byte of the ADD instruction (0x01) would be replaced with 0xCC, leaving the remaining bytes as meaningless garbage: Hopefully you were able to follow all of that, because that is actually the simplest case. Software breakpoints are what you use most of the time. Many of the most commonly used features of a debugger are implemented using software breakpoints, including stepping over a call, executing all code up to a particular point, and running to the end of a function. Behind the scenes, all of these use a temporary software breakpoint that is automatically removed the first time that it is hit. However, there is a more complicated and more powerful way to set a breakpoint with the direct assistance of the processor. These are known as hardware breakpoints. The x86 instruction set provides 6 special debug registers. (They are referred to as DB0 through DB7, suggesting a total of 8, but DR4 and DR5 are the same as DR6 and DR7, so there are actually only 6.) The first 4 debug registers (DR0 through DR3) store either a memory address or an I/O location, whose values can be set using a special form of the MOV instruction. DR6 (equivalent to DR4) is a status register that contains flags, and DR7 (equivalent to DR5) is a control register. When the control register is set accordingly, an attempt by the processor to access one of these four locations will cause a hardware breakpoint (specifically, an INT 1 interrupt will be raised), which can then be caught by a debugger. Again, the details are complicated and can be found various places online or in Intel's technical manuals, but not necessary to gain a high-level understanding. The nice thing about these special debug registers is that they provide a way to implement data breakpoints without needing to modify the code! However, there are two serious limitations. First, there are only four possible locations, so without a lot of cleverness, you are limited to four breakpoints. Second, the debug registers are privileged resources, and instructions that access and manipulate them can be executed only at ring 0 (essentially, kernel mode). Attempts to read or write these registers at any other privilege level (such as in ring 3, which is effectively user mode) will cause a general protection fault. Therefore, the Visual Studio debugger has to jump through some hoops to use these. I believe that it first suspends the thread and then calls the SetThreadContext API function (which causes a switch to kernel mode internally) to manipulate the contents of the registers. Finally, it resumes the thread. These debug registers are very powerful for setting read/write breakpoints for memory locations that contain data, as well as for setting execute breakpoints for memory locations that contain code. However, if you need more than 4, or hit against some other limitation, then these hardware-provided debug registers won't work. The Visual Studio debugger has to have some other, more general way of implementing data breakpoints. This is, in fact, why having a large number of breakpoints can really slow down the execution of your program when running under the debugger. There are various tricks here, and I know a lot less about exactly which ones are used by the different closed-source debuggers. You could almost certainly find out by reverse-engineering or even closer observation, and perhaps there is someone that knows more about this than me. But I'll briefly summarize a couple of the tricks I know about: One trick for memory-access breakpoints is to use guard pages. This involves changing the protection level of the virtual-memory page that contains the data of interest to PAGE_GUARD, meaning that subsequent attempts to access that page (either read or write) will raise a guard page violation exception. The debugger can then catch this exception, verify that it occurred upon access to the memory address of interest, and process it as a breakpoint. Then, when you resume execution, the debugger arranges for the page access to succeed, resets the PAGE_GUARD flag again, and continues. This is how OllyDBG implements its support for memory-access breakpoints. I don't know if Visual Studio's debugger uses this trick or not. Another trick is to use single-stepping support. Basically, the debugger sets the Trap Flag (TF) in the x86 EFLAGS register. This causes the CPU to trap before executing each instruction (which it does by raising an INT 1 exception, just as we saw above when the debug registers are used). The debugger then catches this trap, and decides whether it should continue executing or not.  Finally, there are conditional breakpoints. This is where you can set a breakpoint on a line of code, but ask the debugger to only break there if a certain specified condition evaluates to true. These are extremely powerful, but, in my experience, only rarely used by developers. As far as I know, these are implemented under the hood as normal, unconditional breakpoints. When the breakpoint is hit, the debugger automatically evaluates the condition. If it is true, it \"breaks in\" for the user. If it is false, it continues execution just as if the breakpoint had never been hit. There is no hardware support for conditional breakpoints (beyond the data breakpoints support discussed above), and I am not aware of any lower-level support for conditional breakpoints (e.g., something provided by the operating system). This is, of course, why having complicated conditions attached to your breakpoints can significantly slow down the execution speed of your program! If you're interested in more details (as if this answer isn't already long enough!), you might check out Tarik Soulami's Inside Windows Debugging. It looks like it contains relevant information, although I haven't read it yet so I can't unabashedly recommend it. (It's on my Amazon wish list!)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/35688569/effects-of-debugger-on-embedded-application", "keywords": [], "tags": ["c", "debugging", "embedded", "stm32", "iar"], "question": {"id": 35688569, "title": "Effects of debugger on embedded application", "content": "I'm currently using IAR to debug an STM32f0 micro, and I've noticed some interesting effects on my device's functionality while attempting to debug when the unit is running.  It seems to me that the debugger is slowing down or inhibiting the application in some way, meaning some of the more time critical sections of the code are having trouble executing correctly.  What is the debugger doing to the code in order to allow me to look at the registers/variables/memory/position in source code, and how does this affect execution time? Note: optimisations are already turned off, as they tend to stuff up IAR's ability to step through code correctly and cause it to sometimes miss breakpoints. ", "abstract": ""}, "answers": [{"id": 35712280, "score": 2, "vote": 0, "content": "The ARM Cortex-M0 CoreSight on-chip debug unit used of the STM32F0xx is non-intrusive for normal execution.  Hardware breakpoints matched instruction-fetch addresses in real-time.  If your debugger supports update of memory content and variables while running (rather then at a breakpoint), that may conceivably have an effect, but on STM32F2xx with I have not seen any issues even with very time critical code with with microsecond scale deadlines (F2 is however Cortex-M3 not M0). Applying conditional breakpoints will slow execution considerably, if the breakpoint location is executed frequently since the processor must be stopped and the condition tested by the host. A common problem encountered when debugging that may catch the unwary is that when the processor stops on a break-point, the on-chop peripherals and timers continue to run, of then resulting in several interrupts pending when the processor is restarted often with undesirable effects depending on your applications ability to handle such abnormal timing gracefully.  The DBGMCU peripheral supports the ability to selectively stop specific timers and peripherals, and to support low-power modes without disconnecting the debugger.  You may need to use these features to improve your debug experience.", "abstract": ""}, {"id": 35693741, "score": 0, "vote": 0, "content": "What is the debugger doing to the code in order to allow me to look at\n  the registers/variables/memory/position in source code, and how does\n  this affect execution time? It depends on your debugger. In general, debuggers slow the application (application performance) whether it is run in emulator or on the device itself based on the level of intrusiveness. The breakpoints, single stepping can have huge impact on the timing of execution of application as they are intrusive. Also note that the intrusiveness due to these features in turn depends on the offering by the vendor. Normally, debuggers shall read the CPU registers and memory so that it can be displayed to the user, however this process shall consume memory/time in turn causing side effect.  Some debug techniques used by debuggers involve incorporation of additional information into the application code which in turn can increase the size of application which can effect the execution time. Such intrusive techniques can cause side effects due to this additional code. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/19564019/debugger-implementation-step-over-issue", "keywords": [], "tags": ["debugging", "breakpoints"], "question": {"id": 19564019, "title": "Debugger implementation - Step over issue", "content": "I am currently writing a debugger for a script virtual machine.\nThe compiler for the scripts generates debug information, such as function entry points, variable scopes, names, instruction to line mappings, etc. However, and have run into an issue with step-over. Right now, I have the following:\n1. Look up the current IP\n2. Get the source line from that\n3. Get the next (valid) source line\n4. Get the IP where the next valid source line starts\n5. Set a temporary breakpoint at that instruction or: if the next source line no longer belongs to the same function, set the temp  breakpoint at the next valid source line after return address. So far this works well. However, I seem to be having problems with jumps. For example, take the following code: Given this code, if I'm on line B and choose to step-over, the IP determined for the breakpoint will be on line C. If, however, the conditional jump evaluates to false, it should be placed on line D. Because of this, the step-over wouldn't halt at the expected location (or rather, it wouldn't halt at all). There seems to be little information on debugger implementation of this specific issue out there. However, I found this. While this is for a native debugger on Windows, the theory still holds true. It seems though that the author has not considered this issue, either, in section \"Implementing Step-Over\" as he says: Again: The debugger-thread locates next executable line and address (0x41141e), it places an IBP on that location. This statement does not seem to hold true in cases where jumps are involved, though. Has anyone encountered this problem before? If so, do you have any tips on how to tackle this?", "abstract": ""}, "answers": [{"id": 28948941, "score": 2, "vote": 0, "content": "Since this thread comes in Google first when searching for \"debugger implement step over\". I'll share my experiences regarding the x86 architecture. You start first by implementing step into: This is basically single stepping on the instructions and checking whether the line corresponding to the current EIP changes. (You use either the DIA SDK or the read the dwarf debug data to find out the current line for an EIP). In the case of step over: before single stepping to the next instruction, you'll need to check if the current instruction is a CALL instuction. If it's a CALL instruction then put a temporary breakpoint on the instruction following it and continue execution till the execution stops (then remove it). In this case you effectively stepped over function calls literally in the assembly level and so in the source too. No need to manage stack frames (unless you'll need to deal with single line recursive functions). This analogy can be applied to other architectures as well.", "abstract": ""}, {"id": 19647234, "score": 0, "vote": 0, "content": "Ok, so since this seems to be a bit of black magic, in this particular case the most intelligent thing was to enumerate the instruction where the next line starts (or the instruction stream ends + 1), and then run that many instructions before halting again. The only gotcha was that I have to keep track of the stack frame in case CALL is executed; those instructions should run without counting in case of step-over.", "abstract": ""}]}]