[{"link": "https://stackoverflow.com/questions/75749914/python-methods-calling-other-methods-from-another-class", "keywords": [], "tags": ["python", "function", "class"], "question": {"id": 75749914, "title": "Python methods calling other methods from another class", "content": "I might have a simple question for some of you but I couldnt find this exact topic in the forum. In this simple example I have two classes class mainTest() & class mainTest2(): Essentially I am trying to call the dosomething(self): method in the second class from the first class, but the issue that I am having is when the dosomething method is calling a secondary method from the second class, with the following error message: What I tried to do is instead of calling self.dosomethingelse(self) I called mainTest2.dosomethingelse(self) But I get the following error: I know this might be pretty obvious but Im just a beginner. Thanks in advance!", "abstract": ""}, "answers": [{"id": 75749974, "score": 1, "vote": 0, "content": "There's nothing wrong with your original definition of mainTest2; the definition of mainTest1 is doing something fundamentally wrong. In your first example, you are calling a function that expects an instance of mainTest2 with an argument of type mainTest. Instances of mainTest don't have the dosomethingelse method expected by dosomething. In the second example, you are just passing that same instance of mainTest that mainTest2.dosomething received and passing it to a different function that expects an argument of type mainTest2. Just as before, that argument is lacking an expected attribute, this time d instead of dosomethingelse. Instance methods are not intended to be invoked as regular functions with explicit instance arguments. They are intended to be invoked on the instance itself. It's hard to correct mainTest, because what it's doing is fundamentally wrong. You don't have an instance of mainTest2 available, so you have no business trying to call mainTest2.dosomethingelse.", "abstract": ""}, {"id": 75749965, "score": 0, "vote": 0, "content": "When you call t.runsomething(), that passes self to mainTest2.dosomething(self) however, that self is of type mainTest so when you run mainTest2.dosomething(self) and it calls self.dosomethingelse() the self here is what you passed in ie \"type of mainTest and that type has no method dosomethingelse()", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/3786881/what-is-a-method-in-python", "keywords": [], "tags": ["python", "methods"], "question": {"id": 3786881, "title": "What is a &quot;method&quot; in Python?", "content": "Can anyone, please, explain to me in very simple terms what a \"method\" is in Python? The thing is in many Python tutorials for beginners this word is used in such way as if the beginner already knew what a method is in the context of Python. While I am of course familiar with the general meaning of this word, I have no clue what this term means in Python. So, please, explain to me what the \"Pythonian\" method is all about. Some very simple example code would be very much appreciated as a picture is worth thousand words.", "abstract": ""}, "answers": [{"id": 74548037, "score": 0, "vote": 0, "content": "The python doc explains about a method as shown below: ... A method is a function that \u201cbelongs to\u201d an object. (In Python, the\nterm method is not unique to class instances: other object types can\nhave methods as well. For example, list objects have methods called\nappend, insert, remove, sort, and so on. ... And, the python doc also explains about a function as shown below: A series of statements which returns some value to a caller. It can\nalso be passed zero or more arguments which may be used in the\nexecution of the body. ... And, the python doc also explains about an object as shown below: Objects are Python\u2019s abstraction for data. All data in a Python\nprogram is represented by objects or by relations between objects. (In\na sense, and in conformance to Von Neumann\u2019s model of a \u201cstored\nprogram computer\u201d, code is also represented by objects.) Every object has an identity, a type and a value. An object\u2019s identity\nnever changes once it has been created; you may think of it as the\nobject\u2019s address in memory. The \u2018is\u2019 operator compares the identity of\ntwo objects; the id() function returns an integer representing its\nidentity.", "abstract": ""}, {"id": 70011059, "score": 0, "vote": 0, "content": "A method is a function that \u2018belongs\u2019 to an object and has a specific name: where obj is some object (this may be an expression), and methodname is the name of a method that is defined by the object\u2019s type. It is worth of noting: we call method like any other function.\nMore can be found in python tutorial.", "abstract": ""}, {"id": 3786900, "score": 92, "vote": 0, "content": "It's a function which is a member of a class: Simple as that! (There are also some alternative kinds of method, allowing you to control the relationship between the class and the function.  But I'm guessing from your question that you're not asking about that, but rather just the basics.)", "abstract": ""}, {"id": 59040078, "score": 0, "vote": 0, "content": "To understand methods you must first think in terms of object oriented programming:\nLet's take a car as a a class. All cars have things in common and things that make them unique, for example all cars have 4 wheels, doors, a steering wheel.... but Your individual car (Lets call it, my_toyota) is red, goes from 0-60 in 5.6s \nFurther the car is currently located at my house, the doors are locked, the trunk is empty... All those are properties of the instance of my_toyota. your_honda might be on the road, trunk full of groceries ... However there are things you can do with the car. You can drive it, you can open the door, you can load it. Those things you can do with a car are methods of the car, and they change a properties of the specific instance.  as pseudo code you would do: to change the location from my home to the shop or by this the trunk is now loaded with [milk, butter, bread].  As such a method is practically a function that acts as part of the object: the code then would be:", "abstract": ""}, {"id": 54966515, "score": 0, "vote": 0, "content": "If you think of an object as being similar to a noun, then a method is similar to a verb. Use a method right after an object (i.e. a string or a list) to apply a method's action to it.", "abstract": ""}, {"id": 35812834, "score": 28, "vote": 0, "content": "In Python, a method is a function that is available for a given object because of the object's type. For example, if you create my_list = [1, 2, 3], the append method can be applied to my_list because it's a Python list: my_list.append(4). All lists have an append method simply because they are lists. As another example, if you create my_string = 'some lowercase text', the upper method can be applied to my_string simply because it's a Python string: my_string.upper(). Lists don't have an upper method, and strings don't have an append method. Why? Because methods only exist for a particular object if they have been explicitly defined for that type of object, and Python's developers have (so far) decided that those particular methods are not needed for those particular objects. To call a method, the format is object_name.method_name(), and any arguments to the method are listed within the parentheses. The method implicitly acts on the object being named, and thus some methods don't have any stated arguments since the object itself is the only necessary argument. For example, my_string.upper() doesn't have any listed arguments because the only required argument is the object itself, my_string. One common point of confusion regards the following: Is sqrt a method of the math object? No. This is how you call the sqrt function from the math module. The format being used is module_name.function_name(), instead of object_name.method_name(). In general, the only way to distinguish between the two formats (visually) is to look in the rest of the code and see if the part before the period (math, my_list, my_string) is defined as an object or a module.", "abstract": ""}, {"id": 19699546, "score": 0, "vote": 0, "content": "http://docs.python.org/2/tutorial/classes.html#method-objects Usually, a method is called right after it is bound: In the MyClass example, this will return the string 'hello world'.\n  However, it is not necessary to call a method right away: x.f is a\n  method object, and can be stored away and called at a later time. For\n  example: will continue to print hello world until the end of time. What exactly happens when a method is called? You may have noticed\n  that x.f() was called without an argument above, even though the\n  function definition for f() specified an argument. What happened to\n  the argument? Surely Python raises an exception when a function that\n  requires an argument is called without any \u2014 even if the argument\n  isn\u2019t actually used... Actually, you may have guessed the answer: the special thing about\n  methods is that the object is passed as the first argument of the\n  function. In our example, the call x.f() is exactly equivalent to\n  MyClass.f(x). In general, calling a method with a list of n arguments\n  is equivalent to calling the corresponding function with an argument\n  list that is created by inserting the method\u2019s object before the first\n  argument. If you still don\u2019t understand how methods work, a look at the\n  implementation can perhaps clarify matters. When an instance attribute\n  is referenced that isn\u2019t a data attribute, its class is searched. If\n  the name denotes a valid class attribute that is a function object, a\n  method object is created by packing (pointers to) the instance object\n  and the function object just found together in an abstract object:\n  this is the method object. When the method object is called with an\n  argument list, a new argument list is constructed from the instance\n  object and the argument list, and the function object is called with\n  this new argument list.", "abstract": ""}, {"id": 11512621, "score": 4, "vote": 0, "content": "Sorry, but--in my opinion--RichieHindle is completely right about saying that method... It's a function which is a member of a class. Here is the example of a function that becomes the member of the class. Since then it behaves as a method of the class. Let's start with the empty class and the normal function with one argument: Now we add a member to the C class, which is the reference to the function. After that we can create the instance of the class and call its method as if it was defined inside the class: We can use also the alternative way of calling the method: The o.func even manifests the same way as the class method: And we can try the reversed approach. Let's define a class and steal its method as a function: So far, it looks the same. Now the function stealing: The truth is that the method does not accept 'whatever' argument: IMHO, this is not the argument against method is a function that is a member of a class. Later found the Alex Martelli's answer that basically says the same. Sorry if you consider it duplication :)", "abstract": ""}, {"id": 3787670, "score": 45, "vote": 0, "content": "A method is a function that takes a class instance as its first parameter. Methods are members of classes. As you wanted to know what it specifically means in Python, one can distinguish between bound and unbound methods. In Python, all functions (and as such also methods) are objects which can be passed around and \"played with\". So the difference between unbound and bound methods is: 1) Bound methods Bound methods are methods that belong to instances of a class. In this example, instance.method is bound to the instance called instance. Everytime that bound method is called, the instance is passed as first parameter automagically - which is called self by convention. 2) Unbound methods When you access C.method (the method inside a class instead of inside an instance), you get an unbound method. If you want to call it, you have to pass the instance as first parameter because the method is not bound to any instance. Knowing that difference, you can make use of functions/methods as objects, like passing methods around. As an example use case, imagine an API that lets you define a callback function, but you want to provide a method as callback function. No problem, just pass self.myCallbackMethod as the callback and it will automatically be called with the instance as first argument. This wouldn't be possible in static languages like C++ (or only with trickery). Hope you got the point ;) I think that is all you should know about method basics. You could also read more about the classmethod and staticmethod decorators, but that's another topic.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/74420001/is-there-a-way-to-access-a-python-method-in-another-file-that-is-reliant-on-anot", "keywords": [], "tags": ["python", "class", "oop", "methods"], "question": {"id": 74420001, "title": "Is there a way to access a python method in another file that is reliant on another method without specifying self?", "content": "I have some trouble with creating a python class and methods, and I don't know how to resolve it. I have 2 files, 1 file contains a class with multiple methods. 2 of these are: So the get_price_of_list method utilises the get_price_of method. My problem: When accessing the get_price_of_list from another file it now asks for 2 params: self and tickers. However, I don't need it to be an instance so is there any way to convert it to a static method while still being able to access the other function?", "abstract": ""}, "answers": [{"id": 74420024, "score": 0, "vote": 0, "content": "Here's the thing: If you want it to be an instance. First, initiate the class (pass in all args in the class). Then you can continue using the functions. Also, your get_price_of() function is missing self as the first parameter, which is why I suppose this approach fails at work. OR You can simply make them independent functions and remove self. Then, inside one function you can simply pass the parameter of the other. Here's the code:", "abstract": ""}, {"id": 74420046, "score": 1, "vote": 0, "content": "Yes. you can use @staticmethod. As I can see in your get_price_of method, there is no need for your instance to be exist. You just pass a ticker and you get a result back. Same thing with get_price_of_list. They are kind of utility functions that happen to be inside the class namespace. You could also define them in module. But one advantage of using them inside a class is that they are now organized. Relevant functions accumulated inside a class namespace. Change your methods to: Note that I changed self to the class name itself in get_price_of_list.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73544736/how-to-exclude-a-method-in-python", "keywords": [], "tags": ["python", "methods", "code-reuse"], "question": {"id": 73544736, "title": "How to exclude a method in Python?", "content": "I have a Python method in a class like below. I need to call the entire methodA() in another Python class by excluding only self.method3(self) from the methodA(). Could you please help me to achieve it?\nI don't want to duplicate the code just to exclude one method.", "abstract": ""}, "answers": [{"id": 73545146, "score": -1, "vote": 0, "content": "You can use the @SkipTest annotation from the unittest module to exclude a specific method from being run.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73528647/calling-an-instance-method-without-creating-an-instance-of-class-in-python", "keywords": [], "tags": ["python", "methods", "instance"], "question": {"id": 73528647, "title": "Calling an instance method without creating an instance of class in Python", "content": "I read on that instance methods can only be called by creating an instance (object) of the class. But it appears that I can call one without doing so. Check the code below: Please let me know what is happening behind the scenes.", "abstract": ""}, "answers": [{"id": 73528689, "score": 1, "vote": 0, "content": "Your code works because you feed as self argument the class itself. Your function will work as long as you use self as class type and not as class instance, which is very bad practice. I suggest to use staticmethods for such purposes: or @classmethod: Output:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73449754/assigning-vs-defining-python-magic-methods", "keywords": [], "tags": ["python", "class", "assign", "magic-methods"], "question": {"id": 73449754, "title": "Assigning vs. Defining Python Magic Methods", "content": "Consider the following abhorrent class: One can then call map(int, lst) via MapInt() - lst, i.e. However, addition is not so cooperative: This strangeness can be resolve by invoking the magic method directly: So my question is, what gives? Assigning __add__ directly seems to \"discard\" the self argument, but invoking the method itself or defining it in the standard way works fine.", "abstract": ""}, "answers": [{"id": 73465736, "score": 0, "vote": 0, "content": "This has to do with how python binds objects to an instance with the dot operator. When you create a class body, it contains a bunch of objects that become attributes living in the class dictionary. It does not matter how an attribute ends up in the class dictionary, the behavior will be the same. For example: If you try to access those class attributes through an instance, one of three things will happen: If the attribute has both __get__ and __set__, it's a data attribute. Data attributes shadow even instance dictionary items. A property object is a good example of a data attribute. Even if mi.test = 1 raises an AttributeError, MapInt.test has a __set__ method. As a consequence, mi.test will never access mi.__dict__['test'], which allow you to hide the property value there. If the attribute only has a __get__ descriptor, it's a non-data attribute. Functions, lambdas, and some other objects are non-data descriptors. A function gets bounds to the instance when you access it. So mi.__sub__(...) gets resolved as MapInt.__sub__.__get__(mi)(...). A function's __get__ creates a partial that automatically passes self in the usual manner. Descriptors like classmethod and staticmethod do other things in __get__, as you can imagine. If the attribute is not a descriptor, as determined by the presence of __get__ and __set__, then the object is returned as-is. In your particular case, mi.__call__ and mi.__add__ are int and map, respectively. Neither of those types has a __get__ method or is a descriptor, so it will not bind as a method.", "abstract": ""}, {"id": 73463221, "score": 2, "vote": 0, "content": "@sj95126 has already given you the answer. Here's some more insight which gives the output Note that: In group 1 above, f is passed as an argument to the function. In d(f) and w(f) it is done explicitly. In f.w() it is done implicitly by the binding behaviour of the pure-Python function wrapped. Because dir is not a pure-Python function, this binding behaviour is absent, and f is not passed in, so its output is the same as that of d(). (Irrelevant to your question, but for completeness: wrapped() passes zero arguments to wrapped therefore it passes zero arguments to dir and calling dir with zero arguments makes it return the list of names in the scope in which it was called, that is the local scope of wrapped in which the only names are the parameters args and kwds.", "abstract": ""}, {"id": 73449833, "score": 19, "vote": 0, "content": "The transformation of instance methods is described in the Python Data Model (emphasis mine): Note that the transformation from function object to instance method object happens each time the attribute is retrieved from the instance [...] Also notice that this transformation only happens for user-defined functions; other callable objects (and all non-callable objects) are retrieved without transformation. Since map is a built-in, not a user-defined function, there is no transformation to an instance method, so the self argument is not added.", "abstract": ""}, {"id": 73449894, "score": 3, "vote": 0, "content": "It doesn't have anything to do with the difference between \"assigning\" and/or \"defining\". You could even add functions dynamically after the creation of the class. They are all the same. This is the behavior of a descriptor. Your __sub__ is a descriptor. If it is called from an instance, it will give you a MethodType object whose first parameter is filled with the reference to the instance and that's why your first assert statement works. Actually all user-defined functions are descriptors but built-in callables(functions/classes) like map in this case or other callable objects like classes are not so don't except that their first parameter is going to be filled with something.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71292923/class-methods-redefining-self-argument-problems", "keywords": [], "tags": ["python-3.x", "class", "self"], "question": {"id": 71292923, "title": "Class methods redefining, &#39;self&#39; argument problems", "content": "I want to implement such case - i have a class, there i have some variable which contains external method, in some situations method can be redefined. It may looks like: So, it works: The result looks like: But in case redefine some_method: It returns a error, which says that i need to give self as argument in the line self.some_method(): Why does it happen and maybe someone knows trick to solve this problem?", "abstract": ""}, "answers": [{"id": 71297165, "score": 2, "vote": 0, "content": "It's a subtlety of what . does in Python. It both looks up the method on the class, and binds the method to the instance. This binding is what provides the class instance implicitly as the first argument, self. Look at this: However, when the method is found on the instance (which shadows the one on the class), the binding does not happen: This is stated in the Python reference: It is also important to note that user-defined functions which are attributes of a class instance are not converted to bound methods; this only happens when the function is an attribute of the class. The solution, then, is to make sure that the method is always an attribute of the class instance, and call it accordingly: Looks weird, works great. If you want the method to always be an attribute of the class instead, consider using inheritance.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70656424/is-there-a-way-to-disable-some-function-in-python-class-so-that-it-cannot-be-use", "keywords": [], "tags": ["python", "python-class", "python-object"], "question": {"id": 70656424, "title": "Is there a way to disable some function in python class so that it cannot be used except using it in inside its class?", "content": "for example i have myClassFile.py file with code as follow: then i have run.py file with code as follow: which when i run will output how to prevent someone to write below code on run.py file or outside myClass ? so that if they used that method outside myClass class it will be an error or some sort", "abstract": ""}, "answers": [{"id": 70656528, "score": 3, "vote": 0, "content": "You can add a level of protection around methods and attributes by prefixing them with __. But you can't make them totally private (as far as I know), there's always a way around, as shown in example below.", "abstract": ""}, {"id": 70656465, "score": -1, "vote": 0, "content": "Python does not have support for these. You can mark them private by prefixing them with _, or make it harder to call them by prefixing them with __. These are called private methods. To make a private variable or a method in python, just prefix it with a __, so def second(self) turns into def __second(self). This also works for variables and functional programming variables! gives an error, but x.test() prints _test out successfully! Note, this can still be run by using x.__Test__test()", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70651947/how-to-pass-a-function-with-parameters-to-after-method-of-tk", "keywords": [], "tags": ["python", "tkinter", "callback", "mainloop"], "question": {"id": 70651947, "title": "how to pass a function with parameters to after method of tk?", "content": "I want to run a function alongside the main loop of a window. I have this code: This code prints \"hello\" every second. If i add an argument to the function task like so: The function gets executed without any delay until this error message is shown: Is it just not possible to use a callback function with arguments in the after method? Weirdly enough, there seems to be no documentation on this method on the official API site.", "abstract": ""}, "answers": [{"id": 70652008, "score": 3, "vote": 0, "content": "This happens because task(0) is actually calling itself instead of passing the name of the function to call like in the first code you are passing an expression which calls the function task with 0 as an argument, and when this happens the function calls itself again and again because inside of the function call you are calling it again using the same expression, this happens until the maximum depth is reached in python of recursive calls (I think it is 1000). A solution to this is to use lambda expression like this if you want to pass an argument:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/62477883/method-vs-function-valued-field-in-python", "keywords": [], "tags": ["python", "methods"], "question": {"id": 62477883, "title": "Method vs function-valued field in Python", "content": "I am switching from MATLAB to Python and numpy and I would like to know if there is any difference between the option to define a class method and the option to the function to a  class field (instance variable)? Here is the example: vs It works in both cases when I call   Are there any differences between these two approaches? Any best practices/downsides?\nTo me, the first one feels more \"proper OOP\", but the second one feels more flexible. Or, maybe, the definitions are identical, because of the way Python works under the hood?", "abstract": ""}, "answers": [{"id": 62477914, "score": 2, "vote": 0, "content": "The second one can't be overridden and takes a lot more space, because there's a separate function in every instance's __dict__ instead of one function in the class __dict__. (Instance method objects are created and reclaimed on the fly if you do it the normal way, or optimized out entirely in many cases depending on Python version.)", "abstract": ""}]}]