[{"link": "https://stackoverflow.com/questions/9157210/how-do-i-raise-the-same-exception-with-a-custom-message-in-python", "keywords": [], "tags": ["python", "exception", "message"], "question": {"id": 9157210, "title": "How do I raise the same Exception with a custom message in Python?", "content": "I have this try block in my code: Strictly speaking, I am actually raising another ValueError, not the ValueError thrown by do_something...(), which is referred to as err in this case. How do I attach a custom message to err? I try the following code but fails due to err, a ValueError instance, not being callable:", "abstract": ""}, "answers": [{"id": 9157277, "score": 126, "vote": 0, "content": "Update: For Python 3, check Ben's answer Update 2023: I wrote this answer more than ten years ago and there are better answers now. You should be using python 3 and the answer above. Original answer: To attach a message to the current exception and re-raise it:\n(the outer try/except is just to show the effect) For python 2.x where x>=6: This will also do the right thing if err is derived from ValueError. For example UnicodeDecodeError. Note that you can add whatever you like to err. For example err.problematic_array=[1,2,3]. Edit: @Ducan points in a comment the above does not work with python 3 since .message is not a member of ValueError. Instead you could use this (valid python 2.6 or later or 3.x): Edit2: Depending on what the purpose is, you can also opt for adding the extra information under your own variable name. For both python2 and python3:", "abstract": ""}, {"id": 70380633, "score": -1, "vote": 0, "content": "I tried this compact version of @RobinL, and worked as well:", "abstract": ""}, {"id": 75549200, "score": 11, "vote": 0, "content": "PEP 678 \u2013 Enriching Exceptions with Notes was accepted and landed in Python 3.11. New APIs allow users to attach custom message(s) to existing errors. This is useful for adding additional context when an error is encountered. Using the add_note method is suitable for answering the original question: It would render like this: Modifying the args attribute, which is used by BaseException.__str__ to render an exception, is the only way. You could either extend the args: Which will render as: Or you could replace the args[0], which is a little more complicated but produces a cleaner result. This will render the same way as the Python 3.11+ exception __notes__ do:", "abstract": ""}, {"id": 75146373, "score": -2, "vote": 0, "content": "Raising same error, with prepending custom text message in front.\n(edit -  sorry, actually same as https://stackoverflow.com/a/65494175/15229310 , why there is like 10 (upvoted) 'solutions' that simply don't answer question as posted?)", "abstract": ""}, {"id": 62662138, "score": 15, "vote": 0, "content": "This only works with Python 3.  You can modify the exception's original arguments and add your own arguments. An exception remembers the args it was created with.  I presume this is so that you can modify the exception. In the function reraise we prepend the exception's original arguments with any new arguments that we want (like a message).  Finally we re-raise the exception while preserving the trace-back history.", "abstract": ""}, {"id": 65494175, "score": 3, "vote": 0, "content": "Try below: Output:", "abstract": ""}, {"id": 29442282, "score": 333, "vote": 0, "content": "If you're lucky enough to only support python 3.x, this really becomes a thing of beauty :) We can chain the exceptions using raise from. In this case, the exception your caller would catch has the line number of the place where we raise our exception. Notice the bottom exception only has the stacktrace from where we raised our exception. Your caller could still get the original exception by accessing the __cause__ attribute of the exception they catch. Or you can use with_traceback. Using this form, the exception your caller would catch has the traceback from where the original error occurred. Notice the bottom exception has the line where we performed the invalid division as well as the line where we reraise the exception.", "abstract": ""}, {"id": 60185186, "score": 1, "vote": 0, "content": "None of the above solutions did exactly what I wanted, which was to add some information to the first part of the error message i.e. I wanted my users to see my custom message first. This worked for me:", "abstract": ""}, {"id": 49380379, "score": 3, "vote": 0, "content": "Either raise the new exception with your error message using or within the place where you want to raise it OR attach (replace) error message into current exception using 'from' (Python 3.x supported only):", "abstract": ""}, {"id": 17030625, "score": 13, "vote": 0, "content": "It seems all the answers are adding info to e.args[0], thereby altering the existing error message.  Is there a downside to extending the args tuple instead?  I think the possible upside is, you can leave the original error message alone for cases where parsing that string is needed; and you could add multiple elements to the tuple if your custom error handling produced several messages or error codes, for cases where the traceback would be parsed programmatically (like via a system monitoring tool). or Can you see a downside to this approach?", "abstract": ""}, {"id": 45960221, "score": 1, "vote": 0, "content": "Python 3 built-in exceptions have the strerror field:", "abstract": ""}, {"id": 38772267, "score": 4, "vote": 0, "content": "This is the function I use to modify the exception message in Python 2.7 and 3.x while preserving the original traceback. It requires six", "abstract": ""}, {"id": 9157254, "score": 7, "vote": 0, "content": "prints:", "abstract": ""}, {"id": 31155263, "score": 1, "vote": 0, "content": "The current answer did not work good for me, if the exception is not re-caught the appended message is not shown. But doing like below both keeps the trace and shows the appended message regardless if the exception is re-caught or not. ( I used Python 2.7, have not tried it in Python 3 )", "abstract": ""}, {"id": 10997792, "score": 6, "vote": 0, "content": "This code template should allow you to raise an exception with a custom message.", "abstract": ""}, {"id": 9157273, "score": -7, "vote": 0, "content": "if you want to custom the error type, a simple thing you can do is to define an error class based on ValueError.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/62614078/why-does-mutating-a-list-in-a-tuple-raise-an-exception-but-mutate-it-anyway", "keywords": [], "tags": ["python", "python-3.x", "tuples", "immutability"], "question": {"id": 62614078, "title": "Why does mutating a list in a tuple raise an exception but mutate it anyway?", "content": "I am not sure I quite understand what's happening in the below mini snippet (on Py v3.6.7). It would be great if someone can explain to me as to how can we mutate the list successfully even though there's an error thrown by Python. I know that we can mutate a list and update it, but what\u2019s with the error? Like I was under the impression that if there's an error, then the x should remain the same. The Traceback thrown at line (1) is I understand what the error means but I am unable to get the context of it. But now if I try to print the value of my variable x, Python says it's, As far as I can understand, the exception has happened after Python allowed the mutation of the list to happen and then hopefully it tried re-assigning it back. It blew there I think as Tuples are immutable. Can someone explain what's happening under the hood? Edit - 1\nError From ipython console as an image; ", "abstract": ""}, "answers": [{"id": 62616404, "score": 6, "vote": 0, "content": "Existing answers are correct, but I think the documentation can actually shed some extra light on this: From in-place operators documentation: the statement x += y is equivalent to x = operator.iadd(x, y) so when we write It's equivalent to iadd is implemented using extend, in the case of the list, so we see that this operation is actually doing 2 things: As indicated later in the documentation: note that when an in-place method is called, the computation and assignment are performed in two separate steps. The first operation is not a problem The second operation is impossible, since x is a tuple. This can seem puzzling in this case, and one can wonder why the +=operator is equivalent to x = operator.iadd(x, y), rather than simply operator.iadd(x, y). This wouldn't work for immutable types, like int and str. So while iadd is implemented as return x.extend(y) for lists, it is implemented as return x + y for ints. Again from the documentation: For immutable targets such as strings, numbers, and tuples, the updated value is computed, but not assigned back to the input variable", "abstract": ""}, {"id": 62614291, "score": 9, "vote": 0, "content": "There are a few things happening here. += is not always + and then =. += and + can have different implementations if required. Take a look at this example. Similarly, the list class has separate implementations for + and +=. Using += actually does an extend operation in the background. Using + creates a new list. Let's come to your question now. The + operator gets executed first here, which means the list gets updated (extended). This is allowed as the reference to the list (value stored in the tuple) doesn't change, so this is fine. The = then tries to update the reference inside the tuple which isn't allowed since tuples are immutable. But the actual list was mutated by the +. Python fails to update the reference to the list inside the tuple but since it would have been updated to the same reference, we, as users don't see the change. So, the + gets executed and the = fails to execute. + mutates the already referenced list inside the tuple so we see the mutation in the list.", "abstract": ""}, {"id": 62614161, "score": 9, "vote": 0, "content": "My gut feeling is that the line x[0] += [3, 4] first modifies the list itself so [1, 2] becomes [1, 2, 3, 4], then it tries to adjust the content of the tuple which throws a TypeError, but the tuple always points towards the same list so its content (in terms of pointers) is not modified while the object pointed at is modified. We can verify it that way: This does not throw an error and does modify it in place, despite being stored in a \"immutable\" tuple.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/9172263/a-mutable-type-inside-an-immutable-container", "keywords": [], "tags": ["python", "list", "tuples", "immutability", "mutable"], "question": {"id": 9172263, "title": "a mutable type inside an immutable container", "content": "I'm a bit confused about modifying tuple members.  The following doesn't work: But this does work:     Also works: Doesn't work, and works (huh?!): Seemingly equivalent to previous, but works: So what exactly are the rules of the game, when you can and can't modify something inside a tuple? It seems to be more like prohibition of using the assignment operator for tuple members, but the last two cases are confusing me.  ", "abstract": ""}, "answers": [{"id": 9172294, "score": 6, "vote": 0, "content": "You can't modify the tuple, but you can modify the contents of things contained within the tuple. Lists (along with sets, dicts, and objects) are a reference type and thus the \"thing\" in the tuple is just a reference - the actual list is a mutable object which is pointed to by that reference and can be modified without changing the reference itself. After thing[0][0] = 'b': After thing[0].append('c'): The reason why += errors is that it's not completely equivalent to .append() - it actually does an addition and then an assignment (and the assignment fails), rather than merely appending in-place.", "abstract": ""}, {"id": 9172325, "score": 17, "vote": 0, "content": "You can always modify a mutable value inside a tuple. The puzzling behavior you see with  is caused by +=. The += operator does in-place addition but also an assignment \u2014 the in-place addition works just file, but the assignment fails since the tuple is immutable. Thinking of it like explains this better. We can use the dis module from the standard library to look at the bytecode generated from both expressions. With += we get an INPLACE_ADD bytecode: With + we get a BINARY_ADD: Notice that we get a STORE_FAST in both places. This is the bytecode that fails when you try to store back into a tuple \u2014 the INPLACE_ADD that comes just before works fine.  This explains why the \"Doesn't work, and works\" case leaves the modified list behind: the tuple already has a reference to the list: The list is then modified by the INPLACE_ADD and the STORE_FAST fails: So the tuple still has a reference to the same list, but the list has been modified in-place:", "abstract": ""}, {"id": 9175140, "score": 1, "vote": 0, "content": "You cannot replace an element of a tuple, but you can replace the entire contents of the element. This will work:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/35851782/why-does-handling-multiple-exceptions-require-a-tuple-but-not-a-list", "keywords": [], "tags": ["python", "python-2.7", "exception", "error-handling"], "question": {"id": 35851782, "title": "Why does handling multiple exceptions require a tuple, but not a list?", "content": "Consider the following example: The tuple is the correct way to handle multiple exception types. Using a list for the multiple exception types causes neither to be handled. I am wondering why Python syntax requires a tuple for multiple exception types.  The docs say that it uses a tuple, so perhaps it is just \"never was implemented using a list instead of a tuple.\" It seems reasonable to me that a list could also be used in this situation, conceptually at least. Is there any reason why Python uses a tuple instead of a list for this situation?", "abstract": ""}, "answers": [{"id": 35852234, "score": 9, "vote": 0, "content": "The error handling, written in C, uses type checking for the special case of a tuple, before other type-checking and exception handling, so that multiple types of exceptions may be caught.  At least one Python core developer advocates using exception handling for control flow. Adding lists as an additional type to check would work against this strategy. It appears that expanding this to allow for sets or lists has not been specifically addressed by the core development team, though I will gladly reference it if it can be found. There has been a discussion on the Python mailing list that speculates quite a lot (another answer here quotes one response at length).  After performing the below analysis, and in the context of the mailing list discussion, I think the reasoning is obvious. I do not suggest proposing to add other containers. Catching the tuple of exceptions does work: outputs: But catching the list of exceptions does not work: prints: This demonstrates that we are doing type checking for the special case of a tuple. It would certainly make the code slower to add another type to check for, and the core developers have been saying that it's a good thing to use exception handling for control flow in Python for a while now.  An analysis of the source agrees with this above conclusion. This is not an issue for Python's grammar or parsing. It will accept any expression. Thus any expression that results in an Exception or tuple of Exceptions should be legal. If we disassemble a function that does this in Python 3, we see that it looks to match an exception with a comparison operation.  Which outputs: This leads us inside the Python interpreter. The CPython control flow first checks for if the value is a tuple. If so, \nit iterates through the tuple using tuple specific code - looking for the value to be a Exception: Adding another type would require more internal control flow, slowing down control flow inside of the Python interpreter. Tuples are lightweight arrays of pointers. So are lists, but they may be allocated extra space so that you may quickly add to them (up to the point they need to get larger). In Python 3.7.3 on Linux: Sets take up even more space because they are hash tables. They have both a hash of the object they contain as well as a pointer to that which they point to. This is for the CPython core development team to debate and decide.  But my conclusion is that slowing down control flow in Python by checking for other types even at the C level would work against the strategy of using exception handling for control flow in Python modules.  After reasoning through the above, I would not propose that they add this.", "abstract": ""}, {"id": 36236179, "score": 3, "vote": 0, "content": "@BrenBarn Thanks for your link to the discussion at https://mail.python.org/pipermail/python-list/2012-January/619107.html I think the best and clearest response comes from Steven D'Aprano's reply at https://mail.python.org/pipermail/python-list/2012-January/619120.html I copied the content below for easy read. Steven's reply: Simplicity. If you also allow lists, then why not allow arbitrary sequences? What \nabout iterators, do you allow them? That could be awkward, because \niterators can only be run through once. Dictionaries are also iterable, \nso once you allow arbitrary iterables, you get dicts. The whole thing \nbecomes a mess. Better to keep it simple and only allow a single \ncanonical collection type, and in Python, that type is tuple, not list. Tuples are that canonical collection type because they have a number of \ndesirable properties: Tuples are small and memory efficient, using the smallest amount of\nmemory needed to hold their items. Lists typically carry a block of\nspare memory, to make insertions fast. Consequently the Python virtual machine can create them rapidly and\nefficiently. Tuples are immutable, so you don't have to worry about passing one to a\nfunction and having the function modify it behind your back. Tuples are ordered, for the times where that matters. Since the typical use-case is to iterate over the items in fixed order,\nthere's no need to pay the extra expense for a dict or set. Tuples are simple to write: in general you only need commas between\nitems. Sometimes, to avoid ambiguity or change the precedence of\ncalculation, you also need round brackets (parentheses for Americans).\nExcept clauses are one of those times. Frozensets and sets are ruled out for historical reasons: they didn't\nexist until Python 2.3. Besides, which would you rather write? (\"abc\", \"def\")\n  frozenset([abc\", \"def\"]) Sets and lists are ruled out because they are mutable, both require\nmuch more memory, and sets have a heavier computational burden. The latter makes more sense semantically to me -- \"catch all exception\n  types in a list\" as opposed to \"catch this single thing composed of\n  three exception types\". Then you are labouring under a misunderstanding. You're not catching a \ntuple, because tuples are never thrown. You're catching any of the \nexceptions that are contained in that tuple. Both lists and tuples are single things in themselves. Both lists and \ntuples are containers: A list is a single thing that contains other things.  A tuple is a single thing that contains other things.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/41446833/what-is-the-difference-between-i-i-1-and-i-1-in-a-for-loop", "keywords": [], "tags": ["python", "loops", "numpy", "operators"], "question": {"id": 41446833, "title": "What is the difference between i = i + 1 and i += 1 in a &#39;for&#39; loop?", "content": "I found out a curious thing today and was wondering if somebody could shed some light into what the difference is here? After running each for loop, A has not changed, but B has had one added to each element. I actually use the B version to write to a initialized NumPy array within a for loop.", "abstract": ""}, "answers": [{"id": 41447350, "score": 14, "vote": 0, "content": "As already pointed out, b += 1 updates b in-place, while a = a + 1 computes a + 1 and then assigns the name a to the result (now a does not refer to a row of A anymore). To understand the += operator properly though, we need also to understand the concept of mutable versus immutable objects. Consider what happens when we leave out the .reshape: We see that C is not updated, meaning that c += 1 and c = c + 1 are equivalent. This is because now C is a 1D array (C.ndim == 1), and so when iterating over C, each integer element is pulled out and assigned to c. Now in Python, integers are immutable, meaning that in-place updates are not allowed, effectively transforming c += 1 into c = c + 1, where c now refers to a new integer, not coupled to C in any way. When you loop over the reshaped arrays, whole rows (np.ndarray's) are assigned to b (and a) at a time, which are mutable objects, meaning that you are allowed to stick in new integers at will, which happens when you do a += 1. It should be mentioned that though + and += are meant to be related as described above (and very much usually are), any type can implement them any way it wants by defining the __add__ and __iadd__ methods, respectively.", "abstract": ""}, {"id": 41446885, "score": 28, "vote": 0, "content": "In the first example, you are reassigning the variable a, while in the second one you are modifying the data in-place, using the += operator. See the section about 7.2.1. Augmented assignment statements\n: An augmented assignment expression like x += 1 can be rewritten as x = x + 1 to achieve a similar, but not exactly equal effect. In the augmented version, x is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead. += operator calls __iadd__. This function makes the change in-place, and only after its execution, the result is set back to the object you are \"applying\" the += on. __add__ on the other hand takes the parameters and returns their sum (without modifying them).", "abstract": ""}, {"id": 41453452, "score": 2, "vote": 0, "content": "A key issue here is that this loop iterates over the rows (1st dimension) of B: Thus the += is acting on a mutable object, an array. This is implied in the other answers, but easily missed if your focus is on the a = a+1 reassignment. I could also make an in-place change to b with [:] indexing, or even something fancier, b[1:]=0: Of course with a 2d array like B we usually don't need to iterate on the rows.  Many operations that work on a single of B also work on the whole thing.  B += 1, B[1:] = 0, etc.", "abstract": ""}, {"id": 41446882, "score": 134, "vote": 0, "content": "The difference is that one modifies the data-structure itself (in-place operation) b += 1 while the other just reassigns the variable a = a + 1. Just for completeness: x += y is not always doing an in-place operation, there are (at least) three exceptions: If x doesn't implement an __iadd__ method then the x += y statement is just a shorthand for x = x + y. This would be the case if x was something like an int. If __iadd__ returns NotImplemented, Python falls back to x = x + y. The __iadd__ method could theoretically be implemented to not work in place. It'd be really weird to do that, though. As it happens your bs are numpy.ndarrays which implements __iadd__ and return itself so your second loop modifies the original array in-place. You can read more on this in the Python documentation of \"Emulating Numeric Types\". These [__i*__] methods are called to implement the augmented arithmetic assignments (+=, -=, *=, @=, /=, //=, %=, **=, <<=, >>=, &=, ^=, |=). These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self). If a specific method is not defined, the augmented assignment falls back to the normal methods. For instance, if x is an instance of a class with an __iadd__() method, x += y is equivalent to x = x.__iadd__(y) . Otherwise, x.__add__(y) and y.__radd__(x) are considered, as with the evaluation of x + y. In certain situations, augmented assignment can result in unexpected errors (see Why does a_tuple[i] += [\"item\"] raise an exception when the addition works?), but this behavior is in fact part of the data model.", "abstract": ""}, {"id": 41447385, "score": 3, "vote": 0, "content": "First off: The variables a and b in the loops refer to numpy.ndarray objects. In the first loop, a = a + 1 is evaluated as follows: the __add__(self, other) function of numpy.ndarray is called. This creates a new object and hence, A is not modified. Afterwards, the variable a is set to refer to the result.  In the second loop, no new object is created. The statement b += 1 calls  the __iadd__(self, other) function of numpy.ndarray which modifies the ndarray object in place to which b is referring to. Hence, B is modified.", "abstract": ""}, {"id": 41446935, "score": 4, "vote": 0, "content": "The short form(a += 1) has the option to modify a in-place , instead of creating a new object representing the sum and rebinding it back to the same name(a = a + 1).So,The short form(a += 1) is much efficient as it doesn't necessarily need to make a copy of a unlike a = a + 1. Also even if they are outputting the same result, notice they are different because they are separate operators: + and +=", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/21361281/mutate-tuple-of-lists-getting-tuple-object-does-not-support-item-assignment", "keywords": [], "tags": ["python", "list", "tuples", "immutability"], "question": {"id": 21361281, "title": "Mutate tuple of lists getting &quot;&#39;tuple&#39; object does not support item assignment\u201c", "content": "I'm trying to modify a list in a tuple, the append method works, while += operator works yet with an exception raised saying tuple could not be modified. I know a tuple is immutable, but I'm not trying to mutate it. Why this happen?", "abstract": ""}, "answers": [{"id": 21361412, "score": 7, "vote": 0, "content": "+= is the in-place addition operator. It does two things: By using += on a list stored in a tuple, the first step succeeds; the t[0] list is altered in-place, but the second step, rebinding t[0] to the return value of t[0].__iadd__ fails because a tuple is immutable. The latter step is needed to support the same operator on both mutable and immutable objects: Here a immutable string was added to, and somestr was rebound to a new object, because strings are immutable. Here the list was altered in-place and somestr was rebound to the same object, because list.__iadd__() can alter the list object in-place. From the augmented arithmetic special method hooks documentation: These methods are called to implement the augmented arithmetic assignments (+=, -=, *=, /=, //=, %=, **=, <<=, >>=, &=, ^=, |=). These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self).  The work-around here is to call t[0].extend() instead:", "abstract": ""}, {"id": 21361368, "score": 1, "vote": 0, "content": "When we say tuple is immutable, it means that the elements of a tuple (which are references to other objects), cannot be changed (read as, cannot be made to refer other objects). So, when you say, You are not changing the element at index 0, to refer some other object. Instead, you are making changes to the same object, which is perfectly okay as per the tuple. When you say, Python internally calls __iadd__ (stands for inplace add) method, which can be understood like this which means that, we take the object t[0], adding it with [4,5,] to get a new object and that new object is being assigned back to t[0]. Now we are trying to mutate the tuple (making an element of a tuple refer to some other object). That is why you see in the later case.", "abstract": ""}, {"id": 21361312, "score": 4, "vote": 0, "content": "Because t[0] += [4,5,] is interpreted as: t[0]__iadd__([4,5]) succeed, while t[0] = .. fail. list.__iadd__ extend the list, and return itself.", "abstract": ""}, {"id": 21361335, "score": 1, "vote": 0, "content": "In fact you do change the tuple: The + operator for lists creates a new list and you try to mutate your tuple by replacing the old list by the new one. appendmodifies the list in the tuple, therefore it works.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/29747224/append-to-a-list-defined-in-a-tuple-is-it-a-bug", "keywords": [], "tags": ["python", "list", "tuples"], "question": {"id": 29747224, "title": "Append to a list defined in a tuple - is it a bug?", "content": "So I have this code: which generates this error: While this code: prints this: Is this behavior expected? I realize this is not a very common use case. However, while the error is expected, I did not expect the list change. ", "abstract": ""}, "answers": [{"id": 39872951, "score": 2, "vote": 0, "content": "The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works The short version is that += actually does two things, one right after the other: In this case, step 1 works because you\u2019re allowed to add stuff to lists (they\u2019re mutable), but step 2 fails because you can\u2019t put stuff into tuples after creating them (tuples are immutable).  In a real program, I would suggest you don't do a try-except clause, because tup[0].extend([4,5,6]) does the exact same thing.", "abstract": ""}, {"id": 29747287, "score": 37, "vote": 0, "content": "Yes it's expected.  A tuple cannot be changed. A tuple, like a list, is a structure that points to other objects. It doesn't care about what those objects are. They could be strings, numbers, tuples, lists, or other objects. So doing anything to one of the objects contained in the tuple, including appending to that object if it's a list, isn't relevant to the semantics of the tuple. (Imagine if you wrote a class that had methods on it that cause its internal state to change. You wouldn't expect it to be impossible to call those methods on an object based on where it's stored). Or another example: Two mutable lists referenced by a list and by a tuple. Should I be able to do the last line (answer: yes). If you think the answer's no, why not? Should t change the semantics of l3 (answer: no). If you want an immutable object of sequential structures, it should be tuples all the way down. This example uses the infix operator: Many operations have an \u201cin-place\u201d version. The following functions\n  provide a more primitive access to in-place operators than the usual\n  syntax does; for example, the statement x += y is equivalent to x =\n  operator.iadd(x, y). Another way to put it is to say that z =\n  operator.iadd(x, y) is equivalent to the compound statement z = x; z\n  += y. https://docs.python.org/2/library/operator.html So this: is equivalent to this: The __iadd__ line succeeds, and modifies the first list. So the list has been changed. The __iadd__ call returns the mutated list.  The second line tries to assign the list back to the tuple, and this fails. So, at the end of the program, the list has been extended but the second part of the += operation failed. For the specifics, see this question.", "abstract": ""}, {"id": 29747543, "score": 6, "vote": 0, "content": "Tuples cannot be changed directly, correct. Yet, you may change a tuple's element by reference. Like:", "abstract": ""}, {"id": 29747466, "score": 12, "vote": 0, "content": "Well I guess tup[0] += (4, 5, 6) is translated to: tup[0].__iadd__((4,5,6)) is executed normally changing the list in the first element. But the assignment fails since tuples are immutables.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/39658446/why-can-you-extend-append-to-a-list-in-a-tuple-but-not-assign-to-it", "keywords": [], "tags": ["python", "tuples"], "question": {"id": 39658446, "title": "Why can you extend/append to a list in a tuple, but not assign to it?", "content": "Inspired by reading footnote 4 of this article. Consider the following scenario: Tuples are immutable. So, as expected, trying to add to the list inside the tuple raises an error. However if we inspect our tuple, the list has been added to!! (I can imagine this leading to very hard to track down bugs) Also, both extending and appending work without raising an error. So, my questions are:", "abstract": ""}, "answers": [{"id": 39658654, "score": 2, "vote": 0, "content": "If tuples are immutable, why is it possible to change a list within a tuple? Because \"tuples are immutable\" only means you cannot modify the tuple. The list that's referred to from the tuple is not part of the tuple, it doesn't \"know\" that it is in a tuple, and it has no means to resist being modified. Why does the first example raise an error and the other two not? Because of how += works. It calls __iadd__ on the list and then (because __iadd__ is not required to return the original object) attempts to assign the resulting modified object back to the tuple. The first thing succeeds, the second thing fails. That is, for this case where t[2] has an __iadd__ function, t[2] += [5,6] is equivalent to: t[2] = t[2].__iadd__([5,6]) In the first example, why is the list inside the tuple changed even though an error is raised? Because this Python operation doesn't offer what in C++ we'd call a \"strong exception guarantee\". The first part of the operation has already been performed, and cannot be (or at any rate is not) reversed when the second part fails. For the official version see Why does a_tuple[i] += [\u2018item\u2019] raise an exception when the addition works?", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/38344244/tuples-operator-throws-exception-but-succeeds", "keywords": [], "tags": ["python", "tuples"], "question": {"id": 38344244, "title": "Tuples: += operator throws exception, but succeeds?", "content": "Why does the following throw an exception, although it succeeds?", "abstract": ""}, "answers": [{"id": 38345741, "score": 3, "vote": 0, "content": "The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works The short version is that += actually does two things, one right after the other: In this case, step 1 works because you\u2019re allowed to add stuff to lists (they\u2019re mutable), but step 2 fails because you can\u2019t put stuff into tuples after creating them (tuples are immutable).  In a real program, I would suggest you don't do this because t[0].extend(['c']) does the exact same thing.", "abstract": ""}, {"id": 38344424, "score": 7, "vote": 0, "content": "It can also help to understand this behavior by taking a look at the bytecode with dis.dis.  ", "abstract": ""}, {"id": 38344245, "score": 17, "vote": 0, "content": "Found the answer on IRC. t[0] += [1] is several discrete actions: It seems that x += y is basically x = x + y (but, is it?) The tricky bit is that += implies assignment to both the tuple t and to the list t[0] t[0] += [1] is not literally t[0] = t[0] + [1], it is: t[0] = t[0].__iadd__([1]) What really happens is: Why is this not visible in plain sight? Because a n00b like me would expect t[0] += [1] to either succeed all together or fail, because it's one short line of python. But that's not always the case.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/32799300/are-tuples-really-immutable-in-python", "keywords": [], "tags": ["python", "python-2.7", "python-3.x", "tuples", "immutability"], "question": {"id": 32799300, "title": "Are tuples really immutable in Python?", "content": "One question that I faced today, which actually tested the immutability of the tuples in Python: Interviewer: Are tuples immutable in Python? Me: Yes Interviewer: So what does print(t1) here print? Me: (4, 5, 91, 10) Interviewer: How does immutability of tuple then define this behavior? Me: It's got nothing to do with immutability, t1 label is referring to a new tuple.  Interviewer: What will happen next?  Me: TypeError is raised Interviewer: What will be the value of t be after that? Me: (1, 2, [3, 4]) or (1, 2, [3, 4, 5, 6]) maybe, not sure Interviewer: What made you think the value will change to (1, 2, [3, 4, 5, 6]) and what will happen if I write  will t2 still be (1, 2, [3, 4, 5, 6]) after this operation?", "abstract": ""}, "answers": [{"id": 32799373, "score": 3, "vote": 0, "content": "Even though the tuples are immutable, the object inside it can be mutuable Since in >>> t = (1, 2, [3, 4]) the list is mutable so you can change the list value with Augmented assignment. += but then the exception is raised. here the t[2] list is modified as you can see As you can see the t[2] id never gets changed.  As for the second case: t[2] = t[2] + [5,6] - it creates a new list and then assign it to t[2] As you can see List = list + [] is a new list with a different id. and as the tuple is immutable t[2] doesn't get assigned to a new object in the second case", "abstract": ""}]}]