[{"link": "https://stackoverflow.com/questions/34997241/a-list-comprehension-of-lambdas-returns-the-same-values", "keywords": [], "tags": ["python", "python-3.x", "lambda", "list-comprehension"], "question": {"id": 34997241, "title": "A list comprehension of lambdas returns the same values", "content": "I've found this example somewhere, and I cannot understand it. As I see, the first line creates a list of lambda functions which I can call afterwards. What I don't understand is the output of [6,6,6,6]. As I can see, the elements of mult are located in different parts of memory, so, these are not several references to the same data block. But why do they produce the same results? Do all these functions reference the same i (which is the last one, which is 3), and why is this happening? And is there a quick way to make such a list of lambdas that would produce [0,2,4,6] instead?", "abstract": ""}, "answers": [{"id": 34997306, "score": 3, "vote": 0, "content": "i is not bound in the body of the lambda; its value is looked up once the function is called, so you are creating a list of 4 identical functions. In Python 2, the index of a list comprehension \"leaks\", since a new scope is not created. When you call each m, each sees the same value of i, which is the last value i was assigned in the comprehension. The solution is to force i to take a specific value in the body of each function. This can be done by using a \"do-nothing\" parameter, one whose only purpose is to use its default value.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66039869/lambda-with-different-expression-returns-same-output", "keywords": [], "tags": ["python", "python-3.x"], "question": {"id": 66039869, "title": "Lambda with different expression returns same output", "content": "Take this code snippet for example: The output is: But I expected it to be How do I fix this?", "abstract": ""}, "answers": [{"id": 66039891, "score": 3, "vote": 0, "content": "Use default arguments: This works because the default value is evaluated when the function is created. Otherwise all lambda functions will point to the last value of x, which was 1.", "abstract": ""}, {"id": 66039981, "score": 1, "vote": 0, "content": "@sarartur already provided the solution. Here is little more explanation for this behavior. This is called Late Binding Closures. Quoting from the blog, Python\u2019s closures are late binding. This means that the values of variables used in closures are looked up at the time the inner function is called. So here whenever any of the returned functions are called, the value of i is looked up in the surrounding scope at call time. By then, the loop has completed and i is left with its final value of 1.", "abstract": ""}, {"id": 66039895, "score": 0, "vote": 0, "content": "This is happening because your lambda expressions are printing x, but x is being updated by your for loop, so by the time your lambda expressions are invoked, x has finished with a value of 1 because that's the last value in range(2).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/19837486/lambda-in-a-loop", "keywords": [], "tags": ["python", "loops", "anonymous-function"], "question": {"id": 19837486, "title": "Lambda in a loop", "content": "Considering the following code snippet: I expect to create a dictionary of two function as following : but it looks like the two lambda function generated are exactly the same : I really don't understand why. Do you have any suggestions ?", "abstract": ""}, "answers": [{"id": 57288183, "score": 16, "vote": 0, "content": "Alternatively, instead of lambda, you can use functools.partial which, in my opinion, has a cleaner syntax.  Instead of: it will be: Or, here is another simple example:", "abstract": ""}, {"id": 19837683, "score": 122, "vote": 0, "content": "You need to bind d for each function created. One way to do that is to pass it as a parameter with a default value: Now the d inside the function uses the parameter, even though it has the same name, and the default value for that is evaluated when the function is created. To help you see this: Remember how default values work, such as for mutable objects like lists and dicts, because you are binding an object. This idiom of parameters with default values is common enough, but may fail if you introspect function parameters and determine what to do based on their presence.  You can avoid the parameter with another closure:", "abstract": ""}, {"id": 46847190, "score": 3, "vote": 0, "content": "I met the same problem. The selected solution helped me a lot, but I consider necessary to add a precision to make functional the code of the question: define the lambda function outside of the loop. By the way, default value is not necessary.", "abstract": ""}, {"id": 19837590, "score": 33, "vote": 0, "content": "This is due to the point at which d is being bound. The lambda functions all point at the variable d rather than the current value of it, so when you update d in the next iteration, this update is seen across all your functions. For a simpler example: You can get around this by adding an additional function, like so: You can also fix the scoping inside the lambda expression  However in general this is not good practice as you have changed the signature of your function.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/33983980/lambda-in-for-loop-only-takes-last-value", "keywords": [], "tags": ["python", "lambda", "tkinter", "contextmenu"], "question": {"id": 33983980, "title": "lambda in for loop only takes last value", "content": "Problemset: Context Menu should show filter variables dynamically and execute a function with parameters defined inside the callback.\nGeneric descriptions show properly, but function call is always executed with last set option. What I have tried: The current output i get is: Filter Log Recordset by 2 and DEBUG No matter which of the three options i choose. I assume it has sth to do with the garbage collection that only the last option remains but i cannot figure out how to avoid this. Any help is recommended.", "abstract": ""}, "answers": [{"id": 63044909, "score": -1, "vote": 0, "content": "I know I am late, but I found a messy workaround which gets the job done (tested in Python 3.7) If you use a double lambda (like I said, very messy) you can preserve the value, like so: Step 1: Create the nested lambda statement: Step 2: Use the lambda statement: The send_param method returns the inner most lambda (lambda: print(val)) without executing the statement, until you call the result of send_param which takes no arguments, for example: Only the second line will execute the print statement.", "abstract": ""}, {"id": 57736125, "score": 20, "vote": 0, "content": "Closures in Python capture variables, not values. For example consider: What do you expect the result of calling f() to be? The correct answer is 2, because the lambda f captured the variable x, not its value 1 at the time of creation. Now if for example we write: we created a list of 10 different lambdas, but all of them captured the same variable i, thus calling L[3]() the result will be 9 because the value of variable i at the end of the iteration was 9 (in Python a comprehension doesn't create a new binding for each iteration; it just keeps updating the same binding). A \"trick\" that can be seen often in Python when capturing the value is the desired semantic is to use default arguments. In Python, differently from say C++, default value expressions are evaluated at function definition time (i.e. when the lambda is created) and not when the function is invoked. So in code like: we're declaring a parameter j and setting as default the current value of i at the time the lambda was created. This means that when calling e.g. L[3]() the result will be 3 this time because of the default value of the \"hidden\" parameter (calling L[3](42) will return 42 of course). More often you see the sightly more confusing form where the \"hidden\" parameter has the same name as the variable of which we want to capture the value of.", "abstract": ""}, {"id": 33984811, "score": 41, "vote": 0, "content": "Please read about minimal examples. Without reading your code, I believe you have run into a well known issue addressed in previous questions and answers that needs 2 lines to illustrate.  Names in function bodies are evaluated when the function is executed. prints '2' 3 times because the 3 functions are identical and the 'i' in each is not evaluated until the call, when i == 2.  However, makes three different functions, each with a different captured value, so 0, 1, and 2 are printed.  In your statement add option=option before : to capture the different values of option.  You might want to rewrite as to differentiate the loop variable from the function parameter.  If column changed within the loop, it would need the same treatment.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/68550633/python-unexpected-behaviour-with-lambdas-when-iterating", "keywords": [], "tags": ["python"], "question": {"id": 68550633, "title": "Python - Unexpected behaviour with lambdas when iterating", "content": "I'm looking to create and store a specific function for each key of a dictionary. However, I've noticed that whenever I try to iterate through my set of keys (By creating an iterable then manually iterating, using a comprehension, and by the \"for\" loop), all of the functions turn out the same: Could someone explain why this happens and how to fix this?", "abstract": ""}, "answers": [{"id": 68550666, "score": 1, "vote": 0, "content": "This is a fun little twist in Python.  The lambda there is returning the number object.  By the time the loop ends, the number object has the value 9.  What you need is a trick called \"capturing\": That \"captures\" the value at the point the lambda is defined.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/63123011/lambda-functions-created-in-a-for-loop-being-overwritten", "keywords": [], "tags": ["python", "lambda"], "question": {"id": 63123011, "title": "lambda functions created in a for-loop being overwritten", "content": "Executing the following code results in this output: I don't understand why all functions in the list are getting overwritten? Having only primitive datatypes (floats) in the expression should not lead to any reference problems, should it? Edit: The code uses numpy/scipy for the splines if that matters.", "abstract": ""}, "answers": [{"id": 63123965, "score": 1, "vote": 0, "content": "You can read it from the official python documentation, but in short Consider this what do you think will be printed to console? 99, right? (Yes, it will be 99 in both cases).  See that lambdas behave exactly the same way as regular functions; If the variable is not defined in the function scope, python searches the variable from the parent scope. Notice that after a for loop like this The value of x will be 5. So this is the reason why all the functions you created have the same value (the last one). Apologies for not copy-pasting your example code to my examples. I am writing the answer with my phone so it's easier to just write simplified examples. I hope you'll get the idea from these examples. There are three clean ways for the problem That is, instead of Use The variables local to lambda have zero appended for clarity (will work with just the same variable names). Note that this is pretty much the same as and it would be equally good option to use the def func() syntax inside the for loop. By that I mean, since functions are objects (or: first-class citizens) in python, you can create a function that returns a function. Functions that take functions as arguments or return a function are called higher order functions. You can use this to create a higher order function: or, why not even and the later on just get functions in your loop with This will work since the get_func has its' own scope. The builtin functools has a great helper function called partial which also does just what you want.", "abstract": ""}, {"id": 63123379, "score": 2, "vote": 0, "content": "Your lambda is relying on the definition of m, x0, and b from the enclosing scope, but that dependency is loaded when the lambda is executed, not when it's defined. As such, you're using the values from the final loop in all of your lambdas. You need to store those values at definition time. The simplest approach is to make them default arguments for the lambda (argument defaults being bound at definition time):", "abstract": ""}, {"id": 63123301, "score": -1, "vote": 0, "content": "So, I think I found a way to get this to work. exec gets a bad rep here on SO, but this works and I can't think of another way.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/62414299/python-lambda-functions-defined-in-a-loop-end-up-pointing-to-the-same-operation", "keywords": [], "tags": ["python", "loops", "lambda", "initialization", "switch-statement"], "question": {"id": 62414299, "title": "python lambda functions defined in a loop, end up pointing to the same operation", "content": "I was looking for an algorithm capable of storing and running functions with a flexible number of arguments. I ended up finding a switch/case analogue for python which meets my requirements: Resulting in: Once I implemented this structure to my target code, however, I encountered many issues because my operations are defined via a loop.  As far as I understand it, this is because the lambda functions are not initialised, and they end up pointing to the last operation declared.  This additional code reproduces the issue: Resulting in: This is the result of opD_3 instead of opB_3 I wonder if anyone could please offer any advice, on how to properly declare the lambda functions in the second case or a different code structure to avoid it. Thanks a lot. ", "abstract": ""}, "answers": [{"id": 62480907, "score": 1, "vote": 0, "content": "The functions can be added in the dictionary using their names. When you dispatch a call to an operation, you could compare the received arguments with signature of matched function in the registry.\nThis way you could figure out other arguments for that function from the optional arguments passed in the dispatch call. For example,", "abstract": ""}, {"id": 62472382, "score": 1, "vote": 0, "content": "The problem is to do with scope: each lambda function creates a \"closure\" over the func variable, and can access that variable's current value when the function runs. And because it's not running until the loop is complete, the value it uses is the last one it held in the loop. The solution is therefore to utilise scope to your advantage, by ensuring that each lambda closes over a func variable which only ever holds one value - the value you need. You need a new scope for each iteration of the loop. And the only way Python allows you to create scope is with a function. So the solution will look something like this: I'd be the first to admit that this is a little clumsy, but it should work. The only difference from your code is that I've put the loop body inside a function - then immediately called that function each time. So there's no difference in how it behaves, except for the how the variables are scoped - which is key here. When those lambda function run, they will use the value of function from their immediately enclosing scope, and because off the add_to_dict function having its own scope, that will be a different function for each time through the loop. I would encourage you to look at this Q&A for useful background - it's about Javascript rather than Python, but the scoping mechanisms (at least in \"old-school\" Javascript before ES6) are identical between the two languages, and the underlying issue you have here is identical to the one in this much-asked JS question. Unfortunately many of the solutions that are available in modern Javascript aren't applicable to Python, but this one does - a simple adaptation of the \"Immediately Invoked Function Expression\" (IIFE for short) pattern that's common in JS. And as you can probably tell, I'm personally more experienced with JS than with Python, so I'd be interested to hear if there's a nicer, more idiomatic, Python solution to this problem than what I've done above.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/62429039/lambda-in-loop-stored-in-list-prints-only-the-last-loops-evaluated-value-not-di", "keywords": [], "tags": ["python", "lambda"], "question": {"id": 62429039, "title": "Lambda in loop stored in list, prints only the last loops evaluated value not different values from all loop iterations", "content": "I have a problem with lambdas in a loop. It is hard to explain the problem so I will show it in a short example: as a result of print I get: Despite I would expect [True, False]. \nCould you tell me why it does not work? and how Could I get the result that I expected? I only add that lambdas in a loop are required in my code to define formulas(those formulas are a lot and can be much more complex). Those formulas are defined in one place in the application and executed after many lines below the definition.\nI would be grateful for your help.  ", "abstract": ""}, "answers": [{"id": 62429146, "score": 3, "vote": 0, "content": "Lambdas are evaluated when they are executed.  They are executed when you print them. The only known foo at that time is the one from the last loop. So TestObj(1) is printed twice.  You can verify this by changing your lambda to: You need to \"early\" bind the foo from the loop to the lambda: Full fix: Output: See Is it Pythonic to use list comprehensions for just side effects? regarding using list comprehension sideeffects and why its bad. Related: ", "abstract": ""}, {"id": 62429245, "score": 1, "vote": 0, "content": "The problem is that the foo is merely lexically defined in the lambda, so it is not storing the value of foo from the time when the lambda was created. Instead of a lambda, you could perhaps use a class to generate your callable.  This can then store the associated state, namely the TestObj instance to which foo was pointing: output:", "abstract": ""}, {"id": 62429135, "score": 0, "vote": 0, "content": "For what you're doing you can use a map function. Small example: So for your example: Or using list comprehension:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/40096323/lambda-function-does-not-return-correct-value", "keywords": [], "tags": ["python", "numpy", "lambda"], "question": {"id": 40096323, "title": "Lambda function does not return correct value", "content": "Im trying to make a variant of the Gillespie algorithm, and to determine the reaction propensities Im trying to automatically generate the propensity vector using lambda expressions. However when creating SSA.P all goes wrong. The last loop in the block of code, PROPLOOP, returns two propensities, where the one generated using P_alternative is the correct one. The question is: how do I get the same values for SSA.P as for SSA.P_alternative? output is:", "abstract": ""}, "answers": [{"id": 40096669, "score": 6, "vote": 0, "content": "The issue is that you're creating your lambda functions in a loop, and they refer to the variables i and j that may change as the loop goes on. The lambda doesn't copy the values of i or j when it is created, it just keeps a reference to the namespace that they are defined in. When it uses the variables when it is called later, it looks them up in that namespace. Since your lambdas get called after the loop (and indeed, the whole function) has ended, they all see the final values the variables were given, which is not what you intended. This explains why the two versions of your code give the same output on the last iteration. The final value of i and j is the expected one for the last lambda function. You can work around this issue by making the lambda keep a copy of the current value of i and j when it is defined. The easiest way to do this is with a default argument: The i=i (and j=j where necessary) in the lambda definitions makes the variables arguments of the lambda function with a default value that is the current value of i (and j) in the outer namespace. Since you only pass two arguments when you call the lambda function, the saved default values will be used.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/26578264/why-does-a-lambda-function-change-its-behavior-from-in-the-function-that-generat", "keywords": [], "tags": ["python", "lambda"], "question": {"id": 26578264, "title": "Why does a lambda function change its behavior from in the function that generates it to the main?", "content": "I thought I understood lambda notation (in python) for defining functions, but I'm seeing a strange behavior that I don't understand.  I looked at What do (lambda) function closures capture? and saw something that I think is related but isn't the same. I generate a list of functions inside a function.  Inside that function, the behavior of the functions in the list is as expected.  However, when it's returned to main(), items 1 through 3 of the list all behave as item 3.  I say \"behave as\" because you can see that the functions aren't actually identical -- they're stored at different memory locations. I put in some debugging lines that are commented, which help a little in seeing what the code is doing.  The lambda function depends on an integer, and the value of the integer is as expected inside the function but is the same for list items 1 through 3 in main(). I'd really appreciate if someone could help me understand what's going on here.  Thanks!", "abstract": ""}, "answers": [{"id": 26578377, "score": 1, "vote": 0, "content": "Each time through the loop, the lambda expression creates a function object which contains a reference to ii whose value will looked up when the function is called. Since all the lambdas are evaluated in the same scope, they all contain a reference to the same name ii. The last value assigned to that name comes from the last iteration of the loop, so although the function objects were created in different iterations of the loop, the value that each will see for ii is the same, namely the last value that was obtained from xrange(size). One simple (but slightly awkward) way to avoid this is to pass the value ii as a default value of an argument to the function object, since default values are evaluated at definition time, not call time.", "abstract": ""}, {"id": 26578356, "score": 1, "vote": 0, "content": "In these lines: the lambda object that is created stores references to the matA and ii variables, and when the lambda is executed, it evaluates np.dot(matA[ii], x) using the values that matA and ii have at the time the lambda is called, NOT at the time the lambda was created.  Unfortunately, the lambdas are called after the for loop has finished running, at which point the value of ii will be the last value assigned to it (i.e., size-1), and so all of the lambdas will behave in the way that only the last lambda is expected to behave. There are several ways to get around this.  One way is to store the current value of ii in a scope that only the current lambda can access, and this can be done by creating and immediately calling another lambda wrapped around the \"main\" lambda:", "abstract": ""}]}]