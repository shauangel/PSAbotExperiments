[{"link": "https://stackoverflow.com/questions/2588628/what-is-the-purpose-of-subclassing-the-class-object-in-python", "keywords": [], "tags": ["python", "object", "deprecated", "future-proof", "new-style-class"], "question": {"id": 2588628, "title": "What is the purpose of subclassing the class &quot;object&quot; in Python?", "content": "All the Python built-ins are subclasses of object and I come across many user-defined classes which are too. Why? What is the purpose of the class object? It's just an empty class, right?", "abstract": ""}, "answers": [{"id": 2588667, "score": 62, "vote": 0, "content": "Note: new-style classes are the default in Python 3. Subclassing object is unnecessary there. Read below for more information on usage with Python 2. In short, it sets free magical ponies. In long, Python 2.2 and earlier used \"old style classes\". They were a particular implementation of classes, and they had a few limitations (for example, you couldn't subclass builtin types). The fix for this was to create a new style of class. But, doing this would involve some backwards-incompatible changes. So, to make sure that code which is written for old style classes will still work, the object class was created to act as a superclass for all new-style classes.\nSo, in Python 2.X, class Foo: pass will create an old-style class and class Foo(object): pass will create a new style class. In longer, see Guido's Unifying types and classes in Python 2.2. And, in general, it's a good idea to get into the habit of making all your classes new-style, because some things (the @property decorator is one that comes to mind) won't work with old-style classes.", "abstract": ""}, {"id": 2588677, "score": 13, "vote": 0, "content": "Short answer: subclassing object effectively makes it a new-style class (note that this is unnecessary since automatic in Python 3.x) For the difference between new style classes and old style classes: see this stackoverflow question. For the complete story: see this nice writeup on Python Types and Objects.", "abstract": ""}, {"id": 2588674, "score": 0, "vote": 0, "content": "Python 2.2 introduced \"new style classes\" which had a number of additional features relative to the old style classes which did not subclass object.  Subclasses object was the chosen way to indicate that your class should be a new style class, not an old style one.", "abstract": ""}, {"id": 2588672, "score": 1, "vote": 0, "content": "The short version is that classic classes, which didn't need a superclass, had limitations that couldn't be worked around without breaking a lot of old code.  So they created the concept of new-style classes which subclass from object, and now you can do cool things like define properties, and subclassing dict is no longer an exercise in pain and strange bugs. The details are in section 3.3 of the Python docs: New-style and classic classes.", "abstract": ""}, {"id": 2588669, "score": 4, "vote": 0, "content": "It has to do with the \"new-style\" of classes.  You can read more about it here: http://docs.python.org/tutorial/classes.html#multiple-inheritance and also here: http://docs.python.org/reference/datamodel.html#new-style-and-classic-classes Using new-style classes will allow you to use \"Python's newer, versatile features like __slots__, descriptors, properties, and __getattribute__().\"", "abstract": ""}, {"id": 2588662, "score": 3, "vote": 0, "content": "Right, but it marks the class as a new-style class. Newly developed classes should use the object base because it costs little and future-proofs your code.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/73388831/python-method-that-returns-instance-of-class-or-subclass-while-keeping-subclass", "keywords": [], "tags": ["python", "inheritance", "overwrite"], "question": {"id": 73388831, "title": "Python method that returns instance of class or subclass while keeping subclass attributes", "content": "I'm writing a Python class A with a method square() that returns a new instance of that class with its first attribute squared. For example: I would like to use this method in a subclass B so that it returns an instance of B with x squared but all additional attributes of B unchanged (i. e. taken from the instance). I can get it to work by overwriting square() like this: If I don't overwrite the square() method, this little code example will fail because I need to pass a value for y in the constructor of B: Overwriting the method once isn't a problem. But A potentially has multiple methods similar to square() and there might be more sub(sub)classes. If possible, I would like to avoid overwriting all those methods in all those subclasses. So my question is this:\nCan I somehow implement the method square() in A so that it returns a new instance of the current subclass with x squared and all other attributes it needs for the constructor taken from self (kept constant)? Or do I have to go ahead and overwrite square() for each subclass? Thanks in advance!", "abstract": ""}, "answers": [{"id": 73388921, "score": 1, "vote": 0, "content": "I'd suggest implementing .__copy__() (and possibly .__deepcopy__ as well) methods for both classes. Then your squared can be simple method: It will work with inheritance, assuming all child classes have correctly implemented __copy__ method. EDIT: fixed typo with call to copy() Full working example:", "abstract": ""}, {"id": 73389030, "score": 0, "vote": 0, "content": "check if the object contains y then return the right class instance:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/71788325/when-should-i-make-a-subclass-instead-of-instances-of-a-class", "keywords": [], "tags": ["python", "oop"], "question": {"id": 71788325, "title": "When should I make a subclass instead of instances of a class?", "content": "How do I know when to make something a class instead of an instance of a class? For example: If I'm creating a space game (I'm not), and I want the environment to be the Universe, I'd write: Now let's say I'd like to fill my Universe with Galaxies, so I'd make a Galaxy subclass, with size and name parameters: Next, I'd like to make Planets. If this were the case, I should make a subclass of the Galaxy subclass right? From here I'd like to make the Planet types, or \"families\". What's the best way to go about this? Another subclass of a subclass? Each planet will contain resources that are unique to that family of planets. Should I then make this:", "abstract": ""}, "answers": [{"id": 71799115, "score": 0, "vote": 0, "content": "This doesnt make sense for the reasons listed in the other answers (the car one is the one I like). However it could make sense to have a base class, say SpaceObject (bogus name on purpose, naming is hard). This would have a position and size field.  Those are common to Galaxy, Planet, etc\u2026 In general, when you strongly suspect you\u2019ll have commonality between object classes, create a base class and then gradually move fields/methods into it, from specialized subclasses as the case for reuse becomes apparent.  Don't overdo this but it can be useful. (Universe is harder to pin down in this respect). The subclasses could also track a \u201clocated_in\u201d class. Galaxy-> Universe. About planets and subclasses\u2026 That\u2019s one possibility, to have subclasses (via OOP inheritance).  Another is to use OOP composition instead.  Planet has size, mass, temperature, gravity numeric fields.  Plus say an Atmosphere field. And Core field. Hard to say with planets, but if you were modelling say Dogs, class hierarchies are quickly a lousy way to track size, hair type, barking, etc\u2026 across breeds.", "abstract": ""}, {"id": 71788429, "score": 2, "vote": 0, "content": "So, your first problem here is trying to make a class hierarchy of something that is fundamentally not suitable for it. When you're inheriting from another class, ask yourself \"Is a SubClass a type of Class?\". In your case, \"Is a Galaxy a type of Universe?\" and \"Is a Planet a type of Galaxy?\" are both clearly false. In the cases you've got here, all the classes should contain the lower level types; a Universe might contain a list of Galaxys, which in turn contain a list of Planets. I don't know exactly what you mean by a PlanetType here (it seems perfectly possible for a Planet to have an attribute, possibly an enum.Enum, describing the type and a list of resources), so I doubt it's a case for a subclass, but if it really is useful (e.g. you need methods that appear on all Planets but behave differently by the type), it might be reasonable to declare: or the like, since \"Is a GasGiant a type of Planet?\" does in fact have an answer of \"Yes\". That said, I'd be wary of changing the prototype of the initializer even then; look up the Liskov substitution principle. Basically, you never want to be in a scenario where something expects a Planet (that might really be one of the subclasses) but only works on some of the three Planet classes, breaking if passed a different one.", "abstract": ""}, {"id": 71788461, "score": 5, "vote": 0, "content": "So this is not specific to Python, it's more of a core idea of OOP(Object Oriented Programming) How do I know when to make something a class instead of an instance of a class? Answer : In your example Universe is the superclass , and you want to create the notion of Planets. If Planet inherits (subclass) from Universe that means they have an \"is\" relationship. I'm going to bring another popular example here to illustrate my point. Let's say you have a class Car. Maserati would be a subclass(would inherit) from this superclass because a maserati IS a Car.\nIf you wanted to represent Wheels as a class then it wouldn't make sense to say that Wheels IS a Car. A car HAS wheels. So Wheels Class should be an instance variable in Car.\nSo back to your example. A Universe HAS galaxies and a Galaxy HAS planets. But a planet IS NOT a galaxy and a galaxy IS NOT a Universe.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/70927984/initialize-subclass-instance-when-creating-new-base-class-instance", "keywords": [], "tags": ["python", "class", "abstract-base-class"], "question": {"id": 70927984, "title": "Initialize subclass instance when creating new Base class instance", "content": "TLDR: Is it possible to have calling/instantiating the base class actually return an initialized subclass instance? Consider this Animal base class and Cat and Dog subclasses: This works as intended: Now, I want to extend this so that calling of the Animal class should return one of its subclasses, and namely the first that does not raise an error. So, I want c3 = Animal(0.7) to return a Cat instance. I know how to return an instance from a subclass when instantiating the base class, but only if it can be determined before running __init__, which one it is. So, this does not work... ...because the ValueError is only raised when the instance is already created and returned: Is there a way to achieve this? This works but is detached from the classes and feels badly integrated / highly coupled. EDIT:", "abstract": ""}, "answers": [{"id": 70956927, "score": 0, "vote": 0, "content": "@ElRudi: As requested, solution using Factory pattern. While it is probably possible to automatically detect all the classes inheriting from Animal to avoid having to declare the list of possible animals when creating factory, I don't think it's a good idea and I didn't bother with doing that.", "abstract": ""}, {"id": 70928497, "score": 0, "vote": 0, "content": "This is indeed a weird requirement, but it can be met by customization of __new__: You can now successfully write: BTW, if all subclasses raise an error, the last one will be used (and will raise its own error)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64447317/check-if-an-item-is-an-instance-but-not-a-subclass", "keywords": [], "tags": ["python", "python-3.x", "class", "isinstance"], "question": {"id": 64447317, "title": "Check if an item is an instance but not a subclass", "content": "How can you check if an object is an instance of a class but not any of its subclasses (without knowing the names of the subclasses)?\nSo if I had the below code: what would go in the #code space that would produce the output?: Because issubclass() and isinstance() always return True.", "abstract": ""}, "answers": [{"id": 64459232, "score": 1, "vote": 0, "content": "The object.__class__ attribute is a reference to the exact class of an object, so you only need to compare that with your argument Don't name variables class, its a keyword and won't work, use klassor typ instead. Also, the variable name object shadows the build in object, so use something like obj. I personally like the .__class__ variant more, but the more \"pythonic\" variant would probably be because it doesn't access any dunder (__) attributes.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/56908849/when-you-create-an-instance-of-a-subclass-an-instance-of-its-superclass-is-also", "keywords": [], "tags": ["python", "inheritance"], "question": {"id": 56908849, "title": "When you create an instance of a subclass an instance of its superclass is also created, is it possible to access it?", "content": "I was learning about inheritance in python and it is made very clear in python that once you create an instance of a subclass and instance of the corresponding superclass is also created as expected when the following piece of code is executed \"Dog created\" and \"Beagle created\" are both printed on the console.  So I was wondering how could I access this Dog object that is created?", "abstract": ""}, "answers": [{"id": 56909081, "score": 0, "vote": 0, "content": "That is not what happens. A single instance is created, that is at the same time a Beagle and a Dog. The call to the method in the Dog class inside Beagle.__init__  just runs the code in Dog as well - A subclass, also being an instance of the superclass, have to provide for the code on the ancestors to be run. (That is more usually done through the use of super() than hardcoding the superclass name, though). Moreover, in statically typed languages, usually you can \"cast\" a subclass to one of its superclasses - so that you can create  a \"Beagle\", cast it to \"Dog\", and call directly \"Dog\" methods on the resulting object - that is not the case in Python - it is not ordinarily possible to 'cast' an object to its superclass. rahter, any call that would accept an object of the type of the superclass will also take in objects objects of any of its subclasses. The super(...) call can be used to explicitly invoke methods or attributes of the superclasses from outside the class methods as well - so, if you declare the classes as: You can do this (output from the interactive console, after pasting the snippet above): So you can use Dog's methods, but it is not a separate instance! \n(Also note that when used out of a subclass method body, super() requires the class and instance parameters to be given explicitly)", "abstract": ""}, {"id": 56908874, "score": 1, "vote": 0, "content": "That's not how it works. An instance of Dog is not \"also\" created. There is one instance, that is both Dog and Beagle; because a Beagle \"is-a\" Dog. The point of inheritance is that any attribute defined on Dog is also available on Beagle (unless you override it). ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/55994337/why-a-subclass-is-instance-of-object", "keywords": [], "tags": ["python", "instance", "subclass"], "question": {"id": 55994337, "title": "Why a subclass is instance of object?", "content": "As I know, subclass should be subclass of object, but why it also is an instance of object? What's more, I quote from @prosti answer that isinstance Returns a Boolean stating whether the object is an instance or subclass of another object. But the examples on the same link shows Seems it means a class1 is an instance of class2, if and only if class2 is object, right?", "abstract": ""}, "answers": [{"id": 55995798, "score": 1, "vote": 0, "content": "Not a bad question. By definition, isinstance: Returns a Boolean stating whether the object is an instance or subclass of another object. On the other hand issubclass: Returns a Bool type indicating whether an object is a subclass of a class. With additional remark that a class is considered a subclass of itself. Update: Seems it means a class1 is an instance of class2, if and only if class2 is object, right? You get answers by testing, and logic is super simple. A class is a class and object is an instance of a class. You can check the code in case you really need to understand the implementation. Also you may find the test cases if you are a geek. The object must be instantiated in order to classify for True in the following examples:  Also, some examples in here are Python3 specific, if you are Python2 guy, you must know that you should be more explicit and write: The (object) part is a must if you write Python agnostic code.\nLastly check Standard on Overloading isinstance() and issubclass() but have in mind standards are \"live\" and may update in the future. Lastly you may check this on classes objects relation.", "abstract": ""}, {"id": 55994382, "score": 1, "vote": 0, "content": "In python3 all classes derive from object thus and are identical.\nRegarding why isinstance(A, object) returns True\nsee the following code ", "abstract": ""}, {"id": 55994391, "score": 1, "vote": 0, "content": "Because everything in python is treated as an object, which is a nicer way to say, every object is an instance of object in python! If you think about it, it makes total sence,since python is an object oriented language, and because of that, it is be normal and expected that every value is an object", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/52500506/convert-object-from-class-to-subclass-automatically", "keywords": [], "tags": ["python", "class", "object", "subclass"], "question": {"id": 52500506, "title": "convert object from class to subclass automatically", "content": "I have to following problem. I have a data input, in which a type (animal in the following example) is defined. Based on this type, I need different subclasses, because I want to have different attributes, based on the type. Here is an example: I would like to convert the pet objects to a dog or a cat resp., based on the type argument automatically. The last point is crucial, since there will be many pets and I cannot read the type by hand and use the corresponding subclass explicitly.\nIs there a way to do this? Thanks in advance", "abstract": ""}, "answers": [{"id": 52501230, "score": 1, "vote": 0, "content": "What you want is sometimes called a virtual constructor because subclass instances get created by the base class constructor. This is often handled by using some sort of \"factory\" function.  However, one thing I don't like about most factory function implementations is that they often are implemented in a way that requires the factory function to be manually modified every time another subclass is added to the class hierarchy. Better implementations can reduce that to simply one call to some other \"helper\" function to register each subclass. In Python such a function can be implemented by overriding the base class' default __new__() method (effectively making it the static factory function). Then, within that method, use can be made of a class object's __subclasses__() method to find them all without requiring a manual call to some \"register\" helper method first. Thus making adding a subclass to the virtually-constructed class hierarchy largely automatic.  Here's how to apply these concepts to the example classes in your question. Note too that I've also modified your code so it closely follows the PEP 8 - Style Guide for Python Code guidelines more closely. This is basically just an adaptation of the code in my answer to a another question.", "abstract": ""}, {"id": 52501243, "score": 1, "vote": 0, "content": "You can create a class method for pet that iterates through its subclasses to find the one with name matching the given type, and then instantiate the subclass with the given attribute dict: so that: will output:", "abstract": ""}, {"id": 52501301, "score": 1, "vote": 0, "content": "First off, don't just pass around dicts; that hides the actual required arguments, and uglifies the code. Use regular names for arguments recognized on each initializers, capture the rest as **kwargs and pass them up the initializer chain. Secondly, to accomplish your goal, make an alternate constructor as a classmethod on Pet and use that. classmethod's can return a new object, and they aren't restricted to operating on an already created object like __init__ (__new__ could replace __init__ to achieve a similar effect, but it's more fiddly, and generally less obvious): Usage changes only slightly, from: to: and when you need to construct the object directly, you can pass normal arguments to the normal constructor, rather than constructing a dict that's otherwise unused.", "abstract": ""}, {"id": 52500694, "score": 0, "vote": 0, "content": "Assuming you have the str of type in the object (in your case type): Not sure if globals is the right thing to use tbh", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/44329238/python-data-model-subclass-vs-instance", "keywords": [], "tags": ["python", "python-2.7", "python-3.x"], "question": {"id": 44329238, "title": "Python - Data model - Subclass Vs Instance", "content": "For user-defined type X,  Q) How X behaves as both sub class and instance of object? Q) How int behave as both sub class and instance of object? Q) How type can be both, sub class and instance of object? object not being sub class but instance of type, which makes sense int not being sub class but instance of type, makes sense. also makes sense. Edit: here it says, The major motivation for introducing new-style classes is to provide a unified object model with a full meta-model.  Q) How to understand the meaning of unified object model?  Q) What is meta-model?  Q) What does it mean to say, type instance of type?", "abstract": ""}, "answers": [{"id": 44329912, "score": 4, "vote": 0, "content": "It might be easier to understand diagramatically:  I'm using a red arrow from A to B to mean A.__class__ == B, and a black arrow to mean B in A.__bases__. Every object in python must have a red arrow, but only instances of type have a black arrow.  Roughly speaking issubclass(x, y) means \"start at x, follow black arrows until you reach y\" isinstance(x, y) means \"start at x, follow one red arrow, and then apply issubclass\" Edit: Another example with metaclasses: source", "abstract": ""}, {"id": 44329720, "score": 1, "vote": 0, "content": "Everything in Python is an object and isinstance(whatever, object) == True is just a way of saying this. Therefore regular objects and any types are instances of object by design. Some classes inherits object to provide additional functionality (in Py3k all of them, really), for example type is a subclass of object that yields another types as instances and, say, Int is a subclass of type (and object) that tailored for instantiation integers.\nSo you might ask - why there is a python object object, why this is even a thing that you can pass around and so on. The answer is - mro, dude. It turns out that type object provides a set of handy descriptors, that are invoked as defaults for a ton of other types (since types ultimately inherit majority of functionality from object).", "abstract": ""}, {"id": 44329518, "score": 6, "vote": 0, "content": "All three of your questions come down to \"how can X be both a subclass and instance of object\". The answer is simple: everything is a subclass of object. Classes are objects (=instances of object), and hence, subclasses (including subclasses of object) are also instances of object.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/27475063/test-an-object-is-a-subclass-of-the-type-of-another-instance", "keywords": [], "tags": ["python", "class", "inheritance", "python-3.4"], "question": {"id": 27475063, "title": "Test an object is a subclass of the type of another instance", "content": "I have this code: Now I want to check if obj2 and obj3 are instances of classes that are subclasses of obj1 as well as simply subclasses of of Item. Here is what I understand, I know that I can use the isinstance() to find if obj2 is Sub. and I know that I can use issubclass(Sub, Item). But let's say I didn't know what class obj2 was. I tried using issubclass(type(obj2),Item) but that doesn't work, because type() returns a separate object that I don't really understand the workings of. And this is just one problem, although I figure that the answer to this question will help me solve some of the other problems that I am having. Also I have tried using some of the special attributes to do this such as __class__ but I can't figure out how to do that either.", "abstract": ""}, "answers": [{"id": 27475071, "score": 40, "vote": 0, "content": "You'd need to extract the type of obj with the type() function: Note that the second argument is the class, the first is the instance to test. type() is returning the actual class object here, not any separate object. issubclass() works just fine for your usecase: Demo: Note that if you re-defined the classes here, existing instances will not be updated to point to the new class objects. If type(obj2) doesn't work for you, then that means that the class used to produce it is not the same you are testing with now. You can test if this the case by testing your assumptions; validate that the classes and instances are still in sync, for example:", "abstract": ""}]}]