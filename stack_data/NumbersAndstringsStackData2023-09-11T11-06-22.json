[{"link": "https://stackoverflow.com/questions/58403537/what-can-i-use-for-input-conversion-instead-of-scanf", "keywords": [], "tags": ["c", "scanf"], "question": {"id": 58403537, "title": "What can I use for input conversion instead of scanf?", "content": "I have very frequently seen people discouraging others from using scanf and saying that there are better alternatives. However, all I end up seeing is either \"don't use scanf\" or \"here's a correct format string\", and never any examples of the \"better alternatives\" mentioned. For example, let's take this snippet of code: This reads the whitespace that was left in the input stream after the last conversion. The usual suggested solution to this is to use: or to not use scanf. Since scanf is bad, what are some ANSI C options for converting input formats that scanf can usually handle (such as integers, floating-point numbers, and strings) without using scanf?", "abstract": ""}, "answers": [{"id": 58405726, "score": 11, "vote": 0, "content": "In this answer I'm going to assume that you are reading and\ninterpreting lines of text.\nPerhaps you're prompting the user, who is typing something and\nhitting RETURN.  Or perhaps you're reading lines of structured\ntext from a data file of some kind. Since you're reading lines of text, it makes sense to organize\nyour code around a library function that reads, well, a line of\ntext.\nThe Standard function is fgets(), although there are others (including getline).  And then the next step is to interpret\nthat line of text somehow. Here's the basic recipe for calling fgets to read a line of\ntext: This simply reads in one line of text and prints it back out.\nAs written it has a couple of limitations, which we'll get to in\na minute.  It also has a very great feature: that number 512 we\npassed as the second argument to fgets is the size of the array\nline we're asking fgets to read into.  This fact -- that we can\ntell fgets how much it's allowed to read -- means that we can\nbe sure that fgets won't overflow the array by reading too much\ninto it. So now we know how to read a line of text, but what if we really\nwanted to read an integer, or a floating-point number, or a\nsingle character, or a single word?  (That is, what if the\nscanf call we're trying to improve on had been using a format\nspecifier like %d, %f, %c, or %s?) It's easy to reinterpret a line of text -- a string -- as any of these things.\nTo convert a string to an integer, the simplest (though\nimperfect) way to do it is to call atoi().\nTo convert to a floating-point number, there's atof().\n(And there are also better ways, as we'll see in a minute.)\nHere's a very simple example: If you wanted the user to type a single character (perhaps y or\nn as a yes/no response), you can literally just grab the first\ncharacter of the line, like this: (This ignores, of course, the possibility that the user typed a\nmulti-character response; it quietly ignores any extra characters\nthat were typed.) Finally, if you wanted the user to type a string definitely not containing\nwhitespace, if you wanted to treat the input line as the string \"hello\" followed by something else (which is what\nthe scanf format %s would have done), well, in that case, I\nfibbed a little, it's not quite so easy to reinterpret the line\nin that way, after all, so the answer to that part of the question will have\nto wait for a bit. But first I want to go back to three things I skipped over. (1) We've been calling to read into the array line, and where 512 is the size of the\narray line so fgets knows not to overflow it.  But to make\nsure that 512 is the right number (especially, to check if maybe\nsomeone tweaked the program to change the size), you have to read\nback to wherever line was declared.  That's a nuisance, so\nthere are two much better ways to keep the sizes in sync.\nYou could, (a) use the preprocessor to make a name for the size: Or, (b) use C's sizeof operator: (2) The second problem is that we haven't been checking for\nerror.  When you're reading input, you should always check for\nthe possibility of error.  If for whatever reason fgets can't\nread the line of text you asked it to, it indicates this by\nreturning a null pointer.  So we should have been doing things like Finally, there's the issue that in order to read a line of text,\nfgets reads characters and fills them into your array until it\nfinds the \\n character that terminates the line, and it fills\nthe \\n character into your array, too.  You can see this if\nyou modify our earlier example slightly: If I run this and type \"Steve\" when it prompts me, it prints out That \" on the second line is because the string it read and\nprinted back out was actually \"Steve\\n\". Sometimes that extra newline doesn't matter (like when we called\natoi or atof, since they both ignore any extra non-numeric\ninput after the number), but sometimes it matters a lot.  So\noften we'll want to strip that newline off.  There are several\nways to do that, which I'll get to in a minute.  (I know I've been\nsaying that a lot.  But I will get back to all those things, I promise.) At this point, you may be thinking: \"I thought you said scanf\nwas no good, and this other way would be so much better.\nBut fgets is starting to look like a nuisance.\nCalling scanf was so easy!  Can't I keep using it?\" Sure, you can keep using scanf, if you want.  (And for really\nsimple things, in some ways it is simpler.)  But, please, don't\ncome crying to me when it fails you due to one of its 17 quirks\nand foibles, or goes into an infinite loop because of input your\ndidn't expect, or when you can't figure out how to use it to do\nsomething more complicated.  And let's take a look at fgets's\nactual nuisances: You always have to specify the array size.  Well, of course,\nthat's not a nuisance at all -- that's a feature, because buffer\noverflow is a Really Bad Thing. You have to check the return value.  Actually, that's a wash,\nbecause to use scanf correctly, you have to check its return\nvalue, too. You have to strip the \\n back off.  This is, I admit, a true\nnuisance.  I wish there were a Standard function I could point\nyou to that didn't have this little problem.  (Please nobody\nbring up gets.)  But compared to scanf's 17 different\nnuisances, I'll take this one nuisance of fgets any day. So how do you strip that newline?  There are many ways: (a) Obvious way: (b) Tricky & compact way: Unfortunately this doesn't work quite right on empty lines. (c) Another compact and mildly obscure way: And there are other ways as well.  Me, I always just use (a), since it's simple & obvious, if less than concise.\nSee this question, or this question, for more (much more) on stripping the \\n from what fgets gives you. And now that that's out of the way, we can get back to another\nthing I skipped over: the imperfections of atoi() and atof().\nThe problem with those is they don't give you any useful\nindication of success or failure: they quietly ignore\ntrailing nonnumeric input, and they quietly return 0 if there's\nno numeric input at all.  The preferred alternatives -- which\nalso have certain other advantages -- are strtol and strtod.\nstrtol also lets you use a base other than 10, meaning you can\nget the effect of (among other things) %o or %x with scanf.\nBut showing how to use these functions correctly is a story in itself,\nand would be too much of a distraction from what is already turning\ninto a pretty fragmented narrative, so I'm not going to say\nanything more about them now. The rest of the main narrative concerns input you might be trying\nto parse that's more complicated than just a single number or\ncharacter.  What if you want to read a line containing two\nnumbers, or multiple whitespace-separated words, or specific\nframing punctuation?  That's where things get interesting, and\nwhere things were probably getting complicated if you were trying\nto do things using scanf, and where there are vastly more\noptions now that you've cleanly read one line of text using fgets,\nalthough the full story on all those options could probably fill\na book, so we're only going to be able to scratch the surface here. My favorite technique is to break the line up into\nwhitespace-separated \"words\", then do something further with each\n\"word\".  One principal Standard function for doing this is\nstrtok (which also has its issues, and which also rates a whole\nseparate discussion).  My own preference is a dedicated function\nfor constructing an array of pointers to each broken-apart\n\"word\", a function I describe in\nthese course notes.\nAt any rate, once you've got \"words\", you can further process\neach one, perhaps with the same atoi/atof/strtol/strtod\nfunctions we've already looked at. Paradoxically, even though we've been spending a fair amount of\ntime and effort here figuring out how to move away from scanf,\nanother fine way to deal with the line of text we just read with\nfgets is to pass it to sscanf.  In this way, you end up with\nmost of the advantages of scanf, but without most of the\ndisadvantages. If your input syntax is particularly complicated, it might be appropriate to use a \"regexp\" library to parse it. Finally, you can use whatever ad hoc parsing solutions suit\nyou.  You can move through the line a character at a time with a\nchar * pointer checking for characters you expect.  Or you can\nsearch for specific characters using functions like strchr or strrchr,\nor strspn or strcspn, or strpbrk.  Or you can parse/convert\nand skip over groups of digit characters using the strtol or\nstrtod functions that we skipped over earlier. There's obviously much more that could be said, but hopefully\nthis introduction will get you started.", "abstract": ""}, {"id": 73915292, "score": 0, "vote": 0, "content": "One of the most common uses of scanf is to read a single int as input from the user. Therefore, I will write an answer which focusses on this one problem only. Here is an example of how scanf is commonly used for reading an int from the user: Using scanf in this manner has several problems: The function scanf will not always read a whole line of input. If the input conversion fails due to the user entering bad input such as abc, then the bad input will be left on the input stream. If this bad input is not discarded afterwards, then all further calls to scanf with the %d format specifier will immediately fail, without waiting for the user to enter further input. This may cause an infinite loop. Even if the input conversion succeeds, any trailing bad input will be left on the input stream. For example, if the user enters 6abc, then scanf will successfully convert the 6, but leave abc on the input stream. If this input is not discarded, then we will once again have the problem of all further calls to scanf with the %d format specifier immediately failing, which may cause an infinite loop. Even in the case of the input succeeding and the user not entering any trailing bad input, the mere fact that scanf generally leaves the newline character on the input stream can cause trouble, as demonstrated in this question. Another issue with using scanf with the %d format spcifier is that if the result of the conversion is not representable as an int (e.g. if the result is larger than INT_MAX), then, according to \u00a77.21.6.2 \u00b610 of the ISO C11 standard, the behavior of the program is undefined, which means that you cannot rely on any specific behavior. In order to solve all of the issues mentioned above, it is generally better to use the function fgets, which will always read an entire line of input at once, if possible. This function will read the input as a string. After doing this, you can use the function strtol to attempt to convert the string to an integer. Here is an example program: However, this code has the following issues: It does not check whether the input line was too long to fit into the buffer. It does not check whether the converted number is representable as an int, for example whether the number is too large to be stored in an int. It will accept 6abc as valid input for the number 6. This is not as bad as scanf, because scanf will leave abc on the input stream, whereas fgets will not. However, it would probably still be better to reject the input instead of accepting it. All of these issues can be solved by doing the following: Issue #1 can be solved by checking Issue #2 can be solved by checking whether the function strtol set errno to the value of the macro constant ERANGE, to determine whether the converted value is representable as a long. In order to determine whether this value is also representable as an int, the value returned by strtol should be compared against INT_MIN and INT_MAX. Issue #3 can be solved by checking all remaining characters on the line. Since strtol accepts leading whitespace characters, it would probably also be appropriate to accept trailing whitespace characters. However, if the input contains any other trailing characters, the input should probably be rejected. Here is an improved version of the code, which solves all of the issues mentioned above and also puts everything into a function named get_int_from_user. This function will automatically reprompt the user for input, until the input is valid. This program has the following behavior:", "abstract": ""}, {"id": 58405772, "score": 10, "vote": 0, "content": "What can I use to parse input instead of scanf? Instead of scanf(some_format, ...), consider fgets() with sscanf(buffer, some_format_and %n, ...) By using \" %n\", code can simply detect if all the format was successfully scanned and that no extra non-white-space junk was at the end.", "abstract": ""}, {"id": 58403955, "score": 68, "vote": 0, "content": "fgets is for getting the input. sscanf is for parsing it afterwards. scanf tries to do both at the same time. That's a recipe for trouble. Read first and parse later. The main problem is that scanf was never intended to deal with user input. It's intended to be used with \"perfectly\" formatted data. I quoted the word \"perfectly\" because it's not completely true. But it is not designed to parse data that are as unreliable as user input. By nature, user input is not predictable. Users misunderstands instructions, makes typos, accidentally press enter before they are done etc. One might reasonably ask why a function that should not be used for user input reads from stdin. If you are an experienced *nix user the explanation will not come as a surprise but it might confuse Windows users. In *nix systems, it is very common to build programs that work via piping, which means that you send the output of one program to another by piping the stdout of the first program to the stdin of the second. This way, you can make sure that the output and input are predictable. During these circumstances, scanf actually works well. But when working with unpredictable input, you risk all sorts of trouble. So why aren't there any easy-to-use standard functions for user input? One can only guess here, but I assume that old hardcore C hackers simply thought that the existing functions were good enough, even though they are very clunky. Also, when you look at typical terminal applications they very rarely read user input from stdin. Most often you pass all the user input as command line arguments. Sure, there are exceptions, but for most applications, user input is a very minor thing. First of all, gets is NOT an alternative. It's dangerous and should NEVER be used. Read here why: Why is the gets function so dangerous that it should not be used? My favorite is fgets in combination with sscanf. I once wrote an answer about that, but I will re-post the complete code. Here is an example with decent (but not perfect) error checking and parsing. It's good enough for debugging purposes. I don't particularly like asking the user to input two different things on one single line. I only do that when they belong to each other in a natural way. Like for instance printf(\"Enter the price in the format <dollars>.<cent>: \"); fgets(buffer, bsize, stdin); and then use sscanf(buffer \"%d.%d\", &dollar, &cent). I would never do something like printf(\"Enter height and base of the triangle: \"). The main point of using fgets below is to encapsulate the inputs to ensure that one input does not affect the next. If you do a lot of these, I could recommend creating a wrapper that always flushes: Doing like this will eliminate a common problem, which is the trailing newline that can mess with the nest input. But it has another issue, which is if the line is longer than bsize. You can check that with if(buffer[strlen(buffer)-1] != '\\n'). If you want to remove the newline, you can do that with buffer[strcspn(buffer, \"\\n\")] = 0. In general, I would advise to not expect the user to enter input in some weird format that you should parse to different variables. If you want to assign the variables height and width, don't ask for both at the same time. Allow the user to press enter between them. Also, this approach is very natural in one sense. You will never get the input from stdin until you hit enter, so why not always read the whole line? Of course this can still lead to issues if the line is longer than the buffer. Did I remember to mention that user input is clunky in C? :) To avoid problems with lines longer than the buffer you can use a function that automatically allocates a buffer of appropriate size, you can use getline(). The drawback is that you will need to free the result afterwards. This function is not guaranteed to exist by the standard, but POSIX has it. You could also implement your own, or find one on SO. How can I read an input string of unknown length? If you're serious about creating programs in C with user input, I would recommend having a look at a library like ncurses. Because then you likely also want to create applications with some terminal graphics. Unfortunately, you will lose some portability if you do that, but it gives you far better control of user input. For instance, it gives you the ability to read a key press instantly instead of waiting for the user to press enter. Here is a rant about scanf: https://web.archive.org/web/20201112034702/http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html", "abstract": ""}, {"id": 58403538, "score": 103, "vote": 0, "content": "The most common ways of reading input are: using fgets with a fixed size, which is what is usually suggested, and using fgetc, which may be useful if you're only reading a single char. To convert the input, there are a variety of functions that you can use: strtoll, to convert a string into an integer strtof/d/ld, to convert a string into a floating-point number sscanf, which is not as bad as simply using scanf, although it does have most of the downfalls mentioned below There are no good ways to parse a delimiter-separated input in plain ANSI C. Either use strtok_r from POSIX or strtok, which is not thread-safe. You could also roll your own thread-safe variant using strcspn and strspn, as strtok_r doesn't involve any special OS support. It may be overkill, but you can use lexers and parsers (flex and bison being the most common examples). No conversion, simply just use the string Since I didn't go into exactly why scanf is bad in my question, I'll elaborate: With the conversion specifiers %[...] and %c, scanf does not eat up whitespace. This is apparently not widely known, as evidenced by the many duplicates of this question. There is some confusion about when to use the unary & operator when referring to scanf's arguments (specifically with strings). It's very easy to ignore the return value from scanf. This could easily cause undefined behavior from reading an uninitialized variable. It's very easy to forget to prevent buffer overflow in scanf. scanf(\"%s\", str) is just as bad as, if not worse than, gets. You cannot detect overflow when converting integers with scanf. In fact, overflow causes undefined behavior in these functions.", "abstract": ""}, {"id": 58419818, "score": 5, "vote": 0, "content": "Here is an example of using flex to scan a simple input, in this case a file of ASCII floating point numbers that might be in either US (n,nnn.dd) or European (n.nnn,dd) formats. This is just copied from a much larger program, so there may be some unresolved references:", "abstract": ""}, {"id": 58414919, "score": -6, "vote": 0, "content": "Other answers give the right low-level details, so I'll limit myself to a higher-level: First, analyse what you expect each input line to look like.  Try to describe the input with a formal syntax - with luck, you will find it can be described using a regular grammar, or at least a context-free grammar.  If a regular grammar suffices, then you can code up a finite-state machine which recognizes and interprets each command-line one character at a time.  Your code will then read a line (as explained in other replies), then scan the chars in the buffer through the state-machine.  At certain states you stop and convert the substring scanned thus far to a number or whatever.  You can probably 'roll your own' if it is this simple; if you find you require a full context-free grammar you are better off figuring out how to use existing parsing tools (re: lex and yacc or their variants).", "abstract": ""}, {"id": 58405311, "score": 8, "vote": 0, "content": "Let's state the requirements of parsing as: valid input must be accepted (and converted into some other form) invalid input must be rejected when any input is rejected, it is necessary to provide the user with a descriptive message that explains (in clear \"easily understood by normal people who are not programmers\" language) why it was rejected (so that people can figure out how to fix the problem) To keep things very simple, lets consider parsing a single simple decimal integer (that was typed in by the user) and nothing else. Possible reasons for the user's input to be rejected are: Let's also define \"input contained unacceptable characters\" properly; and say that: From this we can determine that the following error messages are needed: From this point we can see that a suitable function to convert a string into an integer would need to distinguish between very different types of errors; and that something like \"scanf()\" or \"atoi()\" or \"strtoll()\" is completely and utterly worthless because they fail to give you any indication of what was wrong with the input (and use a completely irrelevant and inappropriate definition of what is/isn't \"valid input\"). Instead, lets start writing something that isn't useless: To meet the stated requirements; this convertStringToInteger() function is likely to end up being several hundred lines of code all by itself. Now, this was just \"parsing a single simple decimal integer\". Imagine if you wanted to parse something complex; like a list of \"name, street address, phone number, email address\" structures; or maybe like a programming language. For these cases you might need to write thousands of lines of code to create a parse that isn't a crippled joke. In other words... What can I use to parse input instead of scanf? Write (potentially thousands of lines) of code yourself, to suit your requirements.", "abstract": ""}, {"id": 58403935, "score": 22, "vote": 0, "content": "scanf is awesome when you know your input is always well-structured and well-behaved. Otherwise... IMO, here are the biggest problems with scanf: Risk of buffer overflow - if you do not specify a field width for the %s and %[ conversion specifiers, you risk a buffer overflow (trying to read more input than a buffer is sized to hold).  Unfortunately, there's no good way to specify that as an argument (as with printf) - you have to either hardcode it as part of the conversion specifier or do some macro shenanigans.   Accepts inputs that should be rejected - If you're reading an input with the %d conversion specifier and you type something like 12w4, you would expect scanf to reject that input, but it doesn't - it successfully converts and assigns the 12, leaving w4 in the input stream to foul up the next read. So, what should you use instead? I usually recommend reading all interactive input as text using fgets - it allows you to specify a maximum number of characters to read at a time, so you can easily prevent buffer overflow: One quirk of fgets is that it will store the trailing newline in the buffer if there's room, so you can do an easy check to see if someone typed in more input than you were expecting: How you deal with that is up to you - you can either reject the whole input out of hand, and slurp up any remaining input with getchar: Or you can process the input you got so far and read again.  It depends on the problem you're trying to solve. To tokenize the input (split it up based on one or more delimiters), you can use strtok, but beware - strtok modifies its input (it overwrites delimiters with the string terminator), and you can't preserve its state (i.e., you can't partially tokenize one string, then start to tokenize another, then pick up where you left off in the original string).  There's a variant, strtok_s, that preserves the state of the tokenizer, but AFAIK its implementation is optional (you'll need to check that __STDC_LIB_EXT1__ is defined to see if it's available).   Once you've tokenized your input, if you need to convert strings to numbers (i.e., \"1234\" => 1234), you have options.  strtol and strtod will convert string representations of integers and real numbers to their respective types.  They also allow you to catch the 12w4 issue I mentioned above - one of their arguments is a pointer to the first character not converted in the string:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/35574229/swift-which-the-equivalent-of-sscanf", "keywords": [], "tags": ["ios", "string", "swift"], "question": {"id": 35574229, "title": "Swift: which the equivalent of sscanf()?", "content": "In my iOS app I have team names saved as  and to get the full name of the team I would need to read/split that string according to this format  %s (%s) like we are used to doing with ``sscanf()`in C. How do we do that in Swift?", "abstract": ""}, "answers": [{"id": 75758794, "score": 0, "vote": 0, "content": "Here is an approximate equivalent for sscanf, this depends on the Swift OCL libraries from github.com/eclipse/agileuml (in libraries*.zip): This used like this: print(scan(s: \"100#20.5/10\", fmt: \"%d#%f/%d\"))", "abstract": ""}, {"id": 50150888, "score": 4, "vote": 0, "content": "Unfortunately there's no in-place replacement for sscanf() but the way to do it is to use class Scanner (Apple documentation and by raywenderlich.com). For your case: Result:", "abstract": ""}, {"id": 35578548, "score": 3, "vote": 0, "content": "** updated to current format, as suggested by Nicholas Allio ** I'm sure someone will come along with a regex solution - but until then, you can always parse strings with componentsSeparatedByString", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/8430022/what-is-the-java-equivalent-of-sscanf-for-parsing-values-from-a-string-using-a-k", "keywords": [], "tags": ["java", "scanf"], "question": {"id": 8430022, "title": "what is the Java equivalent of sscanf for parsing values from a string using a known pattern?", "content": "So I come from a C background (originally originally, though I haven't used that language for almost 5 years) and I'm trying to parse some values from a string in Java. In C I would use sscanf. In Java people have told me \"use Scanner, or StringTokenizer\", but I can't see how to use them to achieve my purpose. My input string looks like \"17-MAR-11 15.52.25.000000000\". In C I would do something like: But in Java, all I can do is things like: This doesn't allow me to check the pattern, and for \"MAR\" I end up having to do things like: Horrible! Surely there is a better way?", "abstract": ""}, "answers": [{"id": 75664680, "score": 0, "vote": 0, "content": "Here is a simple implementation of sscanf using Scanner:", "abstract": ""}, {"id": 59466944, "score": 1, "vote": 0, "content": "2019 answer: Java's Scanner is flexible for reading a wide range of formats.  But if your format has simple {%d, %f, %s} fields then you can scan easily with this small class (~90 lines): For example, the OP's case can be handled like this:", "abstract": ""}, {"id": 8430218, "score": 0, "vote": 0, "content": "Are you familiar with the concept of regular expressions? Java provides you with the ability to use regex by using the Pattern class. \nCheck this one out:\nhttp://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html You can test your String like that: and then use the methods provided by Matcher to manipulate the string you found or NOT.", "abstract": ""}, {"id": 20728225, "score": -3, "vote": 0, "content": "System.in.read() is another option.", "abstract": ""}, {"id": 15265044, "score": 13, "vote": 0, "content": "None of these examples were really satisfactory to me so I made my own java sscanf utility: https://github.com/driedler/java-sscanf/tree/master/src/util/sscanf Here's an example of parsing a hex string:", "abstract": ""}, {"id": 10200448, "score": 3, "vote": 0, "content": "For \"17-MAR-11 15.52.25.000000000\":", "abstract": ""}, {"id": 8430949, "score": 29, "vote": 0, "content": "Here is a solution using scanners:", "abstract": ""}, {"id": 8430318, "score": 2, "vote": 0, "content": "This is far from as elegant solution as one would get with using regex, but ought to work.", "abstract": ""}, {"id": 8430204, "score": 41, "vote": 0, "content": "The problem is Java hasn't out parameters (or passing by reference) as C or C#. But there is a better way (and more solid). Use regular expressions: Of course C code is more concise, but this technique has one profit:\nPatterns specifies format more precise than '%s' and '%d'. So you can use \\d{2} to specify that day MUST be compose of exactly 2 digits.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/2175080/sscanf-in-python", "keywords": [], "tags": ["python", "parsing", "split", "scanf", "procfs"], "question": {"id": 2175080, "title": "sscanf in Python", "content": "I'm looking for an equivalent to sscanf() in Python. I want to parse /proc/net/* files, in C I could do something like this: I thought at first to use str.split, however it doesn't split on the given characters, but the sep string as a whole: Which should be returning 17, as explained above. Is there a Python equivalent to sscanf (not RE), or a string splitting function in the standard library that splits on any of a range of characters that I'm not aware of?", "abstract": ""}, "answers": [{"id": 60397881, "score": 2, "vote": 0, "content": "There is an example in the official python docs about how to use sscanf from libc:", "abstract": ""}, {"id": 59757055, "score": 1, "vote": 0, "content": "You could install pandas and use pandas.read_fwf for fixed width format files.  Example using /proc/net/arp: By default it tries to figure out the format automagically, but there are options you can give for more explicit instructions (see documentation).  There are also other IO routines in pandas that are powerful for other file formats.", "abstract": ""}, {"id": 11085456, "score": 74, "vote": 0, "content": "When I'm in a C mood, I usually use zip and list comprehensions for scanf-like behavior.  Like this: Note that for more complex format strings, you do need to use regular expressions: Note also that you need conversion functions for all types you want to convert. For example, above I used something like:", "abstract": ""}, {"id": 12852181, "score": 100, "vote": 0, "content": "There is also the parse module. parse() is designed to be the opposite of format() (the newer string formatting function in Python 2.6 and higher).", "abstract": ""}, {"id": 2180718, "score": 16, "vote": 0, "content": "You can parse with module re using named groups. It won't parse the substrings to their actual datatypes (e.g. int) but it's very convenient when parsing strings. Given this sample line from /proc/net/tcp: An example mimicking your sscanf example with the variable could be:", "abstract": ""}, {"id": 2176352, "score": -2, "vote": 0, "content": "If the separators are ':', you can split on ':', and then use x.strip() on the strings to get rid of any leading or trailing whitespace. int() will ignore the spaces.", "abstract": ""}, {"id": 2175135, "score": 38, "vote": 0, "content": "Python doesn't have an sscanf equivalent built-in, and most of the time it actually makes a whole lot more sense to parse the input by working with the string directly, using regexps, or using a parsing tool.  Probably mostly useful for translating C, people have implemented sscanf, such as in this module: http://hkn.eecs.berkeley.edu/~dyoo/python/scanf/ In this particular case if you just want to split the data based on multiple split characters, re.split is really the right tool.", "abstract": ""}, {"id": 2175126, "score": 1, "vote": 0, "content": "you can turn the \":\" to space, and do the split.eg no regex needed (for this case)", "abstract": ""}, {"id": 2175096, "score": 24, "vote": 0, "content": "You can split on a range of characters using the re module.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65432889/nodejs-equivalent-of-c-sscanf", "keywords": [], "tags": ["node.js", "matching", "format-string"], "question": {"id": 65432889, "title": "Nodejs equivalent of c sscanf", "content": "I need a function that behaves similar to the behavior of sscanf For example, let's suppose we have a format string that looks like this (the function I'm looking for doesn't have to be exactly like this, but something similar) And have return/modify a variable to look like After researching this for a while, the only things I could actually find was scanf, but that takes input form stdin, and not a string I am aware that there is a regex solution for this, but I'm looking for a function that does this without the need for regex (regex is slow). However, if there is no other solution for this, I will accept a regex solution.", "abstract": ""}, "answers": [{"id": 65434164, "score": 1, "vote": 0, "content": "The normal solution for this in most languages that have regular expressions built-in is to use regular expressions. If you're not used to or don't like regular expressions I'm sorry. Most of the programming world have assumed that knowledge of regular expressions is mandatory. In any case. The normal solution to this is string.prototype.match: What pattern you put in your capture group (the (..) part) depends on what you want. The code above captures anything at all including spaces and special characters. If you just want to capture a \"word\", that is, printable characters without spaces, then you can use (\\w+): If you want to capture a word with only letters but not numbers you can use ([a-zA-Z]+): The flexibility of regular expression is why other methods of string scanning are usually not supported in languages that have had regular expression built-in since the beginning. But of course, flexibility comes with complexity.", "abstract": ""}, {"id": 65433072, "score": 0, "vote": 0, "content": "Do you mean to have the ${var} to act as a placeholder? If so you could do it by replacing the \" with the backtick:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65055610/sscanf-equivalent-in-linux-bash", "keywords": [], "tags": ["bash", "scanf"], "question": {"id": 65055610, "title": "sscanf equivalent in linux bash", "content": "I want to extract a number that appears in the middle of a script in linux bash: In C I'd do something like: How do I do that in linux bash?", "abstract": ""}, "answers": [{"id": 65056573, "score": 2, "vote": 0, "content": "Another way to approach the sscanf() look alike would be to pass in a regex type pattern to match and then use the +(...) extglob pattern to replace all occurrences in the input string with \"(.*)\" to then let [[ .. =~ .. ]] populate the BASH_REMATCH without having to pass a duplicate of the string with the \"(.*)\" inserted manually. For example: This is essentially what the great answer by @Cyrus shows, it's just another approach to building the search string. Example Output (note: shamelessly borrowing example text from @Cyrus)", "abstract": ""}, {"id": 65055661, "score": 5, "vote": 0, "content": "With bash and a regex: You will find the matches in array BASH_REMATCH from field 1. Output:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/492262/is-there-an-equivalent-to-sscanf-in-net", "keywords": [], "tags": [".net", "string"], "question": {"id": 492262, "title": "Is there an equivalent to &#39;sscanf()&#39; in .NET?", "content": "The .NET Framework gives us the Format method: I would like an \"Unformat\" function, something like: I know something similar exists in the ANSI-C library (printf vs scanf).  The question: is there something similiar in C#? Update: Capturing groups with regular expressions are not the solution I need. They are also one way. I'm looking for a system that can work both ways in a single format. It's OK to give up some functionality (like types and formatting info).", "abstract": ""}, "answers": [{"id": 37202918, "score": -1, "vote": 0, "content": "I reference earlier reply, wrote a sample see following", "abstract": ""}, {"id": 5114304, "score": 5, "vote": 0, "content": "If anyone's interested, I've just posted a scanf() replacement for .NET. If regular expressions don't quite cut it for you, my code follows the scanf() format string quite closely. You can see and download the code I wrote at http://www.blackbeltcoder.com/Articles/strings/a-sscanf-replacement-for-net.", "abstract": ""}, {"id": 887792, "score": 1, "vote": 0, "content": "I came across the same problem, i belive that there is a elegante solution using REGEX... but a came up with function in C# to \"UnFormat\" that works quite well. Sorry about the lack of comments.", "abstract": ""}, {"id": 492948, "score": 1, "vote": 0, "content": "@mquander: Actualy, PHP solves it even different: But maybe your regular expression remark can help me. I just need to rewrite \"This {0} very {1}.\" to something like: new Regex(@\"^This (.*) very (.*)\\.$\"). This should be done programmatical, so I can use one format string on the public class interface. BTW: I've already have a parser to find the parameters: see the Named Format Redux blog entry by Phil Haack (and yes, I also want named paramters to work both ways).", "abstract": ""}, {"id": 492287, "score": 3, "vote": 0, "content": "Yep. These are called \"regular expressions\". The one that will do the thing is", "abstract": ""}, {"id": 492284, "score": 16, "vote": 0, "content": "There's no such method, probably because of problems resolving ambiguities: Regular expression capturing groups are made for this problem; you may want to look into them.", "abstract": ""}, {"id": 492281, "score": 5, "vote": 0, "content": "Regex with grouping?", "abstract": ""}, {"id": 492275, "score": 4, "vote": 0, "content": "You could do string[] parts = string.Split(' '), and then extract by the index position parts[1] and parts [3] in your example.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/47958786/how-to-sscanf-in-java", "keywords": [], "tags": ["java", "scanf"], "question": {"id": 47958786, "title": "How to &quot;sscanf&quot; in Java?", "content": "I have a string and I want to a) check if it matches the following format and b) extract the numbers and text into variables: In, C, I would use : How do I do the same in Java?", "abstract": ""}, "answers": [{"id": 47959387, "score": 0, "vote": 0, "content": "The alternatve solution: StringTokenizer break the string into tokens. Where \":\" is a tokens delimiter.\nOutput:", "abstract": ""}, {"id": 47958813, "score": 1, "vote": 0, "content": "Did you mean : If you want to match exact (one number):(two numbers):(two number) you can use \\\\d:\\\\d{2}:\\\\d{2} instead of \\\\d+:\\\\d+:\\\\d+ details ...how do I extract the numbers and the text from the string? If you are using Java 8 you can split your input, the first input return numbers separated by :, the second is the text you want, so to extract the numbers, you need to split the first input again by : then Iterate over them and convert each one to an Integer, like this :", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/6104821/c-equivalent-of-sscanf", "keywords": [], "tags": ["c++", "stl"], "question": {"id": 6104821, "title": "C++ equivalent of sscanf?", "content": "I've been using sscanf and I think I've gotten too comfortable with it. Apparently it is deprecated too and I should use sscanf_s, which is not standard as far as I know. So I was wondering if the STL has an idiomatic C++ replacement do the same thing?  Thanks I do:", "abstract": ""}, "answers": [{"id": 6104838, "score": 11, "vote": 0, "content": "The formatting isn't as easy but check out stringstream. See also istringstream and ostringstream for input and output buffers formatting.", "abstract": ""}, {"id": 6105916, "score": 1, "vote": 0, "content": "If you're using a compiler with enough C++0x support, it's easy to write a type-safe scanf()-style function... have a read of the printf() example at http://en.wikipedia.org/wiki/C%2B%2B0x to get you started....", "abstract": ""}, {"id": 6105493, "score": 11, "vote": 0, "content": "In C++, the ultimate parser is Boost.Qi", "abstract": ""}, {"id": 6104851, "score": 1, "vote": 0, "content": "I believe stringstreams are what you are looking for. for example:", "abstract": ""}, {"id": 6104845, "score": 1, "vote": 0, "content": "You can try using stringstream. It is much more powerful than sscanf and serves the purpose.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/4223917/c-equivalent-of-c-sscanf", "keywords": [], "tags": ["c#", "c", "string", "formatted-input"], "question": {"id": 4223917, "title": "C# equivalent of C sscanf", "content": "Possible Duplicate:\nIs there an equivalent to 'sscanf()' in .NET?  sscanf in C is a nice way to read well formatted input from a string. How to achieve this C#. For example, The above code will assign 10 to a and 12 to b. How to achieve the same using C#?", "abstract": ""}, "answers": [{"id": 9283159, "score": 8, "vote": 0, "content": "Writing your own sscanf() method in C# isn't that difficult, if you don't mind writing a little low-level code. You can see my version in the article A sscanf() Replacement for .NET.", "abstract": ""}, {"id": 4224018, "score": 11, "vote": 0, "content": "There is no direct equivalent of sscanf in the .NET Framework. The simplest way to achieve the same functionality is splitting the string (String.Split) and then assigning the subsequent parts to variables with the Int32.Parse method. For example: Many different data types in the Framework have Parse methods, including enumerations, if the values you want to read in from the string are not necessarily integer values. You could also use regular expressions, but they're probably a bit overkill for a task as simple as this. \nEDIT: If you're truly deadset on using sscanf, you could always consider P/Invoking the function from the C runtime libraries. Something like this perhaps (untested):", "abstract": ""}, {"id": 4224076, "score": 9, "vote": 0, "content": "I'm just writing to kill time.", "abstract": ""}, {"id": 4224035, "score": 1, "vote": 0, "content": "from Run-Time Routines and .NET Framework Equivalents sscanf, swscanf ==> See Parse methods, such as System.Double.Parse So, I guess there's no direct equivalent.", "abstract": ""}, {"id": 4223989, "score": 18, "vote": 0, "content": "There is no direct equivalent in C#. Given the same task in C#, you could do it something like this: Depending on how well-formed you can assume the input to be, you might want to add some error checks.", "abstract": ""}]}]