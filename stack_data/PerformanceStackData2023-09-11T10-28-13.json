[{"link": "https://stackoverflow.com/questions/1316887/what-is-the-most-efficient-string-concatenation-method-in-python", "keywords": [], "tags": ["python", "string"], "question": {"id": 1316887, "title": "What is the most efficient string concatenation method in Python?", "content": "Is there an efficient mass string concatenation method in Python (like StringBuilder in C# or StringBuffer in Java)? I found following methods here: What should be used and why? (A related question is here.)", "abstract": ""}, "answers": [{"id": 76578940, "score": -3, "vote": 0, "content": "=>The best way to concatinate string is using '+'.For eg:- =>The another easy way is by using\njoint method.For eg:-", "abstract": ""}, {"id": 1316891, "score": 70, "vote": 0, "content": "''.join(sequence_of_strings) is what usually works best \u2013 simplest and fastest.", "abstract": ""}, {"id": 64527807, "score": 12, "vote": 0, "content": "Update: Python3.11 has some optimizations for % formatting yet it maybe still better to stick with f-strings. For Python 3.8.6/3.9, I had to do some dirty hacks, because perfplot was giving out some errors. Here assume that x[0] is a a and x[1] is b:  The plot is nearly same for large data. For small data,  Taken by perfplot and this is the code, large data == range(8), small data == range(4). When medium data is there, and four strings are there x[0], x[1], x[2], x[3] instead of two strings:  Better to stick with f-strings. Also the speed of %s is similar to .format().", "abstract": ""}, {"id": 50474424, "score": 2, "vote": 0, "content": "Probably the \"new f-strings in Python 3.6\" is the most efficient way of concatenating strings. Using %s Using .format Using f-strings", "abstract": ""}, {"id": 24718551, "score": 29, "vote": 0, "content": "As per John Fouhy's answer, don't optimize unless you have to, but if you're here and asking this question, it may be precisely because you have to. In my case, I needed to assemble some URLs from string variables... fast. I noticed no one (so far) seems to be considering the string format method, so I thought I'd try that and, mostly for mild interest, I thought I'd toss the string interpolation operator in there for good measure. To be honest, I didn't think either of these would stack up to a direct '+' operation or a ''.join(). But guess what? On my Python 2.7.5 system, the string interpolation operator rules them all and string.format() is the worst performer: The results: If I use a shorter domain and shorter path, interpolation still wins out. The difference is more pronounced, though, with longer strings. Now that I had a nice test script, I also tested under Python 2.6, 3.3 and 3.4, here's the results. In Python 2.6, the plus operator is the fastest! On Python 3, join wins out. Note: these tests are very repeatable on my system. So, 'plus' is always faster on 2.6, 'intp' is always faster on 2.7 and 'join' is always faster on Python 3.x. Lesson learned: tl;dr:", "abstract": ""}, {"id": 33981580, "score": 2, "vote": 0, "content": "One year later, let's test mkoistinen's answer with Python\u00a03.4.3: Nothing changed. join is still the fastest method. With string interpolation (intp) being arguably the best choice in terms of readability, you might want to use string interpolation nevertheless.", "abstract": ""}, {"id": 38362140, "score": 124, "vote": 0, "content": "If you know all components beforehand once, use the literal string interpolation, also known as f-strings or formatted strings, introduced in Python 3.6. Given the test case from mkoistinen's answer, having strings The contenders and their execution time on my computer using Python 3.6 on Linux as timed by IPython and the timeit module are f'http://{domain}/{lang}/{path}' - 0.151 \u00b5s 'http://%s/%s/%s' % (domain, lang, path) - 0.321 \u00b5s 'http://' + domain + '/' + lang + '/' + path - 0.356 \u00b5s ''.join(('http://', domain, '/', lang, '/', path)) - 0.249 \u00b5s (notice that building a constant-length tuple is slightly faster than building a constant-length list). Thus the shortest and the most beautiful code possible is also fastest. The speed can be contrasted with the fastest method for Python 2, which is + concatenation on my computer; and that takes 0.203 \u00b5s with 8-bit strings, and 0.259 \u00b5s if the strings are all Unicode. (In alpha versions of Python 3.6 the implementation of f'' strings was the slowest possible - actually the generated byte code is pretty much equivalent to the ''.join() case with unnecessary calls to str.__format__ which without arguments would just return self unchanged. These inefficiencies were addressed before 3.6 final.)", "abstract": ""}, {"id": 12321184, "score": 3, "vote": 0, "content": "I ran into a situation where I needed to have an appendable string of unknown size.  These are the benchmark results (python 2.7.3): This seems to show that '+=' is the fastest.  The results from the skymind link are a bit out of date. (I realize that the second example is not complete. The final list would need to be joined.  This does show, however, that simply preparing the list takes longer than the string concatenation.)", "abstract": ""}, {"id": 22356177, "score": 11, "vote": 0, "content": "It pretty much depends on the relative sizes of the new string after every new concatenation. With the + operator, for every concatenation, a new string is made. If the intermediary strings are relatively long, the + becomes increasingly slower, because the new intermediary string is being stored. Consider this case: Results 1 0.00493192672729 2 0.000509023666382 3 0.00042200088501 4 0.000482797622681 In the case of 1&2, we add a large string, and join() performs about 10 times faster.\nIn case 3&4, we add a small string, and '+' performs slightly faster.", "abstract": ""}, {"id": 14610440, "score": 1, "vote": 0, "content": "Inspired by JasonBaker's benchmarks, here's a simple one, comparing 10 \"abcdefghijklmnopqrstuvxyz\" strings, showing that .join() is faster; even with this tiny increase in variables:", "abstract": ""}, {"id": 1316959, "score": 157, "vote": 0, "content": "You may be interested in this: An optimization anecdote by Guido.  Although it is worth remembering also that this is an old article and it predates the existence of things like ''.join (although I guess string.joinfields is more-or-less the same) On the strength of that, the array module may be fastest if you can shoehorn your problem into it.  But ''.join is probably fast enough and has the benefit of being idiomatic and thus easier for other Python programmers to understand. Finally, the golden rule of optimization: don't optimize unless you know you need to, and measure rather than guessing. You can measure different methods using the timeit module. That can tell you which is fastest, instead of random strangers on the Internet making guesses.", "abstract": ""}, {"id": 42001410, "score": 1, "vote": 0, "content": "For a small set of short strings (i.e. 2 or 3 strings of no more than a few characters), plus is still way faster. Using mkoistinen's wonderful script in Python 2 and 3: So when your code is doing a huge number of separate small concatenations, plus is the preferred way if speed is crucial.", "abstract": ""}, {"id": 1316982, "score": 42, "vote": 0, "content": "It depends on what you're doing. After Python 2.5, string concatenation with the + operator is pretty fast. If you're just concatenating a couple of values, using the + operator works best: However, if you're putting together a string in a loop, you're better off using the list joining method: ...but notice that you have to be putting together a relatively high number of strings before the difference becomes noticeable.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/61392258/most-efficient-method-to-concatenate-strings-in-python", "keywords": [], "tags": ["python", "string", "performance"], "question": {"id": 61392258, "title": "Most Efficient Method to Concatenate Strings in Python", "content": "At the time of asking this question, I'm using Python 3.8 When I say efficient, I'm only referring to the speed at which the strings are concatenated, or in more technical terms: I'm asking about the time complexity, not accounting the space complexity. The only methods I can think of at the moment are the following 3 given that: Method 1 result = a + b Method 2 result = ''.join((a, b)) Method 3 result = '{0}{1}'.format(a, b) I want to know which of these methods are faster, or if there are other methods that are more efficient. Also, if you know if either of these methods performs differently with more strings or longer strings, please include that in your answer. Edit After seeing all the comments and answers, I have learned a couple of new ways to concatenate strings, and I have also learned about the timeit library. I will report my personal findings below: It seems that for these small strings, the traditional a + b method is the fastest for string concatenation. Thanks for all of the answers!", "abstract": ""}, "answers": [{"id": 61392407, "score": 9, "vote": 0, "content": "Let's try it out! We can use timeit.timeit() to run a statement many times and return the overall duration. Here, we use s to setup the variables a and b (not included in the overall time), and then run the various options 10 million times. This shows that unless your application's bottleneck is string concatenation, it's probably not worth being too concerned about... Depending on the performance of your system, you might see a speed improvement in the order of a few seconds if you're performing literally millions of operations. Note that your results may vary quite drastically depending on the lengths (and number) of the strings you're concatenating, and the hardware you're running on.", "abstract": ""}, {"id": 61392334, "score": 6, "vote": 0, "content": "For exactly two strings a and b, just use a + b. The alternatives are for joining more than 2 strings, avoiding the temporary str object created by each use of +, as well as the quadratic behavior due to repeatedly copying the contents of earlier operations in the next result. (There's also f'{a}{b}', but it's syntactically  heavier and no faster than a + b.)", "abstract": ""}, {"id": 61392417, "score": 0, "vote": 0, "content": "Looks like .join() and .format() are basically the same and 4x faster. An F string, eg: is also a very quick and clean method, especially when working with more complex formats. ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/21078/most-efficient-way-to-concatenate-strings", "keywords": [], "tags": ["c#", ".net", "string", "performance", "optimization"], "question": {"id": 21078, "title": "Most efficient way to concatenate strings?", "content": "What's the most efficient way to concatenate strings?", "abstract": ""}, "answers": [{"id": 74502341, "score": 3, "vote": 0, "content": "I've tested all the methods in this page and at the end I've developed my solution that is the fastest and less memory expensive. Note: tested in Framework 4.8  Yes, it use unsafe You can edit the method and adapt it to your case. For example you can make it something like public static unsafe string FastConcat(string str1, string str2, string str3 = null, string str4 = null, string str5 = null, string str6 = null, string str7 = null)", "abstract": ""}, {"id": 21093, "score": 170, "vote": 0, "content": "The StringBuilder.Append() method is much better than using the + operator.  But I've found that, when executing 1000 concatenations or less, String.Join() is even more efficient than StringBuilder. The only problem with String.Join is that you have to concatenate the strings with a common delimiter. Edit: as @ryanversaw pointed out, you can make the delimiter string.Empty.", "abstract": ""}, {"id": 21118, "score": 12, "vote": 0, "content": "If you're operating in a loop, StringBuilder is probably the way to go; it saves you the overhead of creating new strings regularly. In code that'll only run once, though, String.Concat is probably fine. However, Rico Mariani (.NET optimization guru) made up a quiz in which he stated at the end that, in most cases, he recommends String.Format.", "abstract": ""}, {"id": 21113, "score": 68, "vote": 0, "content": "From Chinh Do - StringBuilder is not always faster: Rules of Thumb When concatenating three dynamic string values or less, use traditional string concatenation. When concatenating more than three dynamic string values, use StringBuilder. When building a big string from several string literals, use either the @ string literal or the inline + operator. Most of the time StringBuilder is your best bet, but there are cases as shown in that post that you should at least think about each situation.", "abstract": ""}, {"id": 6184000, "score": 1, "vote": 0, "content": "It really depends on your usage pattern.\nA detailed benchmark between string.Join, string,Concat and string.Format can be found here: String.Format Isn't Suitable for Intensive Logging (This is actually the same answer I gave to this question)", "abstract": ""}, {"id": 48340975, "score": 3, "vote": 0, "content": "Another solution: inside the loop, use List instead of string. it is very very fast.", "abstract": ""}, {"id": 47231853, "score": 12, "vote": 0, "content": "Here is the fastest method I've evolved over a decade for my large-scale NLP app. I have variations for IEnumerable<T> and other input types, with and without separators of different types (Char, String), but here I show the simple case of  concatenating all strings in an array into a single string, with no separator. Latest version here is developed and unit-tested on C# 7 and .NET 4.7. There are two keys to higher performance; the first is to pre-compute the exact total size required. This step is trivial when the input is an array as shown here. For handling IEnumerable<T> instead, it is worth first gathering the strings into a temporary array for computing that total (The array is required to avoid calling ToString() more than once per element since technically, given the possibility of side-effects, doing so could change the expected semantics of a 'string join' operation). Next, given the total allocation size of the final string, the biggest boost in performance is gained by building the result string in-place. Doing this requires the (perhaps controversial) technique of temporarily suspending the immutability of a new String which is initially allocated full of zeros. Any such controversy aside, however... ...note that this is the only bulk-concatenation solution on this page which entirely avoids an extra round of allocation and copying by the String constructor. Complete code: I should mention that this code has a slight modification from what I use myself. In the original, I call the cpblk IL instruction from C# to do the actual copying. For simplicity and portability in the code here, I replaced that with P/Invoke memcpy instead, as you can see. For highest performance on x64 (but maybe not x86) you may want to use the cpblk method instead.", "abstract": ""}, {"id": 43069670, "score": 5, "vote": 0, "content": "Following may be one more alternate solution to concatenate multiple strings. string interpolation", "abstract": ""}, {"id": 12257751, "score": 100, "vote": 0, "content": "There are 6 types of string concatenations: In an experiment, it has been proved that string.Concat() is the best way to approach if the words are less than 1000(approximately) and if the words are more than 1000 then StringBuilder should be used. For more information, check this site.  The string.Concat method here is equivalent to the string.Join method invocation with an empty separator. Appending an empty string is fast, but not doing so is even faster, so the string.Concat method would be superior here.", "abstract": ""}, {"id": 21131, "score": 291, "vote": 0, "content": "Rico Mariani, the .NET Performance guru, had an article on this very subject.  It's not as simple as one might suspect.  The basic advice is this: If your pattern looks like: x = f1(...) + f2(...) + f3(...) + f4(...) that's one concat and it's zippy, StringBuilder probably won't help. If your pattern looks like:   if (...) x += f1(...)\nif (...) x += f2(...)\nif (...) x += f3(...)\nif (...) x += f4(...)  then you probably want StringBuilder. Yet another article to support this claim comes from Eric Lippert where he describes the optimizations performed on one line + concatenations in a detailed manner.", "abstract": ""}, {"id": 34558305, "score": 6, "vote": 0, "content": "Try this 2 pieces of code and you will find the solution. Vs You will find that 1st code will end really quick and the memory will be in a good amount. The second code maybe the memory will be ok, but it will take longer... much longer.\nSo if you have an application for a lot of users and you need speed, use the 1st. If you have an app for a short term one user app, maybe you can use both or the 2nd will be more \"natural\" for developers. Cheers. ", "abstract": ""}, {"id": 164074, "score": 8, "vote": 0, "content": "From this MSDN article: There is some overhead associated with\n  creating a StringBuilder object, both\n  in time and memory. On a machine with\n  fast memory, a StringBuilder becomes\n  worthwhile if you're doing about five\n  operations. As a rule of thumb, I\n  would say 10 or more string operations\n  is a justification for the overhead on\n  any machine, even a slower one. So if you trust MSDN go with StringBuilder if you have to do more than 10 strings operations/concatenations - otherwise simple string concat with '+' is fine.", "abstract": ""}, {"id": 26680343, "score": 5, "vote": 0, "content": "Adding to the other answers, please keep in mind that StringBuilder can be told an initial amount of memory to allocate. The capacity parameter defines the maximum number of characters that can be stored in the memory allocated by the current instance. Its value is assigned to the Capacity property. If the number of characters to be stored in the current instance exceeds this capacity value, the StringBuilder object allocates additional memory to store them. If capacity is zero, the implementation-specific default capacity is used. Repeatedly appending to a StringBuilder that hasn't been pre-allocated can result in a lot of unnecessary allocations just like repeatedly concatenating regular strings. If you know how long the final string will be, can trivially calculate it, or can make an educated guess about the common case (allocating too much isn't necessarily a bad thing), you should be providing this information to the constructor or the Capacity property. Especially when running performance tests to compare StringBuilder with other methods like String.Concat, which do the same thing internally. Any test you see online which doesn't include StringBuilder pre-allocation in its comparisons is wrong. If you can't make any kind of guess about the size, you're probably writing a utility function which should have its own optional argument for controlling pre-allocation.", "abstract": ""}, {"id": 23266274, "score": 2, "vote": 0, "content": "System.String is immutable. When we modify the value of a string variable then a new memory is allocated to the new value and the previous memory allocation released. System.StringBuilder was designed to have concept of a mutable string where a variety of operations can be performed without allocation separate memory location for the modified string.", "abstract": ""}, {"id": 19365619, "score": 5, "vote": 0, "content": "It's also important to point it out that you should use the + operator if you are concatenating string literals. When you concatenate string literals or string constants by using the + operator, the compiler creates a single string. No run time concatenation occurs. How to: Concatenate Multiple Strings (C# Programming Guide)", "abstract": ""}, {"id": 21114, "score": 0, "vote": 0, "content": "It would depend on the code. \nStringBuilder is more efficient generally, but if you're only concatenating a few strings and doing it all in one line, code optimizations will likely take care of it for you. It's important to think about how the code looks too: for larger sets StringBuilder will make it easier to read, for small ones StringBuilder will just add needless clutter.", "abstract": ""}, {"id": 21097, "score": 1, "vote": 0, "content": "For just two strings, you definitely do not want to use StringBuilder.  There is some threshold above which the StringBuilder overhead is less than the overhead of allocating multiple strings. So, for more that 2-3 strings, use DannySmurf's code.  Otherwise, just use the + operator.", "abstract": ""}, {"id": 21084, "score": 2, "vote": 0, "content": "The most efficient is to use StringBuilder, like so: @jonezy: String.Concat is fine if you have a couple of small things. But if you're concatenating megabytes of data, your program will likely tank.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/16696632/most-efficient-way-to-concatenate-strings-in-javascript", "keywords": [], "tags": ["javascript", "string", "performance", "concatenation"], "question": {"id": 16696632, "title": "Most efficient way to concatenate strings in JavaScript?", "content": "In JavaScript, I have a loop that has many iterations, and in each iteration, I am creating a huge string with many += operators. Is there a more efficient way to create a string? I was thinking about creating a dynamic array where I keep adding strings to it and then do a join. Can anyone explain and give an example of the fastest way to do this?", "abstract": ""}, "answers": [{"id": 53678213, "score": 12, "vote": 0, "content": "You can also do string concat with template literals.  I updated the other posters' JSPerf tests to include it.", "abstract": ""}, {"id": 68006068, "score": 0, "vote": 0, "content": "I can't comment on other's answers (not enough rep.), so I will say MadBreaks' answer of using template literals is good, but care should be taken if building a site that needs to be compatible with IE (Internet Explorer), because template literals aren't compatible with IE. So, in that case you can just use assignment operators (+, +=).", "abstract": ""}, {"id": 64918008, "score": 15, "vote": 0, "content": "I did a quick test in both node and chrome and found in both cases += is faster: results in node: 7.0.10 results from chrome 86.0.4240.198:", "abstract": ""}, {"id": 65048076, "score": 7, "vote": 0, "content": "I wonder why String.prototype.concat is not getting any love. In my tests (assuming you already have an array of strings), it outperforms all other methods. perf.link test Test code:", "abstract": ""}, {"id": 16696775, "score": 167, "vote": 0, "content": "Seems based on benchmarks at JSPerf that using += is the fastest method, though not necessarily in every browser. For building strings in the DOM, it seems to be better to concatenate the string first and then add to the DOM, rather then iteratively add it to the dom. You should benchmark your own case though. (Thanks @zAlbee for correction)", "abstract": ""}, {"id": 35898611, "score": 18, "vote": 0, "content": "Three years past since this question was answered but I will provide my answer anyway :) Actually, accepted answer is not fully correct. Jakub's test uses hardcoded string which allows JS engine to optimize code execution (Google's V8 is really good in this stuff!). \nBut as soon as you use completely random strings (here is JSPerf) then string concatenation will be on a second place.", "abstract": ""}, {"id": 20591693, "score": 96, "vote": 0, "content": "I have no comment on the concatenation itself, but I'd like to point out that @Jakub Hampl's suggestion: For building strings in the DOM, in some cases it might be better to iteratively add to the DOM, rather then add a huge string at once. is wrong, because it's based on a flawed test. That test never actually appends into the DOM. This fixed test shows that creating the string all at once before rendering it is much, MUCH faster. It's not even a contest. (Sorry this is a separate answer, but I don't have enough rep to comment on answers yet.)", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72867726/most-efficient-way-to-concatenate-multiple-strings-in-c", "keywords": [], "tags": ["c++", "string", "string-concatenation"], "question": {"id": 72867726, "title": "Most efficient way to concatenate multiple strings in C++", "content": "I want to find the most efficient way to concatenate multiple strings of type std::string. One of the issues is that I also have a char within it, and another issue is that I need it to be as fast as possible.\nLet's say I have the following variables defined: This code does not compile with Intel C++14 compiler. This time the output came as expected: \"default_E_\" I still wanted to test another way: Output was OK again, because of the separation of the char from the strings. \"default_E_\" When testing for timing, I've found out that the append option is faster that the +=. I want to know if there is a better, more efficient way, \nand also could I minimize the number of lines so it wouldn't look so ugly?", "abstract": ""}, "answers": [{"id": 73008662, "score": -1, "vote": 0, "content": "Use the \"built-in\" C++ \"stringbuilder\" : OR (more concise, not using result variable) Using ostringstream object you can also concatenate any type of variables, provided that all of them are \"streamable\" (standard stream or the type itself know how to serialize what you are sending after operator << ):", "abstract": ""}, {"id": 72963617, "score": 3, "vote": 0, "content": "The fastest way is most likely going to involve allocating a destination string once, which means you will need to know the size of all your input strings. Luckily std::string, string literals and individual characters have a O(1) size, so only c style strings need to be looped twice. See it on coliru", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/21880730/c-what-is-the-best-and-fastest-way-to-concatenate-strings", "keywords": [], "tags": ["c", "string", "performance", "concatenation"], "question": {"id": 21880730, "title": "C: What is the best and fastest way to concatenate strings", "content": "I currently concatenate strings in c using the strcat() function from string.h library. I thought about it, and I got to a conclusion that it should be very expensive function, as before it starts to concatenate, it has to iterate over the char array until it finds the '\\0' char. For example, if I concatenate the string \"horses\" 1000 times using strcat(), I'll have to pay\n(1 + 2 + 3 + ... + 1000) * strlen(\"horses\") = (1000*1001)/2 * 6 = 3003000 I thought about the non-standard way, of maintaining an integer with the string length, and then sending to strcat() the pointer to the end of the string: In this case, I'll pay only 1000 * strlen(\"horses\") = 1000 * 6 = 6000. 6000 is 500x smaller than 3003000, so it can be very critical for performance if you make a lot of such concatenations. Is there some more standard way to do it, looking better than my solution?", "abstract": ""}, "answers": [{"id": 66664641, "score": 0, "vote": 0, "content": "Here is a simple safe and efficient concatenation function: On POSIX systems, the code can be simplified with strnlen():", "abstract": ""}, {"id": 66663537, "score": 1, "vote": 0, "content": "Here's what I do, and it's faster than strcat, but I don't know how it compares to other solutions.  Let's say you have an array of 1000 strings and want to concatenate them with spaces between, and you have a 100,000 character buffer to hold it. sprintf will return the number of characters written, and keep advancing the pointer buffer+L.\nThis does NOT have any safety checking.  You can check whether L exceeds 100000, but that's on you.  If buffer+L is beyond the end of the string, it will crash your app.", "abstract": ""}, {"id": 52345189, "score": 2, "vote": 0, "content": "This is a late answer, but I just have come across the same issue. To find a starting point, I decided to re-read the man pages for strcpy, strncpy, strlen, strnlen, strcat and strncat. I have almost missed it, but fortunately ... there is an interesting passage in man strcpy on my development system (Debian stretch). Citing it (formatting mine): strlcpy() Some systems (the BSDs, Solaris, and others) provide the following\n  function: This function is similar to strncpy(), but it copies at most size-1\n  bytes to dest, always adds a terminating null byte, and does not pad\n  the target with (further) null bytes. This function fixes some of the\n  problems of strcpy() and strncpy(), but the caller must still handle\n  the possibility of data loss if size is too small. The return value\n  of the function is the length of src, which allows truncation to be\n  easily detected: if the return value is greater than or equal to size,\n  truncation occurred. If loss of data matters, the caller must either\n  check the arguments before the call, or test the function return\n  value. strlcpy() is not present in glibc and is not standardized by\n  POSIX, but is available on Linux via the libbsd library. Yes, you are reading this right: The man page of a glibc function contains a hint to a non-standardized function in another library which does the job better. This might prove how important this issue is. By the way, I'll never get why the designers of the str(n)cpy() functions didn't chose the number of bytes copied or a pointer to the new end of dest as return value. Returning just dest seems silly because those functions do not change that parameter, so in every case it is still known to the caller when the function has returned, and hence this choice does not make any sense. Did I miss something? Until I knew about strlcpy(), I mostly have used my own string concatenation functions, something like @Joshua Taylor has shown in his answer. This idea has its own problems, though:  Scanning / copying strings byte by byte might be very inefficient. Depending on the target CPU, we should use the 32-bit or even 64-bit registers and copy multiple bytes at a time. Of course, this makes the function more complicated since we have to check if enough bytes remain to be copied, and if not, use the next smaller register size. To further improve performance, we should use assembly code to implement our function. AFAIK, libraries like glibc and libbsd have it implemented that way. So it might be best to use the libbsd implementation. I have not done performance measurements, though.", "abstract": ""}, {"id": 46607212, "score": 0, "vote": 0, "content": "Check this https://john.nachtimwald.com/2017/02/26/efficient-c-string-builder/ It helped me Copy an char** to clipboard in the blink of an eye ", "abstract": ""}, {"id": 39541770, "score": 0, "vote": 0, "content": "I use this variant which is more of a drop-in replacement for strcat, though not exactly: The return value is not important here.\nA char array char str[32] does not contain storage for an actual pointer to the characters (to get a pointer to again), so you can do: or because storage for the pointer is now created on the stack for myfunction(). A length constrained version would be:", "abstract": ""}, {"id": 21886525, "score": 3, "vote": 0, "content": "To concatenate multiple strings, code may use strlen() and memcpy() which are both often well optimized functions.  With this approach, easy to add an inexpensive size limit.\nGiven the real chance the destination buffer may overflow otherwise, a size limit is essential. Run time proportional to the sum of string lengths: O(len(S[0]) + len(S[1]) + len(S[2]) + ...)", "abstract": ""}, {"id": 21884334, "score": 18, "vote": 0, "content": "If you want it easy, fast, general, and safe, I suggest using the open_memstream() function (it's a part of the POSIX-2008 standard, unfortunately it did not make it into the C11 standard, thought). It works like this: First, you hand it the address of a pointer and a size the return value is a file stream just as if you had used fopen() to open a file. As such, you can use the entire arsenal of fprintf() & co. to stream anything you like to your memory buffer, which is automatically allocated and managed for you. Most importantly, it also keeps track of the size of the accumulated string, so it does not have to rescan it to compute its size. Finally, you close the stream, which will update your result pointer and the size variable to reflect the actual amount of string data written.", "abstract": ""}, {"id": 21881314, "score": 39, "vote": 0, "content": "Joel Spolsky, in his Back to Basics article, describes the problem of inefficient string concatenation with strcat as the Shlemiel the painter's algorithm (read the article, it's quite good).  As an example of inefficient code, he gives this example, which runs in O(n2) time: It's not really a problem to walk over the first string the first time;  since we've already got to walk over the second string, the runtime of one strcat is linear in the length of the result. Multiple strcats is problematic though, because we walk over the previously concatenated results again and again.  He provides this alternative: How do we fix this? A few smart C programmers implemented their own\n  mystrcat as follows: What have we done here? At very little extra cost we're returning a\n  pointer to the end of the new, longer string. That way the code that\n  calls this function can decide to append further without rescanning\n  the string: This is, of course, linear in performance, not n-squared, so it\n  doesn't suffer from degradation when you have a lot of stuff to\n  concatenate. Of course, this is what you can do if you want to use standard C strings.  The alternative that you're describing of caching the length of the string and using a special concatenation function (e.g., calling strcat with slightly different arguments) is sort of a variation on Pascal strings, which Joel also mentioned: The designers of Pascal were aware of this problem and \"fixed\" it by\n  storing a byte count in the first byte of the string. These are called\n  Pascal Strings. They can contain zeros and are not null terminated.\n  Because a byte can only store numbers between 0 and 255, Pascal\n  strings are limited to 255 bytes in length, but because they are not\n  null terminated they occupy the same amount of memory as ASCIZ\n  strings. The great thing about Pascal strings is that you never have\n  to have a loop just to figure out the length of your string. Finding\n  the length of a string in Pascal is one assembly instruction instead\n  of a whole loop. It is monumentally faster. \u2026 For a long time, if you wanted to put a Pascal string literal in your\n  C code, you had to write: Yep, you had to count the bytes by hand, yourself, and hardcode it\n  into the first byte of your string. Lazy programmers would do this,\n  and have slow programs:", "abstract": ""}, {"id": 21881332, "score": 1, "vote": 0, "content": "Assume you have two string: s1 and s2 with length l1 and l2 Concatenation means that you should generate a new string s3 with length l1+l2. The time complexity of this operation is O(l1+l2). From this point of view, strcat() seems to be the best choice. However, if you want to indicate the state that two strings are concatenated, then you only need to record their pointers, which is O(1). A simple example would be like this:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/69433075/the-most-efficient-way-o-3-strings-concatenation-in-java-8", "keywords": [], "tags": ["java", "string", "performance", "string-concatenation"], "question": {"id": 69433075, "title": "The most efficient way o 3 Strings concatenation in java 8", "content": "I have a multithreaded Http server in Java 8\nwhich gets thousands of requests per second and has to create responses which require String concatenation. What is the best (fastest) solution to this problem? I know that in general StringBuilder has much better performance than + operator and I thought StringBuilder will be the best solution but in this case I would have to initialize new StringBuilder for each request. Moreover, in my problem concatenation always require 3 strings - two of them are final and the middle one is a variable. The variable can take values from the set of ~20 different elements. So the number of possible concatenated strings equals 20 x number_of_different_strings which is about 2000. Is it better to use StringBuilder or just concatenate Strings (the number will not exceed 2k different strings) or maybe its better to store all created Strings (about 2k) in map and ask for specific one each time?", "abstract": ""}, "answers": [{"id": 69433190, "score": 1, "vote": 0, "content": "I know that in general StringBuilder has much better performance than + operator That is not exactly true. In fact, when you use the + operator, the Java compiler will convert that into using StringBuilder in the compiled code. The issue is the following. Look at the following code: Every time you use the + operator, the Java compiler will create a StringBuilder to perform that operation. The compiler converts the above into something like this: Note that this is very inefficient code. In each iteration of the loop, a new StringBuilder object is created. The data contained in the string result is copied into that StringBuilder. Then the next name is appended to it, and then the data in the StringBuilder is copied into a new String which is assigned to result. There is a lot of unnecessary copying going on. You can write much more efficient code by using StringBuilder directly: This way, only one StringBuilder object is created and data is not being copied into it and into a String in each iteration in the loop. If your code does not involve appending many strings in a loop, and you just have to concatenate three strings, then it does not matter if you use + or a StringBuilder explicitly. In fact, the code written with + would be compiled into exactly the same as what you would write when you would use StringBuilder manually.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/36121370/most-efficient-way-to-concatenate-strings", "keywords": [], "tags": ["java", "stringbuffer"], "question": {"id": 36121370, "title": "Most efficient way to concatenate Strings", "content": "I was under the impression that StringBuffer is the fastest way to concatenate strings, but I saw this Stack Overflow post saying that concat() is the fastest method. I tried the 2 given examples in Java 1.5, 1.6 and 1.7 but I never got the results they did. My results are almost identical to this Can somebody explain what I don't understand here? What is truly the fastest way to concatenate strings in Java? Is there a different answer when one seeks the fastest way to concatenate two strings and when concatenating multiple strings?", "abstract": ""}, "answers": [{"id": 69003451, "score": 1, "vote": 0, "content": "Joining very long lists os strings by naively addinging them from start to end is very slow: the padded buffer grows incrementally, and is reallocated again and again, making additional copies (and sollicitating a lot the garbage collector). The most efficient way to join long lists is to always start by joining pairs of adjascent strings whose total length is the smallest from ALL other candidate pairs; however this would require a complex lookup to find the optimal pair (similar to the wellknown problem of Hanoi towers), and finding it only to reduce the numebr of copies to the strict minimum would slow down things. What you need a smart algorithm using a \"divide and conquer\" recursive algorithm with a good heuristic which is very near from this optimum: Note that empty strings in the collection have to be ignored as if they were not part of the set. Many default implementations of String.join(table of string, optional separator) found in various libraries are slow as they are using naive incremental joinining from left to right; the divide-and-conquer algorithm above will outperform it, when you need to join MANY small string to generate a very large string. Such situation is not exceptional, it occurs in text preprocessors and generators, or in HTML processing (e.g. in \"Element.getInnerText()\" when the element is a large document containing many text elements separated or contained by many named elements). The strategy above works when the source strings are all (or almost all to be garbage collected to keep only the final result. If th result is kept together as long as the list of source strings, the best alternative is to allocate the final large buffer of the result only once for its total length, then copy source strings from left to right. In both cases, this requires a first pass on all strings to compute their total length. If you usse a reallocatable \"string buffer\", this does not work well if the \"string buffer\" reallocates constantly. However, the string buffer may be useful when performing the first pass, to prejoin some short strings that can fit in it, with a reasonnable (medium) size (e.g. 4KB for one page of memory): once it is full, replace the subset of strings by the content of the string buffer, and allocate a new one. This can considerably reduce the number of small strings in the source set, and after the first pass, you have the total length for the final buffer to allocate for the result, where you'll copy incrementally all the remaining medium-size strings collected in the first pass This works very well when the list of source strings come from a parser function or generator, where the total length is not fully known before the end of parsing/generation: you'll use only intermediate stringbuffers with medium size, and finally you'll generate the final buffer without reparsing again the input (to get many incremental fragments) or without calling the generator repeatedly (this would be slow or would not work for some generators or if the input of the parser is consumed and not recoverable from the start). Note that this remarks also applies not just to joinind strings, but also to file I/O: writing the file incrementally also suffers from reallocation or fragmentation: you should be able to precompute the total final length of the generated file. Otherwise you need a classig buffer (implemented in most file I/O libraries, and usually sized in memory at about one memory page of 4KB, but you should allocate more because file I/O is considerably slower, and fragmentation becomes a performance problem for later file accesses when file fragments are allocated incrementalyy by too small units of just one \"cluster\"; using a buffer at about 1MB will avoid most pperformance problems caused by fragmented allocation on the file system as fragments will be considerably larger; a filesystem like NTFS is optimized to support fragments up to 64MB, above which fragmentation is no longer a noticeable problem; the same is true for Unix/Linux filesystems, which rend to defragment only up to a maximum fragment size, and can efficiently handle allocation of small fragments using \"pools\" of free clusters organized by mimum size of 1 cluster, 2 cluster, 4 clusters, 8 clusters... in powers of two, so that defragmenting these pools is straightforward and not very costly, and can be done asynchornously in the background when there's lo level of I/O activity). An in all modern OSes, memory management is correlated with disk storage management, using memory mapped files for handling caches: the memory is backed by a storage, managed by the virtual memory manager (which means that you can allocate more dynamic memory than you have physical RAM, the rest will be paged out to the disk when needed): the straegy you use for managing RAM for very large buffers tends to be correlated to the performance of I/O for paging: using a memory mapped file is a good solution, and everything that worked with file I/O can be done now in a very large (virtual) memory.", "abstract": ""}, {"id": 36121514, "score": 15, "vote": 0, "content": "String.concat is faster than the + operator if you are concatenating two strings...  Although this can be fixed at any time and may even have been fixed in java 8 as far as I know. The thing you missed in the first post you referenced is that the author is concatenating exactly two strings, and the fast methods are the ones where the size of the new character array is calculated in advance as str1.length() + str2.length(), so the underlying character array only needs to be allocated once. Using StringBuilder() without specifying the final size, which is also how + works internally, will often need to do more allocations and copying of the underlying array. If you need to concatenate a bunch of strings together, then you should use a StringBuilder.  If it's practical, then precompute the final size so that the underlying array only needs to be allocated once.", "abstract": ""}, {"id": 36121507, "score": 6, "vote": 0, "content": "What I understood from others answer is following: If you need thread safety, use StringBuffer If strings are known before hand and for some reasons multiple time same code needs to be run, use '+' as compiler will optimize and handle it during compile time itself. if only two strings need to be concatenated, use concat() as it will not require StringBuilder/StringBuffer objects to be created. Credits to @nickb If multiple strings need to be concatenated, use StringBuilder.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/64980766/fastest-way-to-concatenate-two-strings-in-python", "keywords": [], "tags": ["python", "python-3.x", "string", "performance"], "question": {"id": 64980766, "title": "Fastest Way to Concatenate Two Strings in Python", "content": "Given two arbitrary strings: When concatenated they produce 'start end' What is the fastest way to concatenate the two strings?", "abstract": ""}, "answers": [{"id": 64980767, "score": 2, "vote": 0, "content": "Method 1: a += b Method 2: a + b Method 3: ''.join((a, b)) Method 4: '{0}{1}'.format(a, b) Method 5: f'{a}{b}' Method 6: '%s%s' % (a, b) We can utilize the timeit library to test each method. With this example code, we run each method 10000 times and return the average time it takes. As you can see, Method 2, a + b is the fastest concatenation method.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/63388179/what-is-the-most-efficient-way-to-concatenate-strings-in-dart", "keywords": [], "tags": ["dart"], "question": {"id": 63388179, "title": "What is the most efficient way to concatenate strings in Dart?", "content": "Languages like Java, let you concatenate Strings using '+\" operator. But as strings are immutable, they advise one to use StringBuilder for efficiency if one is going to repeatedly concatenate a string. What is the most efficient way to concatenate Strings in Dart ? https://api.dart.dev/stable/2.9.1/dart-core/StringBuffer-class.html It appears that if one uses StringBuffer, one is postponing the performance hit till toString is called?", "abstract": ""}, "answers": [{"id": 63390274, "score": 4, "vote": 0, "content": "There are a number of ways to concatenate strings: String.operator +: string1 + string2. This is the most straightforward.  However, if you need to concatenate a lot of strings, using + repeatedly will create a lot of temporary objects, which is inefficient. (Also note that unlike other concatenation methods, + will throw an exception if either argument is null.) String interpolation: '$string1$string2'.  If you need to concatenate a fixed number of strings that are known in advance (such that you can use a single interpolating string), I would expect this to be reasonably efficient.  If you need to incrementally build a string, however, this would have the same inefficiency as +. StringBuffer.  This is efficient if you need to concatenate a lot of strings. Iterable.join: [string1, string2].join().  This internally uses a StringBuffer so would be equivalent. If you need to concatenate a small, fixed number of strings, I would use string interpolation.  It's usually more readable than using +, especially if there are string literals involved.  Using StringBuffer in such cases would add some unnecessary overhead.", "abstract": ""}, {"id": 63388180, "score": 0, "vote": 0, "content": "Here is what I understood: It appears that performance will vary depending on your use case. If you use StringBuffer, and intend to concatenate a very large string, then as the concatenation occurs only when you call toString, it is at that point where you get the \"performance hit\". But if you use \"+\", then each time you call \"+\" there is a performance hit. As strings are immutable, each time you concatenate two strings you are creating a new object which needs to be garbage collected. Hence the answer seems to be to test for your situation, and determine which option makes sense.", "abstract": ""}]}]