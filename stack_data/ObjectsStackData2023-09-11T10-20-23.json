[{"link": "https://stackoverflow.com/questions/54722509/constructor-overloading-in-python-with-default-arguments", "keywords": [], "tags": ["python", "class", "constructor-overloading"], "question": {"id": 54722509, "title": "Constructor overloading in python with default arguments", "content": "I defined a class in python as following. I created an object for this class, It works fine. And I expected the following object creation will work, But It throws an error saying, But If I change the definition of the class as follows, Now obj1 = myclass(\"01-Feb-2019\") works. But obj = myclass() throws the following error, Could we define a constructor overloading in Python? Could I define a constructor which accepts the empty argument as well as one argument?", "abstract": ""}, "answers": [{"id": 71250748, "score": 0, "vote": 0, "content": "Use multipledispatch(link) module to overload methods A Dispatcher object stores and selects between different\nimplementations of the same abstract operation. It selects the\nappropriate implementation based on a signature, or list of types. We\nbuild one dispatcher per abstract operation. The dispatch decorator hides the creation and manipulation of\nDispatcher objects from the user. Using @dispatch wrapper to overload methods:", "abstract": ""}, {"id": 54723426, "score": 1, "vote": 0, "content": "As others have written, Python does not support multiple constructors *). However you can emulate them easily as follows: Then you can do *) except if you go for multi-dispatch - making use of Python's powerful inspection features Note that assigning default values in the method declaration should be done very reluctantly as it may work differently than one thinks coming from another language. The proper way to define default values would be using \nNone and assign default values like this", "abstract": ""}, {"id": 54723366, "score": 0, "vote": 0, "content": "Python doesn't have multiple constructors - see Multiple constructors in python?", "abstract": ""}, {"id": 54722936, "score": 0, "vote": 0, "content": "Unlike Java or C#, you cannot define multiple constructors. However, you can define a default value if one is not passed.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/13989304/no-constructor-overloading-in-python-disadvantage", "keywords": [], "tags": ["python"], "question": {"id": 13989304, "title": "No constructor overloading in Python - Disadvantage?", "content": "I was going through DiveIntoPython and came across this: Java and Powerbuilder support function overloading by argument list,\n  i.e. one class can have multiple methods with the same name but a\n  different number of arguments, or arguments of different types. Other\n  languages (most notably PL/SQL) even support function overloading by\n  argument name; i.e. one class can have multiple methods with the same\n  name and the same number of arguments of the same type but different\n  argument names. Python supports neither of these; it has no form of\n  function overloading whatsoever. Methods are defined solely by their\n  name, and there can be only one method per class with a given name. So\n  if a descendant class has an __init__ method, it always overrides the\n  ancestor __init__ method, even if the descendant defines it with a\n  different argument list. And the same rule applies to any other\n  method. Isn't this a major disadvantage that a subclass's __init__ method will always override a superclass's __init__ method? So if I'm initializing some variables and calling some functions in a class class1's __init__, then I derive a subclass class2(class1) of it, I'd have to reinitialize all of class1's variables and call those functions in class2's __init__? I'm pretty sure I'm misunderstanding all this, so it'd be great if someone clarifies this up.", "abstract": ""}, "answers": [{"id": 13989519, "score": 2, "vote": 0, "content": "So if I'm initializing some variables and calling some functions in a class class1's __init__, then I derive a subclass class2(class1) of it, I'd have to reinitialize all of class1's variables and call those functions in class2's __init__? No. You just have to call the superclass's __init__(). Here, and here, you can find how to do it.", "abstract": ""}, {"id": 13989367, "score": 14, "vote": 0, "content": "You're right that defining __init__ in a subclass overrides the superclass's __init__, but you can always use super(CurrentClass, self).__init__ to call the superclass's constructor from the subclass. So, you don't have to \"manually\" duplicate the superclass's initialization work. As a side note, even though Python doesn't support method overloading, it supports default arguments (in addition to optional arguments via *args and **kwargs), which means you can easily emulate the behavior of overloaded functions by simply accepting different subsets of arguments in your function/method implementation.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/62155901/python-constructor-overloading", "keywords": [], "tags": ["python", "class"], "question": {"id": 62155901, "title": "Python Constructor Overloading", "content": "I have come across the notion of class constructors in C++. But I have not yet found a way to initialize a class in Python using 2 or more different methods. Could anyone tell how to go about that?", "abstract": ""}, "answers": [{"id": 67063347, "score": 0, "vote": 0, "content": "@Ratan Rithwik solution is correct but only only 2 cases If you want to have as many case as you want, you can use **kwarg\none example with @thebjorn answer EDIT: mixing 'standard' parameter (having default value) and kwargs", "abstract": ""}, {"id": 62156222, "score": 2, "vote": 0, "content": "You don't need multiple constructors in python, you can use the following way to initialize if you have multiple such a case So when you need to initialize an object of class A, you can use Though strictly speaking __init__ is not a constructor but an initialiser", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/66687053/how-to-overload-constructors-in-python", "keywords": [], "tags": ["python", "data-structures"], "question": {"id": 66687053, "title": "How to overload constructors in python?", "content": "Suppose I want to send a list in python and I will have a MyList class that will have 3 constructors. sending an empty list would return nothing, sending a list would convert it into a linked list and sending a linked list will copy its item and make another linkedlist from it Task 1:\ni) Create a Node class that will hold two fields i.e an integer element and a reference to the next Node.\nii) Create a Linked list Abstract Data Type (ADT)named MyList.The elements in the list are Nodes consisting of an integer type key (all keys are unique) and a reference to the next node. Task 2:\nConstructors:(3) MyList ( )\nPre-condition: None.\nPost-condition: This is the default constructor of MyList class. This constructor creates an empty list. b. MyList (int [] a) or Myst(a)\nPre-condition: Array cannot be empty.\nPost-condition: This is the default constructor of MyList class. This constructor creates a list from an array. c. MyList (MyList a) or MyList(a) Pre-condition: List cannot be empty.\nPost-condition: This is the default constructor of MyList class. This constructor creates a list from another list.", "abstract": ""}, "answers": [{"id": 66687583, "score": 0, "vote": 0, "content": "For Task 2 : You can try something like this, by checking the input in the constructor of your class:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/58142838/overloading-constructors-in-python", "keywords": [], "tags": ["python"], "question": {"id": 58142838, "title": "Overloading constructors in Python", "content": "Simply, what is the cleanest or most commonly used way in which constructors are overloaded in Python? I have experience in C# and am new to Python, so I'm still learning what is best practice in Python. C# has a very clean way of overloading constructors, so that I can handle different data types being passed as arguments on initialization. I have seen a lot of different answers in how similar results can be achieved in Python, and I don't NOT want default parameters or logic within my constructor to handle different data types!!! And I can not understand why people are recommending this as an alternative. Here is some C# code, and I basically want to do the same in Python. The above code is just an example. I know there are hacks, like testing argument type and adding this logic to my constructor or accepting that Python is not strongly typed and writing logic in my class methods for how value2 may be handled for different types. However, the code I am writing is not as simple as the above. I want to handle how arguments of different objects or data types are handled. I would like to overload my constructor for handling objects of different classes and data type i.e. I could pass an object of MyObject<MyObjectClass> or a JSON file or text file/CSV file, etc. And I do not want a hacky if statement to test if a JSON file is passed. This is because potentially my constructor for passing a CSV file will contain further arguments and/or different arguments from passing a JSON file. I find the way in which C# handles overloading constructors much cleaner as I can easily add further arguments to my JSON file constructor in the future and I only need to fiddle with the one constructor! I'm sure Python has a very clean way of achieving the same...? It just hit me that overloading is probably non-existent in Python as it is not statically typed. And therefore I am assuming class methods are best suited for my purpose._", "abstract": ""}, "answers": [{"id": 58142873, "score": 8, "vote": 0, "content": "Let's say, you have a class Book: Now, you wish to consume a web API that returns book data and want to instantiate a Book object directly from the API\u2019s JSON response. You'll have to change the init method and add a check. But this kind of approach is not good as per industry standards. Hence, use can try using the @classmethod decorator For detailed description, see this link.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/58858556/how-can-i-perform-constructor-overloading-in-python", "keywords": [], "tags": ["python", "constructor", "overloading"], "question": {"id": 58858556, "title": "How can i perform constructor overloading in python?", "content": "I have an employee class which I would like to fill in two different ways, and would like to know do this by constructor overloading This is because, either I have to initialise the class like  Or I would like to initialise the class by passing a tuple like", "abstract": ""}, "answers": [{"id": 58858659, "score": 2, "vote": 0, "content": "You don't, really. You could mess around with a definition like then do lots of processing that checks the number of arguments, the type of the first argument, etc. Or, you can simply be explicit and define a separate constructor whose name describes exactly what it does. The class method can do some validation on the tuple before passing its contents to the default constructor. Of course, the simplicity of the class method's definition suggests that you don't need to go to this much trouble: if you know the tuple has the right number and kinds of values, just unpack data for use with the default constructor. By \"default constructor\", I mean the method which Employee.__new__ resolves to. Employee.__init__ is technically an initializer, invoked when appropriate on an already constructed instance returned by __new__.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/51541712/classmethod-for-constructor-overloading", "keywords": [], "tags": ["python", "python-3.x", "constructor", "class-method"], "question": {"id": 51541712, "title": "@classmethod for constructor overloading", "content": "I usually use isinstance for constructor overloading, but people also suggests @classmethod for the same. But to my knowledge @classmethod shares the variable. Below is a simple class Now, lets make three objects The output: Now I have two questions,", "abstract": ""}, "answers": [{"id": 51542271, "score": 2, "vote": 0, "content": "Maybe you want to init the instance first, then assign b inside your class to it. Here's the idea : Output: ", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/51515380/python-constructor-overload-with-different-number-of-parameters", "keywords": [], "tags": ["python", "constructor", "overloading", "init"], "question": {"id": 51515380, "title": "Python constructor overload with different number of parameters", "content": "I am trying to build a complex number calculator in python. The number will be represented by a class with two fields. The first constructor I want to use looks like this: but i would like to use another, where the only parameter will be a string representing the whole number: How to implement the overload that allows to use different number of parameters? I am more used to C++, where such thing was easy.\nThanks a lot! EDIT:\nQuestion marked as duplicate:  I did not find any answer regarding different number of parameters. The error I get when trying to build a new instance of the class is about to few arguments.", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/46473267/constructor-overloading-in-python", "keywords": [], "tags": ["python"], "question": {"id": 46473267, "title": "Constructor Overloading in Python", "content": "I am reading through Python and came across various ways to somehow perform overloading in Python(most of them suggested use of @classmethod). But I am trying to do something like this as shown in below code. I have kept all the parameters required in the init method itself. What all possible problems may arise from my choice of overloading? Now I can create any number of Vehicle objects with different parameters each time. I can say something like: or even And later I can say something like v3.w = 10 #for truck and it still works. So my question is: Is it correct way of overloading apart from @classmethod? What difficulties can I run in later down the path if I use this kind of code?", "abstract": ""}, "answers": [{"id": 51047838, "score": 0, "vote": 0, "content": "I just went though this same problem and looking into the documentation on Python 3.6 @classmethod is a decorator that is actually short hand for some deeper programming concepts.  For anyone like me whose just trying to unpack what python is doing here, in C# or Java I would explain @classmethod as a function that creates a delegate typed to a class, points the delegate at such a classes constructor/method, returns that constructor/method, and allows the returned constructor/method to be used in whatever you define below @classmethod.  So essentially, @classmethod is really a syntactical shortcut that does a lot of things. What OP is doing here is using this syntactic shortcut to create a \"factory\" which is a very common way of creating instances in many different languages.   I do think its important however to realize that unlike other simple things that you might do in python, there is a lot going on under the hood here.  While it's not wrong, it might be more efficient to create a simple factory depending on what you want to get out of it. If you don't have a back ground in any other languages, I could try to simplify the answer by saying that @classmethod it returns a function to the function that you define below it.  Here's the documentation on Python 3.6.  Scroll down to \"decorators\" to see what it says.  https://docs.python.org/3/glossary.html#term-decorator", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/141545/how-to-overload-init-method-based-on-argument-type", "keywords": [], "tags": ["python", "constructor", "operator-overloading"], "question": {"id": 141545, "title": "How to overload __init__ method based on argument type?", "content": "Let's say I have a class that has a member called data which is a list.   I want to be able to initialize the class with, for example, a filename (which contains data to initialize the list) or with an actual list. What's your technique for doing this? Do you just check the type by looking at __class__? Is there some trick I might be missing? I'm used to C++ where overloading by argument type is easy. ", "abstract": ""}, "answers": [{"id": 49936625, "score": 46, "vote": 0, "content": "with python3, you can use Implementing Multiple Dispatch with Function Annotations as Python Cookbook wrote: and it works like:", "abstract": ""}, {"id": 26018762, "score": 0, "vote": 0, "content": "My preferred solution is: Then invoke it with either MyClass() or MyClass([1,2,3]). Hope that helps. Happy Coding!", "abstract": ""}, {"id": 141565, "score": 10, "vote": 0, "content": "A better way would be to use isinstance and type conversion. If I'm understanding you right, you want this:", "abstract": ""}, {"id": 23415425, "score": -1, "vote": 0, "content": "Why don't you go even more pythonic?\n", "abstract": ""}, {"id": 10218436, "score": 15, "vote": 0, "content": "Quick and dirty fix Then you can call it with", "abstract": ""}, {"id": 141571, "score": 4, "vote": 0, "content": "You should use isinstance", "abstract": ""}, {"id": 212130, "score": 41, "vote": 0, "content": "Excellent question. I've tackled this problem as well, and while I agree that \"factories\" (class-method constructors) are a good method, I would like to suggest another, which I've also found very useful: Here's a sample (this is a read method and not a constructor, but the idea is the same): The key idea is here is using Python's excellent support for named arguments to implement this. Now, if I want to read the data from a file, I say: And to read it from a string, I say: This way the user has just a single method to call. Handling it inside, as you saw, is not overly complex", "abstract": ""}, {"id": 141700, "score": 0, "vote": 0, "content": "OK, great. I just tossed together this example with a tuple, not a filename, but that's easy. Thanks all. a = [1,2] b = (2,3) c = MyData(a) d = MyData(b) c.GetData() d.GetData() [1, 2] [2, 3]", "abstract": ""}, {"id": 141777, "score": 553, "vote": 0, "content": "A much neater way to get 'alternate constructors' is to use classmethods. For instance: The reason it's neater is that there is no doubt about what type is expected, and you aren't forced to guess at what the caller intended for you to do with the datatype it gave you. The problem with isinstance(x, basestring) is that there is no way for the caller to tell you, for instance, that even though the type is not a basestring, you should treat it as a string (and not another sequence.) And perhaps the caller would like to use the same type for different purposes, sometimes as a single item, and sometimes as a sequence of items. Being explicit takes all doubt away and leads to more robust and clearer code.", "abstract": ""}, {"id": 141570, "score": 2, "vote": 0, "content": "You probably want the isinstance builtin function:", "abstract": ""}]}]