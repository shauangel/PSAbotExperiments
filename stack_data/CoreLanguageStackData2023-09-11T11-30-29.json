[{"link": "https://stackoverflow.com/questions/3052793/how-do-i-get-a-result-output-from-a-function-how-can-i-use-the-result-later", "keywords": [], "tags": ["python", "function", "return"], "question": {"id": 3052793, "title": "How do I get a result (output) from a function? How can I use the result later?", "content": "Suppose I have a function like: How do I get the function to return x, in such a way that I can use it as the input for another function or use the variable within the body of a program? I tried using return and then using the x variable in another function, but I get a NameError that way. For the specific case of communicating information between methods in the same class, it is often best to store the information in self. See Passing variables between methods in Python? for details.", "abstract": ""}, "answers": [{"id": 3052827, "score": 36, "vote": 0, "content": "You can use the return statement to return a value from a function, this does not make it so that the returned variable (value) becomes available in the scope of the caller. To use the value in the caller you can either use it directly in a statement or capture the value in a variable. Here's some code to demonstrate this:", "abstract": ""}, {"id": 73356335, "score": 8, "vote": 0, "content": "The direct way is to return a value from the function, as you tried, and let the calling code use that value. This is normally what you want. The natural, simple, direct, explicit way to get information back from a function is to return it. Broadly speaking, the purpose of a function is to compute a value, and return signifies \"this is the value we computed; we are done here\". The main trick here is that return returns a value, not a variable. So return x does not enable the calling code to use x after calling the function, and does not modify any existing value that x had in the context of the call. (That's presumably why you got a NameError.) After we use return in the function: we need to write the calling code to use the return value: The other key point here is that a call to a function is an expression, so we can use it the same way that we use, say, the result of an addition. Just as we may say result = 'hello ' + 'world', we may say result = foo(). After that, result is our own, local name for that string, and we can do whatever we want with it. We can use the same name, x, if we want. Or we can use a different name. The calling code doesn't have to know anything about how the function is written, or what names it uses for things.1 We can use the value directly to call another function: for example, print(foo()).2 We can return the value directly: simply return 'hello world', without assigning to x. (Again: we are returning a value, not a variable.) The function can only return once each time it is called. return terminates the function - again, we just determined the result of the calculation, so there is no reason to calculate any further. If we want to return multiple pieces of information, therefore, we will need to come up with a single object (in Python, \"value\" and \"object\" are effectively synonyms; this doesn't work out so well for some other languages.) We can make a tuple right on the return line; or we can use a dictionary, a namedtuple (Python 2.6+), a types.simpleNamespace (Python 3.3+), a dataclass (Python 3.7+), or some other class (perhaps even one we write ourselves) to associate names with the values that are being returned; or we can accumulate values from a loop in a list; etc. etc. The possibilities are endless.. On the other hand, the function returns whether you like it or not (unless an exception is raised). If it reaches the end, it will implicitly return the special value None. You may or may not want to do it explicitly instead. Other than returning the result back to the caller directly, we can communicate it by modifying some existing object that the caller knows about. There are many ways to do that, but they're all variations on that same theme. If you want the code to communicate information back this way, please just let it return None - don't also use the return value for something meaningful. That's how the built-in functionality works. In order to modify that object, the called function also has to know about it, of course. That means, having a name for the object that can be looked up in a current scope. So, let's go through those in order: If one of our parameters is mutable, we can just mutate it, and rely on the caller to examine the change. This is usually not a great idea, because it can be hard to reason about the code. It looks like: If the value is an instance of our own class, we could also assign to an attribute: Assigning to an attribute does not work for built-in types, including object; and it might not work for some classes that explicitly prevent you from doing it. We already have an example of this above: setting self.value in the Test.__init__ code. This is a special case of modifying a passed-in argument; but it's part of how classes work in Python, and something we're expected to do. Normally, when we do this, the calling won't actually check for changes to self - it will just use the modified object in the next step of the logic. That's what makes it appropriate to write code this way: we're still presenting an interface, so the caller doesn't have to worry about the details. In the example, calling add_word gave information back to the top-level code - but instead of looking for it, we just go ahead and call display.3 See also: Passing variables between methods in Python? This is a rare special case when using nested functions. There isn't a lot to say here - it works the same way as with the global scope, just using the nonlocal keyword rather than global.4 Generally speaking, it is a bad idea to change anything in the global scope after setting it up in the first place. It makes code harder to reason about, because anything that uses that global (aside from whatever was responsible for the change) now has a \"hidden\" source of input. If you still want to do it, the syntax is straightforward: This is actually a special case of modifying a global. I don't mean that assignment is a kind of modification (it isn't). I mean that when you assign a global name, Python automatically updates a dict that represents the global namespace. You can get that dict with globals(), and you can modify that dict and it will actually impact what global variables exist. (I.e., the return from globals() is the dictionary itself, not a copy.)5 But please don't. That's even worse of an idea than the previous one. If you really need to get the result from your function by assigning to a global variable, use the global keyword to tell Python that the name should be looked up in the global scope: This is a rare special case, but now that you've seen the other examples, the theory should be clear. In Python, functions are mutable (i.e. you can set attributes on them); and if we define a function at top level, it's in the global namespace. So this is really just modifying a global: We shouldn't really use this to send information to the caller. It has all the usual problems with globals, and it's even harder to understand. But it can be useful to set a function's attributes from within the function, in order for the function to remember something in between calls. (It's similar to how methods remember things in between calls by modifying self.) The functools standard library does this, for example in the cache implementation. This doesn't work. The builtin namespace doesn't contain any mutable objects, and you can't assign new builtin names (they'll go into the global namespace instead). In some other programming languages, there is some kind of hidden variable that automatically picks up the result of the last calculation, every time something is calculated; and if you reach the end of a function without returning anything, it gets returned. That doesn't work in Python. If you reach the end without returning anything, your function returns None. In some other programming languages, you are allowed (or expected) to assign to a variable with the same name as the function; and at the end of the function, that value is returned. That still doesn't work in Python. If you reach the end without returning anything, your function still returns None. It might seem like you can at least use the value that way, if you use the global keyword: But this, of course, is just a special case of assigning to a global. And there's a big problem with it - the same name can't refer to two things at once. By doing this, the function replaced its own name. So it will fail next time: Sometimes people expect to be able to assign to one of the function's parameters, and have it affect a variable that was used for the corresponding argument. However, this does not work: Just like how Python returns values, not variables, it also passes values, not variables. words is a local name; by definition the calling code doesn't know anything about that namespace. One of the working methods that we saw is to modify the passed-in list. That works because if the list itself changes, then it changes - it doesn't matter what name is used for it, or what part of the code uses that name. However, assigning a new list to words does not cause the existing list to change. It just makes words start being a name for a different list. For more information, see How do I pass a variable by reference?. 1 At least, not for getting the value back. If you want to use keyword arguments, you need to know what the keyword names are. But generally, the point of functions is that they're an abstraction; you only need to know about their interface, and you don't need to think about what they're doing internally. 2 In 2.x, print is a statement rather than a function, so this doesn't make an example of calling another function directly. However, print foo() still works with 2.x's print statement, and so does print(foo()) (in this case, the extra parentheses are just ordinary grouping parentheses). Aside from that, 2.7 (the last 2.x version) has been unsupported since the beginning of 2020 - which was nearly a 5 year extension of the normal schedule. But then, this question was originally asked in 2010. 3Again: if the purpose of a method is to update the object, don't also return a value. Some people like to return self so that you can \"chain\" method calls; but in Python this is considered poor style. If you want that kind of \"fluent\" interface, then instead of writing methods that update self, write methods that create a new, modified instance of the class. 4 Except, of course, that if we're modifying a value rather than assigning, we don't need either keyword. 5 There's also a locals() that gives you a dict of local variables. However, this cannot be used to make new local variables - the behaviour is undefined in 2.x, and in 3.x the dict is created on the fly and assigning to it has no effect. Some of Python's optimizations depend on the local variables for a function being known ahead of time.", "abstract": ""}, {"id": 3052997, "score": 3, "vote": 0, "content": "You can use global statement and then achieve what you want without returning value from \nthe function. For example you can do something like below: The above code will print \"hello world\". But please be warned that usage of \"global\" is not a good idea at all and it is better to avoid usage that is shown in my example.  Also check this related discussion on about usage of global statement in Python.", "abstract": ""}, {"id": 3052813, "score": 4, "vote": 0, "content": "", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/13299427/python-functions-call-by-reference", "keywords": [], "tags": ["python", "variables", "reference", "pass-by-reference"], "question": {"id": 13299427, "title": "Python functions call by reference", "content": "In some languages you can pass a parameter by reference or value by using a special reserved word like ref or val. When you pass a parameter to a Python function it never alters the value of the parameter on leaving the function.The only way to do this is by using the global reserved word (or as i understand it currently). Example 1: would show showing k to be unchanged. In this example the variable n is never changed Example 2: In this example the variable n is changed. Is there any way in Python to call a function and tell Python that the parameter is either a value or reference parameter instead of using global?", "abstract": ""}, "answers": [{"id": 33066581, "score": 219, "vote": 0, "content": "There are essentially three kinds of 'function calls': Python is a PASS-BY-OBJECT-REFERENCE programming language. Firstly, it is important to understand that a variable, and the value of the variable (the object) are two seperate things. The variable 'points to' the object. The variable is not the object. Again: THE VARIABLE IS NOT THE OBJECT Example: in the following line of code: [] is the empty list, x is a variable that points to the empty list, but x itself is not the empty list. Consider the variable (x, in the above case) as a box, and 'the value' of the variable ([]) as the object inside the box. PASS BY OBJECT REFERENCE (Case in python): Here, \"Object references are passed by value.\" Here, the statement x = [0] makes a variable x (box) that points towards the object [0]. On the function being called, a new box li is created. The contents of li are the SAME as the contents of the box x. Both the boxes contain the same object. That is, both the variables point to the same object in memory. Hence, any change to the object pointed at by li will also be reflected by the object pointed at by x. In conclusion, the output of the above program will be: Note: If the variable li is reassigned in the function, then li will point to a separate object in memory. x however, will continue pointing to the same object in memory it was pointing to earlier. Example: The output of the program will be: PASS BY REFERENCE: The box from the calling function is passed on to the called function. Implicitly, the contents of the box (the value of the variable) is passed on to the called function. Hence, any change to the contents of the box in the called function will be reflected in the calling function. PASS BY VALUE: A new box is created in the called function, and copies of contents of the box from the calling function is stored into the new boxes.", "abstract": ""}, {"id": 60979567, "score": 10, "vote": 0, "content": "Technically python do not pass arguments by value: all by reference. But ... since python has two types of objects: immutable and mutable, here is what happens: Immutable arguments are effectively passed by value: string, integer, tuple are all immutable object types. While they are technically \"passed by reference\" (like all parameters), since you can't change them in-place inside the function it looks/behaves as if it is passed by value. Mutable arguments are effectively passed by reference: lists or dictionaries are passed by its pointers. Any in-place change inside the function like (append or del) will affect the original object. This is how Python is designed: no copies and all are passed by reference. You can explicitly pass a copy. Last point I would like to mention which is a function has its own scope.", "abstract": ""}, {"id": 63567958, "score": 0, "vote": 0, "content": "", "abstract": ""}, {"id": 60313314, "score": 1, "vote": 0, "content": "Consider that the variable is a box and the value it points to is the \"thing\" inside the box: 1. Pass by reference : function shares the same box and thereby the thing inside also. 2. Pass by value : function creates a new box, a replica of the old one, including a copy of whatever thing is inside it. Eg. Java - functions create a copy of the box and the thing inside it which can be: a primitive / a reference to an object. (note that the copied reference in the new box and the original both still point to the same object, here the reference IS the thing inside the box, not the object it is pointing to) 3. Pass by object-reference: the function creates a box, but it encloses the same thing the initial box was enclosing. So in Python: a) if the thing inside said box is mutable, changes made will reflect back in the original box  (eg. lists) b) if the thing is immutable (like python strings and numeric types), then the box inside the function will hold the same thing UNTIL you try to change its value. Once changed, the thing in the function's box is a totally new thing compared to the original one. Hence id() for that box will now give the identity of the new thing it encloses.", "abstract": ""}, {"id": 13299557, "score": 88, "vote": 0, "content": "You can not change an immutable object, like str or tuple, inside a function in Python, but you can do things like: That is a weird way to go about it, however, unless you need to always square certain elements in an array. Note that in Python, you can also return more than one value, making some of the use cases for pass by reference less important: When you return values like that, they are being returned as a Tuple which is in turn unpacked. edit:\nAnother way to think about this is that, while you can't explicitly pass variables by reference in Python, you can modify the properties of objects that were passed in. In my example (and others) you can modify members of the list that was passed in. You would not, however, be able to reassign the passed in variable entirely. For instance, see the following two pieces of code look like they might do something similar, but end up with different results:", "abstract": ""}, {"id": 31571065, "score": 10, "vote": 0, "content": "Python is neither pass-by-value nor pass-by-reference.  It's more of \"object references are passed by value\" as described here:   Here's why it's not pass-by-value.  Because returns [0,1] showing that some kind of reference was clearly passed as pass-by-value does not allow a function to alter the parent scope at all. Looks like pass-by-reference then, hu?  Nope. Here's why it's not pass-by-reference. Because returns [0] showing that the original reference was destroyed when list was reassigned.  pass-by-reference would have returned [0,1]. For more information look here:  If you want your function to not manipulate outside scope, you need to make a copy of the input parameters that creates a new object.", "abstract": ""}, {"id": 44400540, "score": -2, "vote": 0, "content": "Python already call by ref..  let's take example: OutPut ", "abstract": ""}, {"id": 16893441, "score": 28, "vote": 0, "content": "Hope the following description sums it up well: There are two things to consider here - variables and objects.  Example: O/P: Example: O/P: Example:  O/P:", "abstract": ""}, {"id": 13300388, "score": 30, "vote": 0, "content": "OK, I'll take a stab at this. Python passes by object reference, which is different from what you'd normally think of as \"by reference\" or \"by value\". Take this example: So you're creating a string object with value 'some value' and \"binding\" it to a variable named bar. In C, that would be similar to bar being a pointer to 'some value'. When you call foo(bar), you're not passing in bar itself. You're passing in bar's value: a pointer to 'some value'. At that point, there are two \"pointers\" to the same string object. Now compare that to: Here's where the difference lies. In the line: you're not actually altering the contents of x. In fact, that's not even possible. Instead, you're creating a new string object with value 'another value'. That assignment operator? It isn't saying \"overwrite the thing x is pointing at with the new value\". It's saying \"update x to point at the new object instead\". After that line, there are two string objects: 'some value' (with bar pointing at it) and 'another value' (with x pointing at it). This isn't clumsy. When you understand how it works, it's a beautifully elegant, efficient system.", "abstract": ""}, {"id": 13299992, "score": 0, "vote": 0, "content": "The answer given is and  which is the best answer so far as it does what it says in the question. However,it does seem a very clumsy way compared to VB or Pascal.Is it the best method we have? Not only is it clumsy, it involves mutating the original parameter in some way manually eg by changing the  original parameter to a list: or copying it to another list rather than just saying: \"use this parameter as a  value \" or \"use this  one as a  reference\". Could the simple answer be there is no reserved word for this but these are great work arounds?", "abstract": ""}, {"id": 13299566, "score": 3, "vote": 0, "content": "So this is a little bit of a subtle point, because while Python only passes variables by value, every variable in Python is a reference. If you want to be able to change your values with a function call, what you need is a mutable object. For example: In the above code, the function modifies the contents of a List object (which is mutable), and so the output is 3 instead of 0. I write this answer only to illustrate what 'by value' means in Python. The above code is bad style, and if you really want to mutate your values you should write a class and call methods within that class, as MPX suggests.", "abstract": ""}, {"id": 13299552, "score": -2, "vote": 0, "content": "In Python the passing by reference or by value has to do with what are the actual objects you are passing.So,if you are passing a list for example,then you actually make this pass by reference,since the list is a mutable object.Thus,you are passing a pointer to the function and you can modify the object (list)  in the function body. When you are passing a string,this passing is done by value,so a new string object is being created and when the function terminates it is destroyed.\nSo it all has to do with mutable and immutable objects.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/4702249/is-there-a-way-in-python-to-return-a-value-via-an-output-parameter", "keywords": [], "tags": ["python"], "question": {"id": 4702249, "title": "Is there a way in Python to return a value via an output parameter?", "content": "Some languages have the feature to return values using parameters also like C#.\nLet\u2019s take a look at an example: So is there anything similar in Python to get a value using parameter, too?", "abstract": ""}, "answers": [{"id": 74505976, "score": 0, "vote": 0, "content": "Adding to Tark-Tolonen's answer: Please absolutely avoid altering the object reference of the output argument in your function, otherwise the output argument won't work. For instance, I wish to pass an ndarray into a function my_fun and modify it After calling my_fun, array a stills remains all zeros since the function np.ones_like returns a reference to another array full of ones and assigns it to out_arr instead of modifying the object reference passed by out_arr directly. Running this code you will find that two print(id()) gives different memory locations. Also, beware of the array operators from numpy, they usually returns a reference to another array if you write something like this Using the - and = operator might cause similar problems. To prevent having out_arr's memory location altered, you can use the numpy functions that does the exactly same operations but has a out parameter built in. The proceeding code should be rewritten as And the memory location of out_arr remains the same before and after calling my_fun while its values gets modified successfully.", "abstract": ""}, {"id": 4702280, "score": 86, "vote": 0, "content": "Python can return a tuple of multiple items: But you can also pass a mutable parameter, and return values via mutation of the object as well:", "abstract": ""}, {"id": 4702272, "score": 9, "vote": 0, "content": "You mean like passing by reference? For Python object the default is to pass by reference. However, I don't think you can change the reference in Python (otherwise it won't affect the original object). For example:", "abstract": ""}, {"id": 4702442, "score": 1, "vote": 0, "content": "You can do that with mutable objects, but in most cases it does not make sense because you can return multiple values (or a dictionary if you want to change a function's return value without breaking existing calls to it). I can only think of one case where you might need it - that is threading, or more exactly, passing a value between threads.", "abstract": ""}, {"id": 4702301, "score": 1, "vote": 0, "content": "In addition, if you feel like reading some code, I think that pywin32 has a way to handle output parameters. In the Windows API it's common practice to rely heavily on output parameters, so I figure they must have dealt with it in some way.", "abstract": ""}, {"id": 4702267, "score": 4, "vote": 0, "content": "Pass a list or something like that and put the return value in there.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/72341337/how-can-i-write-my-own-function-that-accepts-and-uses-a-function-as-a-parameter", "keywords": [], "tags": ["python", "functional-programming", "higher-order-functions"], "question": {"id": 72341337, "title": "How can I write my own function that accepts and uses a function as a parameter?", "content": "I have seen several examples, in the standard library and major third-party libraries, of functions (and methods) that accept a function as input. For example, consider the apply method of Pandas DataFrames. The documentation of the method suggests you can pass another function like sum() or numpy.sqrt() into the function, like  apply(sum) or apply(numpy.sqrt). Similarly, the standard library sorted function explicitly documents that key specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). How can I write my own function that works this way, accepting a function as one of the inputs?", "abstract": ""}, "answers": [{"id": 72341442, "score": 2, "vote": 0, "content": "You do this the same way that you would write the function to accept anything else. Python's def statements don't require any type specification: You can pass any object; functions are objects; therefore, you can pass functions: To make it possible to pass the function as an argument, you do exactly nothing. The same applies, mutatis mutandis, to methods as well as ordinary functions: \"But how do I use it inside the function?\" Unless you are doing something really unusual (at a research level way beyond this question), the only really interesting thing to do with a function - aside from passing it around like this - is to call it. You call a function by getting the function, then writing the function-call syntax after it (the argument list between parentheses). Functions are objects; you get objects by evaluating an expression; therefore you get functions by evaluating an expression (as long as it actually does evaluate to a function). Normally, that expression is... the function's name, looked up in the global namespace (as in the above examples). But just as is the case with any other object, you can do it other ways. In particular, you can give the value other names - for example, by passing it as a parameter. That's what happens when you call a function: the function uses its parameter name as a name for whatever was passed as an argument. Including if that's another function. Inside the called function, then, you call the passed function by naming it - with the parameter name - and then using the normal function call syntax. Now the (misleading) message is printed. More complex expressions are possible. One common pattern is to look them up in a dictionary (although 3.10's match... case construct makes this slightly less useful). Another way is to compile code dynamically (there are a lot of approaches for this; all of them are at least somewhat dangerous, so I will not name or show them here. People with a legitimate use for this, also have the skill to do the necessary research.)", "abstract": ""}, {"id": 72341776, "score": 2, "vote": 0, "content": "A function accepting other functions as argument or returning functions is called higher-order function. So Panda's apply() is a higher-order function. It accepts another function like e.g. sum and calls or invokes it internally as sum(args). To define a higher-order function that accepts a function as argument use a signature as with common functions. In the examples below this will be def md_heading(phrase):. See how to invoke the argument which is expected to be a function: Note: Now try what happens when passing a string literal like `'Hello World' as argument. The invocation of the string passed as argument will raise an error.\nIn exactly that statement return \"# \" + phrase() as: Now you should pass a function as argument, but just as reference (without parentheses): Prints: Hi Or you can pass a lambda as argument: Prints: 'Hello! Note: The lambda must not have a positional argument. This the closes to passing a constant, like the string from the beginning. When we define the lambda with a positional argument like lambda name: \"Hello \" + name here, it will raise: TypeError: <lambda>() missing 1 required positional argument: 'name' because in our higher-order function it is invoked without argument, just as phrase().", "abstract": ""}, {"id": 72341506, "score": 1, "vote": 0, "content": "What's happening because you give in function apply only link in memory for function sum. And in your apply function this link wiil be called. This function returns you sum 28 and 79 (107).", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/65785263/how-to-call-a-c-function-with-an-output-parameter", "keywords": [], "tags": ["python", "dll", "ctypes"], "question": {"id": 65785263, "title": "How to call a C function with an output parameter", "content": "A have code in my dll (on C++). The function must accept a pointer to long as an output variable: I am using Python 3: And I get the error:", "abstract": ""}, "answers": [{"id": 65786490, "score": 1, "vote": 0, "content": "POINTER(ctypes-type) declares a pointer type and its parameter must be a ctypes type, so below was incorrect: When you create a ctype to hold the output parameter, simply create an instance of the type: Then pass it as a parameter by reference with: Also, wrapping input values is generally unncessary if you set .argtypes.  ctypes knows to wrap Python values as declared, so you can just pass them directly. Example: test.c test.py Output: You can create pointers directly with pointer(instance) as well, so below also works, but is less efficient than byref:", "abstract": ""}, {"id": 65785486, "score": 0, "vote": 0, "content": "I modified your code a little to Change the definitions to match.  Following the ideas in the answer to Passing pointers to DLL function in Python , this may help", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/63441764/calling-a-function-with-unknown-number-of-parameters-python", "keywords": [], "tags": ["python", "scikit-learn", "fuzzy-logic"], "question": {"id": 63441764, "title": "Calling a function with unknown number of parameters Python", "content": "I am trying to read in a Fuzzy plain text rule and pass the parameters to a SciKit-Fuzzy function call to create fuzzy rules.\nFor example, if I read in this text rule: Then the function call will be: If text rule is: Then the function call will be: Since each rule can have unlimited number of input variables, e.g. the user can also say: which contains 3 inputs variables service['good'],food['good'],and mood['happy'], and 1 output variable tip['high'].\nI can't think of a way to automatically read in the text rule and convert it to a function call, do you have any idea or suggestion to achieve this goal? Any help will be appreciated. Thanks.", "abstract": ""}, "answers": [{"id": 63442903, "score": 0, "vote": 0, "content": "You could try something like this: But be warned you need to be very very careful with eval. It is a security risk because user can execute code this way!!! Before using this you might to do research on how to prevent this security issue.", "abstract": ""}, {"id": 63443363, "score": 4, "vote": 0, "content": "In python, we can pass an unknown amount of arguments into the function using asterisk notation. Let's try to create a function sum_up() with an unknown number of arguments. As you see, an argument with an asterisk before will collect all arguments given to this function inside a tuple called args. We can call this function that way: But if we want to sum up elements of a list and we need to pass it into the function as arguments... We can try the following: This won't give an effect we need: args of sum_up will look like ([5, 4, 6],).\nTo do what we want, we need to put an asterisk before the argument we're passing: All you need to do is collect all arguments you want to pass in a list and then put an asterisk before this list passed as an argument inside a call:", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/48797834/how-to-change-function-parameter-values-in-a-python-3-c-extension", "keywords": [], "tags": ["python", "c", "python-3.x", "python-c-api", "python-extensions"], "question": {"id": 48797834, "title": "How to change function parameter values in a Python 3 C extension?", "content": "I can't figure out how to change the value of a parameter passed from Python to C.  will let me get file_handle as a PyObject *. Is there a way to change the value file_handle represents? I know I can return multiple values to a Python function call, but that isn't what I want to do in this case. Just for consistency with the C API I am making a module to represent.", "abstract": ""}, "answers": [{"id": 48797925, "score": 2, "vote": 0, "content": "You can't change what the caller's parameter refers to in the caller, all you can do is perform mutations of the object itself using its API. Basically, you received a copy of the caller's pointer, not a C++-style reference (nor a C-style double pointer that would give you access to a pointer declared in the caller), so you can't reassign the argument in the caller. In general, you don't want to try to perfectly reproduce C APIs (I'm assuming your C API uses double-pointers to allow reassigning the value in the caller?) in Python APIs. That's how PHP operates, and it makes for terribly inconsistent APIs that often take no advantage of being in a high level language. This case is doubly-fraught because, when used properly with with statements, file-like objects actually have multiple references (not C++ meaning) to them, the named variable (that was passed to your function) and one or more hidden references held inside the interpreter (to ensure the with statement has a consistent __exit__ to call, even if the caller deletes their own binding for the object). Even if you could somehow reassign the caller's argument, the with statement would still refer to the original file object, and it wouldn't be obvious to the caller that they needed to close (implicitly using with or explicitly calling close) the result again because your function replaced their object. Return multiple results (Py_BuildValue makes this easy), and the caller can replace their value if they want to.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/49183276/turning-an-input-parameter-into-an-output-parameter-in-python", "keywords": [], "tags": ["python", "parameters", "output"], "question": {"id": 49183276, "title": "Turning an input parameter into an output parameter in Python", "content": "I have a Python script that takes several input parameters, one of which is the name of an output folder which will hold processed data. I want to be able to access that output folder variable as an output parameter as well. How do I do this? Note: This script is being used in an ArcGIS model. I need that output parameter to be an input for another process in the model.", "abstract": ""}, "answers": [{"id": 49184305, "score": 1, "vote": 0, "content": "Python is about to \"output\" variables (or parameters as you called them) in a few ways. If you would like the variables to be written to screen, you can use the print function. If you instead want this variable to be used for a different python script, you might want to consider writing a function. Functions can take variables as input and use them to do calculations, then return outputs. Lastly, you may want to consider placing your sys.argv commands inside of a conditions which only runs the commands if your script is run from the command line. This way the program will not be looking for command line arguments if someone used \"import\" on your script instead of running it from the command line.", "abstract": ""}, {"id": 49183847, "score": 1, "vote": 0, "content": "If you have to put it in as an input, don't you have that information already? How are you calling the function if you don't know what your inputs are? Store the input as a variable before calling it, then use that variable wherever else you need it.", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/47899965/out-parameter-using-call-by-reference-for-user-defined-object-in-python", "keywords": [], "tags": ["python", "pass-by-reference", "pass-by-value", "user-defined-types", "out-parameters"], "question": {"id": 47899965, "title": "Out parameter using call by reference for User defined Object in Python", "content": "I have one User defined Object. I want to pass as reference (out parameter) so that value of input Object will be changed inside function and return to called function. This can be achieved by using list or Dictionary i.e mutable object. But How to achieve with User defined object without using list & Dictionary.\nCheck below code snippet as example:- May be i am missing something.", "abstract": ""}, "answers": []}, {"link": "https://stackoverflow.com/questions/22558739/without-pointers-can-i-pass-references-as-arguments-in-python", "keywords": [], "tags": ["python", "function", "pointers", "memory"], "question": {"id": 22558739, "title": "Without pointers, can I pass references as arguments in Python?", "content": "Since Python doesn't have pointers, I am wondering how I can pass a reference to an object through to a function instead of copying the entire object.  This is a very contrived example, but say I am writing a function like this: From my understanding, when I call some_function(y), Python allocates new space to store the argument value, then erases this data once the function has returned c and it's no longer needed. Since I am not actually altering the argument within some_function, how can I simply reference y from within the function instead of copying y when I pass it through?  In this case it doesn't matter much, but if y was very large (say a giant matrix), copying it could eat up some significant time and space.", "abstract": ""}, "answers": [{"id": 22559153, "score": 16, "vote": 0, "content": "Your understanding is, unfortunately, completely wrong. Python does not copy the value, nor does it allocate space for a new one. It passes a value which is itself a reference to the object. If you modify that object (rather than rebinding its name), then the original will be modified. Edit I wish you would stop worrying about memory allocation: Python is not C++, almost all of the time you don't need to think about memory.  It's easier to demonstrate rebinding via the use of something like a list: It might help if you think in terms of names rather than variables: inside the function, the name \"foo\" starts off being a reference to the original list, but then we change that name to point to a new, different list.", "abstract": ""}, {"id": 22559160, "score": 2, "vote": 0, "content": "Python parameters are always \"references\".  The way parameters in Python works and the way they are explained on the docs can be confusing and misleading to newcomers to the languages, specially if you have a background on other languages which allows you to choose between \"pass by value\" and \"pass by reference\". In Python terms, a \"reference\" is just a pointer with some more metadata to help the garbage collector do its job. And every variable and every parameter are always \"references\". So, internally, Python pass a \"pointer\" to each parameter. You can easily see this in this example: The variable X points to a list, and the parameter L is a copy of the \"pointer\" of the list, and not a copy of the list itself. Take care to note that this is not the same as \"pass-by-reference\" as C++ with the & qualifier, or pascal with the var qualifier.", "abstract": ""}]}]